<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>blockchain on vyorkin.org</title>
    <link>https://vyorkin.org/categories/blockchain/</link>
    <description>Recent content in blockchain on vyorkin.org</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Jul 2022 17:01:00 +0300</lastBuildDate><atom:link href="https://vyorkin.org/categories/blockchain/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CTF walkthrough, Ethernaut, #7 Delegation</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-7-delegation/</link>
      <pubDate>Thu, 28 Jul 2022 17:01:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-7-delegation/</guid>
      <description>The goals is to claim the ownership of the.
Analysis Exploit Key takeaways References Delegatecall from Solidity by Example. Delegatecall / Callcode and Libraries from the Solidity docs. </description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #6 Token</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-6-token/</link>
      <pubDate>Thu, 28 Jul 2022 11:10:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-6-token/</guid>
      <description>We start with the 20 tokens. To complete this challenge we need to get some more.
Here is the original Token contract:
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Token { mapping(address =&amp;gt; uint256) balances; uint256 public totalSupply; constructor(uint256 _initialSupply) { balances[msg.sender] = totalSupply = _initialSupply; } function transfer(address _to, uint256 _value) public returns (bool) { require(balances[msg.sender] - _value &amp;gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } Analysis Let&amp;rsquo;s review the transfer function:</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #5 Telephone</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-5-telephone/</link>
      <pubDate>Tue, 26 Jul 2022 15:47:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-5-telephone/</guid>
      <description>We need to claim ownership of the contract below to complete this level:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Telephone { address public owner; constructor() { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } } } Analysis The changeOwner function requires that tx.origin != msg.sender.
We know that tx.origin always refers to the EOA (externally owned account) that started the transaction irrespective of the stack of contracts invoked:</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #4 Coin Flip</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-4-coin-flip/</link>
      <pubDate>Tue, 26 Jul 2022 10:25:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-4-coin-flip/</guid>
      <description>To complete this challenge we need to predict the outcome of a coin flip game 10 times in a row. Here is the slightly altered version of the original smart contract:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract CoinFlip { uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block.number - 1)); if (lastHash == blockValue) { revert(); } lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ?</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #3 Fallout</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-3-fallout/</link>
      <pubDate>Mon, 25 Jul 2022 15:53:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-3-fallout/</guid>
      <description>To complete this level we need to become owner of the contract below (slightly modified to be compatible with Solidity ^0.8.2):
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; import &amp;#34;openzeppelin/utils/math/SafeMath.sol&amp;#34;; contract Fallout { using SafeMath for uint256; mapping(address =&amp;gt; uint256) allocations; address payable public owner; /* constructor */ function Fal1out() public payable { owner = payable(msg.sender); allocations[owner] = msg.value; } modifier onlyOwner() { require(msg.sender == owner, &amp;#34;caller is not the owner&amp;#34;); _; } function allocate() public payable { allocations[msg.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #2 Fallback</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-2-fallback/</link>
      <pubDate>Sat, 23 Jul 2022 23:25:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-2-fallback/</guid>
      <description>To complete this level we need become the owner of the contract and reduce its balance to zero.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; import &amp;#34;openzeppelin/utils/math/SafeMath.sol&amp;#34;; contract Fallback { using SafeMath for uint256; mapping(address =&amp;gt; uint256) public contributions; address payable public owner; constructor() { owner = payable(msg.sender); contributions[msg.sender] = 1000 * (1 ether); } modifier onlyOwner() { require(msg.sender == owner, &amp;#34;caller is not the owner&amp;#34;); _; } function contribute() public payable { require(msg.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #1 Hello Ethernaut</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-1-hello/</link>
      <pubDate>Thu, 21 Jul 2022 14:48:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-1-hello/</guid>
      <description>Intro The Ethernaut CTF game exists for more than 3 years already and has 26 challenges. The first one is a kind of introductory challenge that gives you steps on what you need to set up. If you have Metamask and open the browser&amp;rsquo;s console, you should see greeting messages:
Set up Originally, this game runs on the Rinkeby test network, but we&amp;rsquo;re going to play it locally. As I mentioned in the first post, we will use Foundry toolchain and here is the initial/empty project layout:</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Intro</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-intro/</link>
      <pubDate>Tue, 19 Jul 2022 00:40:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-intro/</guid>
      <description>CTF&amp;rsquo;s / War games CTF&amp;rsquo;s (Capture The Flags) are games/challenges focused on the Ethereum blockchain that help you to learn security techniques and concepts. These are the five popular CTF&amp;rsquo;s worth solving (in this order) to master your Ethereum/Solidity offensive security skills:
The Ethernaut is a wargame by OpenZeppelin. CaptureTheEther Damn Vulnerable DeFi Paradigm CTF 2021 Paradigm CTF 2022 (upcoming) Each level/challenge is a set of vulnerable smart contracts that you need to exploit.</description>
    </item>
    
  </channel>
</rss>
