<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>blockchain on vyorkin.org</title>
    <link>https://vyorkin.org/categories/blockchain/</link>
    <description>Recent content in blockchain on vyorkin.org</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 09 Aug 2022 20:03:00 +0300</lastBuildDate><atom:link href="https://vyorkin.org/categories/blockchain/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CTF walkthrough, Damn Vulnerable DeFi, #1 Unstoppable</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-1-unstoppable/</link>
      <pubDate>Tue, 09 Aug 2022 20:03:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-1-unstoppable/</guid>
      <description>There are only a few days left to prepare for the Paradigm CTF 2022. Hence I&amp;rsquo;m going to spend this time solving the Damn Vulnerable DeFi challenges and then concentrate on playing the Paradigm CTF 2021. Intro Damn Vulnerable DeFi is a CTF that simulates DeFi vulnerabilities created by @tinchoabbate. This game has 13 different levels featuring popular DeFi primitives such as lash loans, price oracles, governance, lending pools, integrations with Uniswap v2, Gnosis Safe wallets, timelocks, NFTs, upgradeability patterns and more.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #14 Gatekeeper One</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-14-gatekeeper-one/</link>
      <pubDate>Thu, 04 Aug 2022 12:24:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-14-gatekeeper-one/</guid>
      <description>To solve this challenge we must register as an entrant.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; import &amp;#34;forge-std/console2.sol&amp;#34;; contract GatekeeperOne { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _; } modifier gateTwo() { require(gasleft() % 8191 == 0); _; } modifier gateThree(bytes8 _gateKey) { require( uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &amp;#34;GatekeeperOne: invalid gateThree part one&amp;#34; ); require( uint32(uint64(_gateKey)) != uint64(_gateKey), &amp;#34;GatekeeperOne: invalid gateThree part two&amp;#34; ); require( uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &amp;#34;GatekeeperOne: invalid gateThree part three&amp;#34; ); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #13 Privacy</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-13-privacy/</link>
      <pubDate>Thu, 04 Aug 2022 11:27:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-13-privacy/</guid>
      <description>The creator of this contract was careful enough to protect the sensitive areas of its storage. Unlock this contract to beat the level.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Privacy { bool public locked = true; uint256 public ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(block.timestamp); bytes32[3] private data; constructor(bytes32[3] memory _data) { data = _data; } function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } /* A bunch of super advanced solidity algorithms.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #12 Elevator</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-12-elevator/</link>
      <pubDate>Wed, 03 Aug 2022 19:58:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-12-elevator/</guid>
      <description>To solve this challenge we have to set the top state variable to true.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; interface Building { function isLastFloor(uint256) external returns (bool); } contract Elevator { bool public top; uint256 public floor; function goTo(uint256 _floor) public { Building building = Building(msg.sender); if (!building.isLastFloor(_floor)) { floor = _floor; top = building.isLastFloor(floor); } } } Analysis Let&amp;rsquo;s go over the goTo function:
function goTo(uint256 _floor) public { Building building = Building(msg.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #12 Elevator</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-12-evelator/</link>
      <pubDate>Wed, 03 Aug 2022 19:58:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-12-evelator/</guid>
      <description>To solve this challenge we have to set the top state variable to true.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; interface Building { function isLastFloor(uint256) external returns (bool); } contract Elevator { bool public top; uint256 public floor; function goTo(uint256 _floor) public { Building building = Building(msg.sender); if (!building.isLastFloor(_floor)) { floor = _floor; top = building.isLastFloor(floor); } } } Analysis Let&amp;rsquo;s go over the goTo function:
function goTo(uint256 _floor) public { Building building = Building(msg.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #11 Re-entrancy</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-11-re-entrancy/</link>
      <pubDate>Tue, 02 Aug 2022 11:57:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-11-re-entrancy/</guid>
      <description>The objective of this challenge is to steal all the funds from the contract.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Reentrance { mapping(address =&amp;gt; uint256) public balances; function donate(address _to) public payable { balances[_to] += msg.value; } function balanceOf(address _who) public view returns (uint256 balance) { return balances[_who]; } function withdraw(uint256 _amount) public { if (balances[msg.sender] &amp;gt;= _amount) { (bool result, ) = msg.sender.call{value: _amount}(&amp;#34;&amp;#34;); if (result) { _amount; } unchecked { balances[msg.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #10 King</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-10-king/</link>
      <pubDate>Mon, 01 Aug 2022 15:56:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-10-king/</guid>
      <description>The goal of this level is to break the game defined by the King contract.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract King { address payable king; address payable public owner; uint256 public prize; constructor() payable { owner = payable(msg.sender); king = payable(msg.sender); prize = msg.value; } receive() external payable { require(msg.value &amp;gt;= prize || msg.sender == owner); king.transfer(msg.value); king = payable(msg.sender); prize = msg.value; } function _king() public view returns (address payable) { return king; } } Here is how the game checks if we passed:</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #9 Vault</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-9-vault/</link>
      <pubDate>Sat, 30 Jul 2022 19:01:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-9-vault/</guid>
      <description>We need to unlock the Vault smart contract to pass the level.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Vault { bool public locked; bytes32 private password; constructor(bytes32 _password) public { locked = true; password = _password; } function unlock(bytes32 _password) public { if (password == _password) { locked = false; } } } Analysis Let&amp;rsquo;s look at the state variables:
bool public locked; bytes32 private password; In EVM storage is a key-value store that maps 256-bit words to 256-bit words and is accessed with EVM’s SSTORE~/~SLOAD instructions.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #8 Force</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-8-force/</link>
      <pubDate>Fri, 29 Jul 2022 16:29:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-8-force/</guid>
      <description>To complete this challenge we need to make the balance of the Force contract greater than zero.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Force {/* MEOW ? /\_/\ / ____/ o o \ /~____ =ø= / (______)__m_m) */} Thoughts The contract has nothing in it, except the ASCII-art of a cat. It doesn&amp;rsquo;t have a receive, fallback function, or any other payable function:
If neither a receive Ether nor a payable fallback function is present, the contract cannot receive Ether through regular transactions and throws an exception.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #7 Delegation</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-7-delegation/</link>
      <pubDate>Fri, 29 Jul 2022 13:18:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-7-delegation/</guid>
      <description>The goals is to claim the ownership of the Delegate contract.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Delegate { address public owner; constructor(address _owner) { owner = _owner; } function pwn() public { owner = msg.sender; } } contract Delegation { address public owner; Delegate delegate; constructor(address _delegateAddress) { delegate = Delegate(_delegateAddress); owner = msg.sender; } fallback() external { (bool result, ) = address(delegate).delegatecall(msg.data); if (result) { this; } } } Analysis We have two contracts: the Delegate and the Delegation.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #6 Token</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-6-token/</link>
      <pubDate>Thu, 28 Jul 2022 11:10:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-6-token/</guid>
      <description>We start with the 20 tokens. To complete this challenge we need to get some more.
Here is the original Token contract:
// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Token { mapping(address =&amp;gt; uint256) balances; uint256 public totalSupply; constructor(uint256 _initialSupply) { balances[msg.sender] = totalSupply = _initialSupply; } function transfer(address _to, uint256 _value) public returns (bool) { require(balances[msg.sender] - _value &amp;gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } Analysis Let&amp;rsquo;s go line by line and see what we can come up with.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #5 Telephone</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-5-telephone/</link>
      <pubDate>Tue, 26 Jul 2022 15:47:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-5-telephone/</guid>
      <description>We need to claim ownership of the contract below to complete this level:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Telephone { address public owner; constructor() { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } } } Analysis The changeOwner function requires that tx.origin != msg.sender.
We know that tx.origin always refers to the EOA (externally owned account) that started the transaction irrespective of the stack of contracts invoked:</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #4 Coin Flip</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-4-coin-flip/</link>
      <pubDate>Tue, 26 Jul 2022 10:25:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-4-coin-flip/</guid>
      <description>To complete this challenge we need to predict the outcome of a coin flip game 10 times in a row. Here is the slightly altered version of the original smart contract:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract CoinFlip { uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block.number - 1)); if (lastHash == blockValue) { revert(); } lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ?</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #3 Fallout</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-3-fallout/</link>
      <pubDate>Mon, 25 Jul 2022 15:53:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-3-fallout/</guid>
      <description>To complete this level we need to become owner of the contract below (slightly modified to be compatible with Solidity ^0.8.2):
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; import &amp;#34;openzeppelin/utils/math/SafeMath.sol&amp;#34;; contract Fallout { using SafeMath for uint256; mapping(address =&amp;gt; uint256) allocations; address payable public owner; /* constructor */ function Fal1out() public payable { owner = payable(msg.sender); allocations[owner] = msg.value; } modifier onlyOwner() { require(msg.sender == owner, &amp;#34;caller is not the owner&amp;#34;); _; } function allocate() public payable { allocations[msg.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #2 Fallback</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-2-fallback/</link>
      <pubDate>Sat, 23 Jul 2022 23:25:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-2-fallback/</guid>
      <description>To complete this level we need become the owner of the contract and reduce its balance to zero.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Fallback { mapping(address =&amp;gt; uint256) public contributions; address payable public owner; constructor() { owner = payable(msg.sender); contributions[msg.sender] = 1000 * (1 ether); } modifier onlyOwner() { require(msg.sender == owner, &amp;#34;caller is not the owner&amp;#34;); _; } function contribute() public payable { require(msg.value &amp;lt; 0.001 ether, &amp;#34;msg.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #1 Hello Ethernaut</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-1-hello/</link>
      <pubDate>Thu, 21 Jul 2022 14:48:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-1-hello/</guid>
      <description>Intro The Ethernaut CTF game exists for more than 3 years already and has 26 challenges. The first one is a kind of introductory challenge that gives you steps on what you need to set up. If you have Metamask and open the browser&amp;rsquo;s console, you should see greeting messages:
Set up Originally, this game runs on the Rinkeby test network, but we&amp;rsquo;re going to play it locally. As I mentioned in the first post, we will use Foundry toolchain and here is the initial/empty project layout:</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Intro</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-intro/</link>
      <pubDate>Tue, 19 Jul 2022 00:40:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-intro/</guid>
      <description>CTF&amp;rsquo;s / War games CTF&amp;rsquo;s (Capture The Flags) are games/challenges focused on the Ethereum blockchain that help you to learn security techniques and concepts. These are the five popular CTF&amp;rsquo;s worth solving (in this order) to master your Ethereum/Solidity offensive security skills:
The Ethernaut is a wargame by OpenZeppelin. CaptureTheEther Damn Vulnerable DeFi Paradigm CTF 2021 Paradigm CTF 2022 (upcoming) Each level/challenge is a set of vulnerable smart contracts that you need to exploit.</description>
    </item>
    
  </channel>
</rss>
