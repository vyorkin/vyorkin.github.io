<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>compilers on vyorkin.org</title>
    <link>https://vyorkin.org/categories/compilers/</link>
    <description>Recent content in compilers on vyorkin.org</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Nov 2019 20:36:00 +0300</lastBuildDate>
    
	<atom:link href="https://vyorkin.org/categories/compilers/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Making of Tiger #3, Parsing</title>
      <link>https://vyorkin.org/posts/making-of-tiger-3-parsing/</link>
      <pubDate>Thu, 28 Nov 2019 20:36:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-3-parsing/</guid>
      <description>Intro In this chapter we’re going to build a parser for our Tiger language. First, let’s do a quick recap of some important concepts of the theory behind programming language parsers:
 Parser generator is the most common type of compiler-compiler’s. It takes some formal grammar (typically it is a context-free grammar in BNF or EBNF form), that defines a syntax of a programming language.  Tiger grammar with Menhir While reading the current paragraph I highly recommend consulting the Tiger Language Reference Manual that has a precise description (along with a BNF notation) of everything we’re going to define below.</description>
    </item>
    
    <item>
      <title>Making of Tiger #2, Lexical Analysis</title>
      <link>https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/</link>
      <pubDate>Tue, 26 Nov 2019 19:10:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/</guid>
      <description>Intro We need a way to translate a program written in one (human-friendly) language to another (machine-specific) language. Generally, this work is splitted into 2 parts: analysis and synthesis.
The synthesis-part (back end) is responsible for the code generation and optimizations.
Analysis-part (front end) is responsible for breaking the program apart to understand its structure and meaning. There are 3 commonly used analysis phases:
 Lexical – breaking a sequence of characters into sequence of individual tokens (words) Syntax – parsing and checking that we have a valid sequnce of tokens Semantic – gathering the program’s meaning, making sure that declarations and statements of program are semantically correct, this usually includes type checking  So, in this blog posts we’ll focus on implementing the lexical analysis phase.</description>
    </item>
    
    <item>
      <title>Making of Tiger #6, Stack frames</title>
      <link>https://vyorkin.org/posts/making-of-tiger-6-stack-frames/</link>
      <pubDate>Tue, 27 Aug 2019 13:00:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-6-stack-frames/</guid>
      <description>Intro In this post we&amp;rsquo;re going to add support for stack frames. Here I&amp;rsquo;ve made some notes while reading the chapter 6 to make sure I understand things clearly.
Stack A stack is a region of memory that grows downward and shrinks upward (like icicles). The top of the stack is it&amp;rsquo;s lowest memory address. We treat stack as a big array, with a special register &amp;ndash; the stack pointer (SP).</description>
    </item>
    
    <item>
      <title>Making of Tiger #1, Intro</title>
      <link>https://vyorkin.org/posts/making-of-tiger-1-intro/</link>
      <pubDate>Fri, 23 Aug 2019 10:31:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-1-intro/</guid>
      <description>Recently I&amp;rsquo;ve started reading the book by Andrew W. Appel titled Modern compiler implementation in ML. I&amp;rsquo;ve picked it up because I&amp;rsquo;ve heard some really good reviews about the ML version of it. Also there are other editions available that use C and Java. Each chapter covers a single phase of the compilation process and comes with some initial ML code and programming excercies. At the end you will have a working optimizing compiler.</description>
    </item>
    
  </channel>
</rss>