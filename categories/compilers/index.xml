<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Compilers on vyorkin.org</title>
    <link>http://localhost:1313/categories/compilers/</link>
    <description>Recent content in Compilers on vyorkin.org</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Sat, 21 Sep 2019 16:53:00 +0300</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/compilers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Making of Tiger #6, Stack frames</title>
      <link>http://localhost:1313/posts/making-of-tiger-6-stack-frames/</link>
      <pubDate>Sat, 21 Sep 2019 16:53:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/making-of-tiger-6-stack-frames/</guid>
      <description>Intro Link to heading In this post we&amp;rsquo;re going to add support for stack frames. Here I&amp;rsquo;ve made some notes while reading the chapter 6 to make sure I understand things clearly.&#xA;Stack Link to heading A stack is a region of memory that grows downward and shrinks upward (like icicles). The top of the stack is it&amp;rsquo;s lowest memory address. We treat stack as a big array, with a special register &amp;ndash; the stack pointer (SP).</description>
    </item>
    <item>
      <title>Making of Tiger #5, Semantic Analysis</title>
      <link>http://localhost:1313/posts/making-of-tiger-5-semantic-analysis/</link>
      <pubDate>Mon, 16 Sep 2019 23:16:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/making-of-tiger-5-semantic-analysis/</guid>
      <description>Intro Link to heading I really enjoyed working through this chapter, but at the same time implementing the type-checking phase was a bit more difficult than working on AST, parser or lexer from the previous chapters.</description>
    </item>
    <item>
      <title>Making of Tiger #4, Abstract Syntax</title>
      <link>http://localhost:1313/posts/making-of-tiger-4-abstact-syntax/</link>
      <pubDate>Sat, 14 Sep 2019 02:01:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/making-of-tiger-4-abstact-syntax/</guid>
      <description> Intro Link to heading </description>
    </item>
    <item>
      <title>Making of Tiger #2, Lexical Analysis</title>
      <link>http://localhost:1313/posts/making-of-tiger-2-lexical-analysis/</link>
      <pubDate>Fri, 23 Aug 2019 00:01:00 +0300</pubDate>
      <guid>http://localhost:1313/posts/making-of-tiger-2-lexical-analysis/</guid>
      <description>Intro Link to heading We need a way to translate a program written in one (human-friendly) language to another (machine-specific) language. Generally, this work is splitted into 2 parts: analysis and synthesis.&#xA;The synthesis-part (back end) is responsible for the code generation and optimizations.&#xA;Analysis-part (front end) is responsible for breaking the program apart to understand its structure and meaning. There are 3 commonly used analysis phases:&#xA;Lexical – breaking a sequence of characters into sequence of individual tokens (words) Syntax – parsing and checking that we have a valid sequence of tokens Semantic – gathering the program’s meaning, making sure that declarations and statements of program are semantically correct, this usually includes type checking In this post we’ll focus on implementing the lexical analysis phase.</description>
    </item>
  </channel>
</rss>
