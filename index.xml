<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>vyorkin.org</title>
    <link>https://vyorkin.org/</link>
    <description>Recent content on vyorkin.org</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 07 Dec 2019 18:23:00 +0300</lastBuildDate><atom:link href="https://vyorkin.org/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Proving TAPL in Coq (ch 3, WIP)</title>
      <link>https://vyorkin.org/posts/proving-tapl-in-coq-ch-3/</link>
      <pubDate>Sat, 07 Dec 2019 18:23:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/proving-tapl-in-coq-ch-3/</guid>
      <description>In order to understand things clearly and to learn Coq proof assistant at the same time, I&amp;rsquo;ve decided to do some proves while reading the TAPL book.
The code is on the GitHub.
For the excercises I want to use the ssreflect proof language instead of ltac. I&amp;rsquo;ll keep solutions to each chapter in a separate file. We&amp;rsquo;ll always work in the following context:
Set Implicit Arguments. Unset Strict Implicit. Unset Printing Implicit Defensive.</description>
    </item>
    
    <item>
      <title>Making of Tiger #3, Parsing</title>
      <link>https://vyorkin.org/posts/making-of-tiger-3-parsing/</link>
      <pubDate>Thu, 28 Nov 2019 20:36:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-3-parsing/</guid>
      <description>Intro    In this chapter we’re going to build a parser for our Tiger language. First, let’s do a quick recap of some important concepts of the theory behind programming language parsers:
 Parser generator is the most common type of compiler-compiler’s. It takes some formal grammar (typically it is a context-free grammar in BNF or EBNF form), that defines a syntax of a programming language.  Tiger grammar with Menhir    While reading the current paragraph I highly recommend consulting the Tiger Language Reference Manual that has a precise description (along with a BNF notation) of everything we’re going to define below.</description>
    </item>
    
    <item>
      <title>Making of Tiger #2, Lexical Analysis</title>
      <link>https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/</link>
      <pubDate>Tue, 26 Nov 2019 19:10:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/</guid>
      <description>Intro    We need a way to translate a program written in one (human-friendly) language to another (machine-specific) language. Generally, this work is splitted into 2 parts: analysis and synthesis.
The synthesis-part (back end) is responsible for the code generation and optimizations.
Analysis-part (front end) is responsible for breaking the program apart to understand its structure and meaning. There are 3 commonly used analysis phases:
 Lexical – breaking a sequence of characters into sequence of individual tokens (words) Syntax – parsing and checking that we have a valid sequnce of tokens Semantic – gathering the program’s meaning, making sure that declarations and statements of program are semantically correct, this usually includes type checking  So, in this blog posts we’ll focus on implementing the lexical analysis phase.</description>
    </item>
    
    <item>
      <title>Making of Tiger #6, Stack frames</title>
      <link>https://vyorkin.org/posts/making-of-tiger-6-stack-frames/</link>
      <pubDate>Tue, 27 Aug 2019 13:00:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-6-stack-frames/</guid>
      <description>Intro    In this post we&amp;rsquo;re going to add support for stack frames. Here I&amp;rsquo;ve made some notes while reading the chapter 6 to make sure I understand things clearly.
Stack    A stack is a region of memory that grows downward and shrinks upward (like icicles). The top of the stack is it&amp;rsquo;s lowest memory address. We treat stack as a big array, with a special register &amp;ndash; the stack pointer (SP).</description>
    </item>
    
    <item>
      <title>Making of Tiger #1, Intro</title>
      <link>https://vyorkin.org/posts/making-of-tiger-1-intro/</link>
      <pubDate>Fri, 23 Aug 2019 10:31:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-1-intro/</guid>
      <description>Recently I&amp;rsquo;ve started reading the book by Andrew W. Appel titled Modern compiler implementation in ML. I&amp;rsquo;ve picked it up because I&amp;rsquo;ve heard some really good reviews about the ML version of it. Also there are other editions available that use C and Java. Each chapter covers a single phase of the compilation process and comes with some initial ML code and programming excercies. At the end you will have a working optimizing compiler.</description>
    </item>
    
    <item>
      <title>About me</title>
      <link>https://vyorkin.org/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vyorkin.org/about/</guid>
      <description>Hello! My name is Vasiliy Yorkin and this is my personal website.
Currently I&amp;rsquo;m doing a blockchain development with the Substrate framework.
Also I&amp;rsquo;m interested in statically typed functional programming, compilers, type theory and formal verification. These days I spend most of my spare time exploring the world of FP, formal methods and category theory.
In this blog I&amp;rsquo;m going to write about some of the things I do. Particularly about Haskell, PureScript and OCaml, but sometimes about Nix (and NixOS), Coq and other technologies and ideas I&amp;rsquo;m care about.</description>
    </item>
    
  </channel>
</rss>
