<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>vyorkin.org</title>
    <link>https://vyorkin.org/</link>
    <description>Recent content on vyorkin.org</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 22 Jul 2022 17:25:00 +0300</lastBuildDate><atom:link href="https://vyorkin.org/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CTF walkthrough, Ethernaut, #2 Fallback</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-2-fallback/</link>
      <pubDate>Fri, 22 Jul 2022 17:25:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-2-fallback/</guid>
      <description> This is a first example of level factory contract:
// SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import &amp;#34;../../game/LevelFactory.sol&amp;#34;; import &amp;#34;./Fallback.sol&amp;#34;; contract FallbackFactory is LevelFactory { function createInstance(address _player) public payable override returns (address) { _player; Fallback instance = new Fallback(); return address(instance); } function validateInstance(address payable _instance, address _player) public override returns (bool) { Fallback instance = Fallback(_instance); return instance.owner() == _player &amp;amp;&amp;amp; address(instance).balance == 0; } } </description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #1 Hello Ethernaut</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-1-hello/</link>
      <pubDate>Thu, 21 Jul 2022 14:48:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-1-hello/</guid>
      <description>Intro The Ethernaut CTF game exists for more than 3 years already and has 26 challenges. The first one is a kind of introductory challenge that gives you steps on what you need to set up. If you have Metamask and open the browser&amp;rsquo;s console, you should see greeting messages:
Set up Originally, this game runs on the Rinkeby test network, but we&amp;rsquo;re going to play it locally. As I mentioned in the first post, we will use Foundry toolchain and here is the initial/empty project layout:</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Intro</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-intro/</link>
      <pubDate>Tue, 19 Jul 2022 00:40:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-intro/</guid>
      <description>CTF&amp;rsquo;s / War games CTF&amp;rsquo;s (Capture The Flags) are games/challenges focused on the Ethereum blockchain that help you to learn security techniques and concepts. These are the five popular CTF&amp;rsquo;s worth solving (in this order) to master your Ethereum/Solidity offensive security skills:
The Ethernaut is a wargame by OpenZeppelin. CaptureTheEther Damn Vulnerable DeFi Paradigm CTF 2021 Paradigm CTF 2022 (upcoming) Each level/challenge is a set of vulnerable smart contracts that you need to exploit.</description>
    </item>
    
    <item>
      <title>Simple betting smart contract</title>
      <link>https://vyorkin.org/posts/simple-betting-smart-contract/</link>
      <pubDate>Fri, 20 May 2022 12:20:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/simple-betting-smart-contract/</guid>
      <description>Test</description>
    </item>
    
    <item>
      <title>Making of Tiger #1, Intro</title>
      <link>https://vyorkin.org/posts/making-of-tiger-1-intro/</link>
      <pubDate>Sun, 31 Oct 2021 12:39:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-1-intro/</guid>
      <description>Recently I&amp;rsquo;ve started reading the book by Andrew W. Appel titled Modern compiler implementation in ML. I&amp;rsquo;ve picked it up because I&amp;rsquo;ve heard some really good reviews about the ML version of it. Also there are other editions available that use C and Java. Each chapter covers a single phase of the compilation process and comes with some initial ML code and programming excercies. At the end you will have a working optimizing compiler.</description>
    </item>
    
    <item>
      <title>Making of Tiger #2, Lexical Analysis</title>
      <link>https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/</link>
      <pubDate>Sun, 31 Oct 2021 12:39:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/</guid>
      <description>Intro We need a way to translate a program written in one (human-friendly) language to another (machine-specific) language. Generally, this work is splitted into 2 parts: analysis and synthesis.
The synthesis-part (back end) is responsible for the code generation and optimizations.
Analysis-part (front end) is responsible for breaking the program apart to understand its structure and meaning. There are 3 commonly used analysis phases:
Lexical – breaking a sequence of characters into sequence of individual tokens (words) Syntax – parsing and checking that we have a valid sequence of tokens Semantic – gathering the program’s meaning, making sure that declarations and statements of program are semantically correct, this usually includes type checking In this post we’ll focus on implementing the lexical analysis phase.</description>
    </item>
    
    <item>
      <title>Making of Tiger #3, Parsing</title>
      <link>https://vyorkin.org/posts/making-of-tiger-3-parsing/</link>
      <pubDate>Sun, 31 Oct 2021 12:39:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-3-parsing/</guid>
      <description>Intro In this chapter we’re going to build a parser for our Tiger language. First, let’s do a quick recap of some important concepts of the theory behind programming language parsers:
Parser generator is the most common type of compiler-compiler’s. It takes some formal grammar (typically it is a context-free grammar in BNF or EBNF form), that defines a syntax of a programming language. Tiger grammar with Menhir While reading the current paragraph I highly recommend consulting the Tiger Language Reference Manual that has a precise description (along with a BNF notation) of everything we’re going to define below.</description>
    </item>
    
    <item>
      <title>Making of Tiger #6, Stack frames</title>
      <link>https://vyorkin.org/posts/making-of-tiger-6-stack-frames/</link>
      <pubDate>Sun, 31 Oct 2021 12:39:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-6-stack-frames/</guid>
      <description>Intro In this post we&amp;rsquo;re going to add support for stack frames. Here I&amp;rsquo;ve made some notes while reading the chapter 6 to make sure I understand things clearly.
Stack A stack is a region of memory that grows downward and shrinks upward (like icicles). The top of the stack is it&amp;rsquo;s lowest memory address. We treat stack as a big array, with a special register &amp;ndash; the stack pointer (SP).</description>
    </item>
    
    <item>
      <title>About me</title>
      <link>https://vyorkin.org/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vyorkin.org/about/</guid>
      <description>Hello! My name is Vasiliy Yorkin and this is my personal website.
Currently I&amp;rsquo;m doing blockchain R&amp;amp;D with the Substrate framework and EVM/Solidity. I&amp;rsquo;m interested in blockchain security, DeFi, statically typed functional programming, compilers, type theory and formal verification.
In this blog I&amp;rsquo;m going to write about some of the things I do. Occasionally I tweet about those and other things on Twitter. Most of my open source work is available on GitHub.</description>
    </item>
    
  </channel>
</rss>
