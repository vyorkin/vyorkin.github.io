<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on vyorkin.org</title>
    <link>https://vyorkin.org/posts/</link>
    <description>Recent content in Posts on vyorkin.org</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Tue, 03 Sep 2024 13:40:00 +0300</lastBuildDate>
    <atom:link href="https://vyorkin.org/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Designing a Theorem Prover, Part 1</title>
      <link>https://vyorkin.org/posts/designing-a-theorem-prover-part-1/</link>
      <pubDate>Tue, 03 Sep 2024 13:40:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/designing-a-theorem-prover-part-1/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#intro&#34; &gt;Intro&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#automated-theorem-proving&#34; &gt;Automated Theorem Proving&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#general-properties&#34; &gt;General Properties&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#sequent-calculus&#34; &gt;Sequent Calculus&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#lk-inference-rules&#34; &gt;LK Inference Rules&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;!-- raw HTML omitted --&gt;&#xA;&lt;p&gt;This is a summary.&lt;/p&gt;</description>
    </item>
    <item>
      <title>CTF walkthrough, Damn Vulnerable DeFi, #8 Puppet</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-8-puppet/</link>
      <pubDate>Tue, 15 Nov 2022 12:30:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-8-puppet/</guid>
      <description>Challenge Link to heading There&amp;rsquo;s a huge lending pool borrowing Damn Valuable Tokens (DVTs), where you first need to deposit twice the borrow amount in ETH as collateral. The pool currently has 100000 DVTs in liquidity.&#xA;There&amp;rsquo;s a DVT market opened in an description Uniswap v1 exchange, currently with 10 ETH and 10 DVT in liquidity.&#xA;Starting with 25 ETH and 1000 DVTs in balance, you must steal all tokens from the lending pool.</description>
    </item>
    <item>
      <title>CTF walkthrough, Damn Vulnerable DeFi, #6 Selfie</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-6-selfie/</link>
      <pubDate>Wed, 02 Nov 2022 08:12:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-6-selfie/</guid>
      <description>After a short break, I&amp;rsquo;m back and excited to keep going with these CTF walkthrough series.&#xA;The current challenge is Selfie:&#xA;Challenge Link to heading A new cool lending pool has launched! It&amp;rsquo;s now offering flash loans of DVT tokens. Wow, and it even includes a really fancy governance mechanism to control it. What could go wrong, right? You start with no DVT tokens in balance, and the pool has 1.</description>
    </item>
    <item>
      <title>CTF walkthrough, Damn Vulnerable DeFi, #5 The rewarder</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-5-the-rewarder/</link>
      <pubDate>Wed, 17 Aug 2022 00:33:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-5-the-rewarder/</guid>
      <description>Challenge Link to heading Today we&amp;rsquo;re going to take a look at The Rewarder challenge:&#xA;There&amp;rsquo;s a pool offering rewards in tokens every 5 days for those who deposit their DVT tokens into it. Alice, Bob, Charlie and David have already deposited some DVT tokens, and have won their rewards! You don&amp;rsquo;t have any DVT tokens. But in the upcoming round, you must claim most rewards for yourself. Oh, by the way, rumours say a new pool has just landed on mainnet.</description>
    </item>
    <item>
      <title>CTF walkthrough, Damn Vulnerable DeFi, #4 Side entrance</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-4-side-entrance/</link>
      <pubDate>Thu, 11 Aug 2022 16:56:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-4-side-entrance/</guid>
      <description>Challenge Link to heading A surprisingly simple lending pool allows anyone to deposit ETH, and withdraw it at any point in time. This very simple lending pool has 1000 ETH in balance already, and is offering free flash loans using the deposited ETH to promote their system. You must take all ETH from the lending pool. Here is the lending pool contract:&#xA;// SPDX-License-Identifier: MIT pragma solidity 0.8.12; import {Address} from &amp;#34;openzeppelin-contracts/utils/Address.</description>
    </item>
    <item>
      <title>CTF walkthrough, Damn Vulnerable DeFi, #3 Truster</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-3-truster/</link>
      <pubDate>Wed, 10 Aug 2022 11:37:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-3-truster/</guid>
      <description>Challenge Link to heading More and more lending pools are offering flash loans. In this case, a new pool has launched that is offering flash loans of DVT tokens for free.&#xA;Currently the pool has 1 million DVT tokens in balance. And you have nothing.&#xA;But don&amp;rsquo;t worry, you might be able to take them all from the pool. In a single transaction.&#xA;// SPDX-License-Identifier: MIT pragma solidity 0.8.12; import {IERC20} from &amp;#34;openzeppelin-contracts/token/ERC20/IERC20.</description>
    </item>
    <item>
      <title>CTF walkthrough, Damn Vulnerable DeFi, #2 Naive Receiver</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-2-naive-receiver/</link>
      <pubDate>Tue, 09 Aug 2022 20:25:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-2-naive-receiver/</guid>
      <description>Challenge Link to heading There&amp;rsquo;s a lending pool offering quite expensive flash loans of Ether, which has 1000 ETH in balance.&#xA;You also see that a user has deployed a contract with 10 ETH in balance, capable of interacting with the lending pool and receiving flash loans of ETH.&#xA;Drain all ETH funds from the user&amp;rsquo;s contract. Doing it in a single transaction is a big plus ;)&#xA;Analysis Link to heading The challenge contains two contracts:</description>
    </item>
    <item>
      <title>CTF walkthrough, Damn Vulnerable DeFi, #1 Unstoppable</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-1-unstoppable/</link>
      <pubDate>Tue, 09 Aug 2022 20:03:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-damn-vulnerable-defi-1-unstoppable/</guid>
      <description>There are only a few days left to prepare for the Paradigm CTF 2022. Hence I&amp;rsquo;m going to spend this time solving the Damn Vulnerable DeFi challenges and then concentrate on playing the Paradigm CTF 2021. Intro Link to heading Damn Vulnerable DeFi is a CTF that simulates DeFi vulnerabilities created by @tinchoabbate. This game has 13 different levels featuring popular DeFi primitives such as lash loans, price oracles, governance, lending pools, integrations with Uniswap v2, Gnosis Safe wallets, timelocks, NFTs, upgradeability patterns and more.</description>
    </item>
    <item>
      <title>CTF walkthrough, Ethernaut, #14 Gatekeeper One</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-14-gatekeeper-one/</link>
      <pubDate>Thu, 04 Aug 2022 12:24:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-14-gatekeeper-one/</guid>
      <description>To solve this challenge we must register as an entrant.&#xA;// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; import &amp;#34;forge-std/console2.sol&amp;#34;; contract GatekeeperOne { address public entrant; modifier gateOne() { require(msg.sender != tx.origin); _; } modifier gateTwo() { require(gasleft() % 8191 == 0); _; } modifier gateThree(bytes8 _gateKey) { require( uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), &amp;#34;GatekeeperOne: invalid gateThree part one&amp;#34; ); require( uint32(uint64(_gateKey)) != uint64(_gateKey), &amp;#34;GatekeeperOne: invalid gateThree part two&amp;#34; ); require( uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), &amp;#34;GatekeeperOne: invalid gateThree part three&amp;#34; ); _; } function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) { entrant = tx.</description>
    </item>
    <item>
      <title>CTF walkthrough, Ethernaut, #13 Privacy</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-13-privacy/</link>
      <pubDate>Thu, 04 Aug 2022 11:27:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-13-privacy/</guid>
      <description>The creator of this contract was careful enough to protect the sensitive areas of its storage. Unlock this contract to beat the level.&#xA;// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Privacy { bool public locked = true; uint256 public ID = block.timestamp; uint8 private flattening = 10; uint8 private denomination = 255; uint16 private awkwardness = uint16(block.timestamp); bytes32[3] private data; constructor(bytes32[3] memory _data) { data = _data; } function unlock(bytes16 _key) public { require(_key == bytes16(data[2])); locked = false; } /* A bunch of super advanced solidity algorithms.</description>
    </item>
    <item>
      <title>CTF walkthrough, Ethernaut, #12 Elevator</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-12-elevator/</link>
      <pubDate>Wed, 03 Aug 2022 19:58:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-12-elevator/</guid>
      <description>To solve this challenge we have to set the top state variable to true.&#xA;// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; interface Building { function isLastFloor(uint256) external returns (bool); } contract Elevator { bool public top; uint256 public floor; function goTo(uint256 _floor) public { Building building = Building(msg.sender); if (!building.isLastFloor(_floor)) { floor = _floor; top = building.isLastFloor(floor); } } } Analysis Link to heading Let&amp;rsquo;s go over the goTo function:&#xA;function goTo(uint256 _floor) public { Building building = Building(msg.</description>
    </item>
    <item>
      <title>CTF walkthrough, Ethernaut, #11 Re-entrancy</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-11-re-entrancy/</link>
      <pubDate>Tue, 02 Aug 2022 11:57:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-11-re-entrancy/</guid>
      <description>The objective of this challenge is to steal all the funds from the contract.&#xA;// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Reentrance { mapping(address =&amp;gt; uint256) public balances; function donate(address _to) public payable { balances[_to] += msg.value; } function balanceOf(address _who) public view returns (uint256 balance) { return balances[_who]; } function withdraw(uint256 _amount) public { if (balances[msg.sender] &amp;gt;= _amount) { (bool result, ) = msg.sender.call{value: _amount}(&amp;#34;&amp;#34;); if (result) { _amount; } unchecked { balances[msg.</description>
    </item>
    <item>
      <title>CTF walkthrough, Ethernaut, #10 King</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-10-king/</link>
      <pubDate>Mon, 01 Aug 2022 15:56:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-10-king/</guid>
      <description>The goal of this level is to break the game defined by the King contract.&#xA;// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract King { address payable king; address payable public owner; uint256 public prize; constructor() payable { owner = payable(msg.sender); king = payable(msg.sender); prize = msg.value; } receive() external payable { require(msg.value &amp;gt;= prize || msg.sender == owner); king.transfer(msg.value); king = payable(msg.sender); prize = msg.value; } function _king() public view returns (address payable) { return king; } } Here is how the game checks if we passed:</description>
    </item>
    <item>
      <title>CTF walkthrough, Ethernaut, #9 Vault</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-9-vault/</link>
      <pubDate>Sat, 30 Jul 2022 19:01:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-9-vault/</guid>
      <description>We need to unlock the Vault smart contract to pass the level.&#xA;// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Vault { bool public locked; bytes32 private password; constructor(bytes32 _password) public { locked = true; password = _password; } function unlock(bytes32 _password) public { if (password == _password) { locked = false; } } } Analysis Link to heading Let&amp;rsquo;s look at the state variables:&#xA;bool public locked; bytes32 private password; In EVM storage is a key-value store that maps 256-bit words to 256-bit words and is accessed with EVM’s SSTORE~/~SLOAD instructions.</description>
    </item>
    <item>
      <title>CTF walkthrough, Ethernaut, #8 Force</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-8-force/</link>
      <pubDate>Fri, 29 Jul 2022 16:29:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-8-force/</guid>
      <description>To complete this challenge we need to make the balance of the Force contract greater than zero.&#xA;// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Force {/* MEOW ? /\_/\ / ____/ o o \ /~____ =ø= / (______)__m_m) */} Thoughts Link to heading The contract has nothing in it, except the ASCII-art of a cat. It doesn&amp;rsquo;t have a receive, fallback function, or any other payable function:&#xA;If neither a receive Ether nor a payable fallback function is present, the contract cannot receive Ether through regular transactions and throws an exception.</description>
    </item>
    <item>
      <title>CTF walkthrough, Ethernaut, #7 Delegation</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-7-delegation/</link>
      <pubDate>Fri, 29 Jul 2022 13:18:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-7-delegation/</guid>
      <description>The goals is to claim the ownership of the Delegate contract.&#xA;// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Delegate { address public owner; constructor(address _owner) { owner = _owner; } function pwn() public { owner = msg.sender; } } contract Delegation { address public owner; Delegate delegate; constructor(address _delegateAddress) { delegate = Delegate(_delegateAddress); owner = msg.sender; } fallback() external { (bool result, ) = address(delegate).delegatecall(msg.data); if (result) { this; } } } Analysis Link to heading We have two contracts: the Delegate and the Delegation.</description>
    </item>
    <item>
      <title>CTF walkthrough, Ethernaut, #6 Token</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-6-token/</link>
      <pubDate>Thu, 28 Jul 2022 11:10:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-6-token/</guid>
      <description>We start with the 20 tokens. To complete this challenge we need to get some more.&#xA;Here is the original Token contract:&#xA;// SPDX-License-Identifier: MIT pragma solidity ^0.6.0; contract Token { mapping(address =&amp;gt; uint256) balances; uint256 public totalSupply; constructor(uint256 _initialSupply) { balances[msg.sender] = totalSupply = _initialSupply; } function transfer(address _to, uint256 _value) public returns (bool) { require(balances[msg.sender] - _value &amp;gt;= 0); balances[msg.sender] -= _value; balances[_to] += _value; return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } Analysis Link to heading Let&amp;rsquo;s go line by line and see what we can come up with.</description>
    </item>
    <item>
      <title>CTF walkthrough, Ethernaut, #5 Telephone</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-5-telephone/</link>
      <pubDate>Tue, 26 Jul 2022 15:47:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-5-telephone/</guid>
      <description>We need to claim ownership of the contract below to complete this level:&#xA;// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Telephone { address public owner; constructor() { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } } } Analysis Link to heading The changeOwner function requires that tx.origin != msg.sender.&#xA;We know that tx.origin always refers to the EOA (externally owned account) that started the transaction irrespective of the stack of contracts invoked:</description>
    </item>
    <item>
      <title>CTF walkthrough, Ethernaut, #4 Coin Flip</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-4-coin-flip/</link>
      <pubDate>Tue, 26 Jul 2022 10:25:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-4-coin-flip/</guid>
      <description>To complete this challenge we need to predict the outcome of a coin flip game 10 times in a row. Here is the slightly altered version of the original smart contract:&#xA;// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract CoinFlip { uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block.number - 1)); if (lastHash == blockValue) { revert(); } lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ?</description>
    </item>
    <item>
      <title>CTF walkthrough, Ethernaut, #3 Fallout</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-3-fallout/</link>
      <pubDate>Mon, 25 Jul 2022 15:53:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-3-fallout/</guid>
      <description>To complete this level we need to become owner of the contract below (slightly modified to be compatible with Solidity ^0.8.2):&#xA;// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; import &amp;#34;openzeppelin/utils/math/SafeMath.sol&amp;#34;; contract Fallout { using SafeMath for uint256; mapping(address =&amp;gt; uint256) allocations; address payable public owner; /* constructor */ function Fal1out() public payable { owner = payable(msg.sender); allocations[owner] = msg.value; } modifier onlyOwner() { require(msg.sender == owner, &amp;#34;caller is not the owner&amp;#34;); _; } function allocate() public payable { allocations[msg.</description>
    </item>
    <item>
      <title>CTF walkthrough, Ethernaut, #2 Fallback</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-2-fallback/</link>
      <pubDate>Sat, 23 Jul 2022 23:25:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-2-fallback/</guid>
      <description>To complete this level we need become the owner of the contract and reduce its balance to zero.&#xA;// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Fallback { mapping(address =&amp;gt; uint256) public contributions; address payable public owner; constructor() { owner = payable(msg.sender); contributions[msg.sender] = 1000 * (1 ether); } modifier onlyOwner() { require(msg.sender == owner, &amp;#34;caller is not the owner&amp;#34;); _; } function contribute() public payable { require(msg.value &amp;lt; 0.001 ether, &amp;#34;msg.</description>
    </item>
    <item>
      <title>CTF walkthrough, Ethernaut, #1 Hello Ethernaut</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-1-hello/</link>
      <pubDate>Thu, 21 Jul 2022 14:48:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-1-hello/</guid>
      <description>Intro Link to heading The Ethernaut CTF game exists for more than 3 years already and has 26 challenges. The first one is a kind of introductory challenge that gives you steps on what you need to set up. If you have Metamask and open the browser&amp;rsquo;s console, you should see greeting messages:&#xA;Set up Link to heading Originally, this game runs on the Rinkeby test network, but we&amp;rsquo;re going to play it locally.</description>
    </item>
    <item>
      <title>CTF walkthrough, Intro</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-intro/</link>
      <pubDate>Tue, 19 Jul 2022 00:40:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/ctf-walkthrough-intro/</guid>
      <description>CTF&amp;rsquo;s / War games Link to heading CTF&amp;rsquo;s (Capture The Flags) are games/challenges focused on the Ethereum blockchain that help you to learn security techniques and concepts. These are the five popular CTF&amp;rsquo;s worth solving (in this order) to master your Ethereum/Solidity offensive security skills:&#xA;The Ethernaut is a wargame by OpenZeppelin. CaptureTheEther Damn Vulnerable DeFi Paradigm CTF 2021 Paradigm CTF 2022 (upcoming) Each level/challenge is a set of vulnerable smart contracts that you need to exploit.</description>
    </item>
    <item>
      <title>Making of Tiger #6, Stack frames</title>
      <link>https://vyorkin.org/posts/making-of-tiger-6-stack-frames/</link>
      <pubDate>Sat, 21 Sep 2019 16:53:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/making-of-tiger-6-stack-frames/</guid>
      <description>Intro Link to heading In this post we&amp;rsquo;re going to add support for stack frames. Here I&amp;rsquo;ve made some notes while reading the chapter 6 to make sure I understand things clearly.&#xA;Stack Link to heading A stack is a region of memory that grows downward and shrinks upward (like icicles). The top of the stack is it&amp;rsquo;s lowest memory address. We treat stack as a big array, with a special register &amp;ndash; the stack pointer (SP).</description>
    </item>
    <item>
      <title>Making of Tiger #3, Parsing</title>
      <link>https://vyorkin.org/posts/making-of-tiger-3-parsing/</link>
      <pubDate>Sun, 08 Sep 2019 15:58:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/making-of-tiger-3-parsing/</guid>
      <description>Intro Link to heading In this chapter we’re going to build a parser for our Tiger language. First, let’s do a quick recap of some important concepts of the theory behind programming language parsers:&#xA;Parser generator is the most common type of compiler-compiler’s. It takes some formal grammar (typically it is a context-free grammar in BNF or EBNF form), that defines a syntax of a programming language. Tiger grammar with Menhir Link to heading While reading the current paragraph I highly recommend consulting the Tiger Language Reference Manual that has a precise description (along with a BNF notation) of everything we’re going to define below.</description>
    </item>
    <item>
      <title>Making of Tiger #2, Lexical Analysis</title>
      <link>https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/</link>
      <pubDate>Fri, 23 Aug 2019 00:01:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/</guid>
      <description>Intro Link to heading We need a way to translate a program written in one (human-friendly) language to another (machine-specific) language. Generally, this work is splitted into 2 parts: analysis and synthesis.&#xA;The synthesis-part (back end) is responsible for the code generation and optimizations.&#xA;Analysis-part (front end) is responsible for breaking the program apart to understand its structure and meaning. There are 3 commonly used analysis phases:&#xA;Lexical – breaking a sequence of characters into sequence of individual tokens (words) Syntax – parsing and checking that we have a valid sequence of tokens Semantic – gathering the program’s meaning, making sure that declarations and statements of program are semantically correct, this usually includes type checking In this post we’ll focus on implementing the lexical analysis phase.</description>
    </item>
    <item>
      <title>Making of Tiger #1, Intro</title>
      <link>https://vyorkin.org/posts/making-of-tiger-1-intro/</link>
      <pubDate>Thu, 22 Aug 2019 20:27:00 +0300</pubDate>
      <guid>https://vyorkin.org/posts/making-of-tiger-1-intro/</guid>
      <description>Recently I&amp;rsquo;ve started reading the book by Andrew W. Appel titled Modern compiler implementation in ML. I&amp;rsquo;ve picked it up because I&amp;rsquo;ve heard some really good reviews about the ML version of it. Also there are other editions available that use C and Java. Each chapter covers a single phase of the compilation process and comes with some initial ML code and programming excercies. At the end you will have a working optimizing compiler.</description>
    </item>
  </channel>
</rss>
