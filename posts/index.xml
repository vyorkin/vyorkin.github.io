<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on vyorkin.org</title>
    <link>https://vyorkin.org/posts/</link>
    <description>Recent content in Posts on vyorkin.org</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 26 Jul 2022 15:47:00 +0300</lastBuildDate><atom:link href="https://vyorkin.org/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CTF walkthrough, Ethernaut, #5 Telephone</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-5-telephone/</link>
      <pubDate>Tue, 26 Jul 2022 15:47:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-5-telephone/</guid>
      <description>We need to claim ownership of the contract below to complete this level:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract Telephone { address public owner; constructor() { owner = msg.sender; } function changeOwner(address _owner) public { if (tx.origin != msg.sender) { owner = _owner; } } } Analysis The changeOwner function requires that tx.origin != msg.sender.
We know that tx.origin always refers to the EOA (externally owned account) that started the transaction irrespective of the stack of contracts invoked:</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #4 Coin Flip</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-4-coin-flip/</link>
      <pubDate>Tue, 26 Jul 2022 10:25:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-4-coin-flip/</guid>
      <description>To complete this challenge we need to predict the outcome of a coin flip game 10 times in a row. Here is the slightly altered version of the original smart contract:
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; contract CoinFlip { uint256 public consecutiveWins; uint256 lastHash; uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968; constructor() { consecutiveWins = 0; } function flip(bool _guess) public returns (bool) { uint256 blockValue = uint256(blockhash(block.number - 1)); if (lastHash == blockValue) { revert(); } lastHash = blockValue; uint256 coinFlip = blockValue / FACTOR; bool side = coinFlip == 1 ?</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #3 Fallout</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-3-fallout/</link>
      <pubDate>Mon, 25 Jul 2022 15:53:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-3-fallout/</guid>
      <description>To complete this level we need to become owner of the contract below (slightly modified to be compatible with Solidity ^0.8.2):
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; import &amp;#34;openzeppelin/utils/math/SafeMath.sol&amp;#34;; contract Fallout { using SafeMath for uint256; mapping(address =&amp;gt; uint256) allocations; address payable public owner; /* constructor */ function Fal1out() public payable { owner = payable(msg.sender); allocations[owner] = msg.value; } modifier onlyOwner() { require(msg.sender == owner, &amp;#34;caller is not the owner&amp;#34;); _; } function allocate() public payable { allocations[msg.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #2 Fallback</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-2-fallback/</link>
      <pubDate>Sat, 23 Jul 2022 23:25:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-2-fallback/</guid>
      <description>To complete this level we need become the owner of the contract and reduce its balance to zero.
// SPDX-License-Identifier: MIT pragma solidity ^0.8.2; import &amp;#34;openzeppelin/utils/math/SafeMath.sol&amp;#34;; contract Fallback { using SafeMath for uint256; mapping(address =&amp;gt; uint256) public contributions; address payable public owner; constructor() { owner = payable(msg.sender); contributions[msg.sender] = 1000 * (1 ether); } modifier onlyOwner() { require(msg.sender == owner, &amp;#34;caller is not the owner&amp;#34;); _; } function contribute() public payable { require(msg.</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Ethernaut, #1 Hello Ethernaut</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-1-hello/</link>
      <pubDate>Thu, 21 Jul 2022 14:48:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-ethernaut-1-hello/</guid>
      <description>Intro The Ethernaut CTF game exists for more than 3 years already and has 26 challenges. The first one is a kind of introductory challenge that gives you steps on what you need to set up. If you have Metamask and open the browser&amp;rsquo;s console, you should see greeting messages:
Set up Originally, this game runs on the Rinkeby test network, but we&amp;rsquo;re going to play it locally. As I mentioned in the first post, we will use Foundry toolchain and here is the initial/empty project layout:</description>
    </item>
    
    <item>
      <title>CTF walkthrough, Intro</title>
      <link>https://vyorkin.org/posts/ctf-walkthrough-intro/</link>
      <pubDate>Tue, 19 Jul 2022 00:40:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/ctf-walkthrough-intro/</guid>
      <description>CTF&amp;rsquo;s / War games CTF&amp;rsquo;s (Capture The Flags) are games/challenges focused on the Ethereum blockchain that help you to learn security techniques and concepts. These are the five popular CTF&amp;rsquo;s worth solving (in this order) to master your Ethereum/Solidity offensive security skills:
The Ethernaut is a wargame by OpenZeppelin. CaptureTheEther Damn Vulnerable DeFi Paradigm CTF 2021 Paradigm CTF 2022 (upcoming) Each level/challenge is a set of vulnerable smart contracts that you need to exploit.</description>
    </item>
    
    <item>
      <title>Simple betting smart contract</title>
      <link>https://vyorkin.org/posts/simple-betting-smart-contract/</link>
      <pubDate>Fri, 20 May 2022 12:20:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/simple-betting-smart-contract/</guid>
      <description>Test</description>
    </item>
    
    <item>
      <title>Making of Tiger #1, Intro</title>
      <link>https://vyorkin.org/posts/making-of-tiger-1-intro/</link>
      <pubDate>Sun, 31 Oct 2021 12:39:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-1-intro/</guid>
      <description>Recently I&amp;rsquo;ve started reading the book by Andrew W. Appel titled Modern compiler implementation in ML. I&amp;rsquo;ve picked it up because I&amp;rsquo;ve heard some really good reviews about the ML version of it. Also there are other editions available that use C and Java. Each chapter covers a single phase of the compilation process and comes with some initial ML code and programming excercies. At the end you will have a working optimizing compiler.</description>
    </item>
    
    <item>
      <title>Making of Tiger #2, Lexical Analysis</title>
      <link>https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/</link>
      <pubDate>Sun, 31 Oct 2021 12:39:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/</guid>
      <description>Intro We need a way to translate a program written in one (human-friendly) language to another (machine-specific) language. Generally, this work is splitted into 2 parts: analysis and synthesis.
The synthesis-part (back end) is responsible for the code generation and optimizations.
Analysis-part (front end) is responsible for breaking the program apart to understand its structure and meaning. There are 3 commonly used analysis phases:
Lexical – breaking a sequence of characters into sequence of individual tokens (words) Syntax – parsing and checking that we have a valid sequence of tokens Semantic – gathering the program’s meaning, making sure that declarations and statements of program are semantically correct, this usually includes type checking In this post we’ll focus on implementing the lexical analysis phase.</description>
    </item>
    
    <item>
      <title>Making of Tiger #3, Parsing</title>
      <link>https://vyorkin.org/posts/making-of-tiger-3-parsing/</link>
      <pubDate>Sun, 31 Oct 2021 12:39:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-3-parsing/</guid>
      <description>Intro In this chapter we’re going to build a parser for our Tiger language. First, let’s do a quick recap of some important concepts of the theory behind programming language parsers:
Parser generator is the most common type of compiler-compiler’s. It takes some formal grammar (typically it is a context-free grammar in BNF or EBNF form), that defines a syntax of a programming language. Tiger grammar with Menhir While reading the current paragraph I highly recommend consulting the Tiger Language Reference Manual that has a precise description (along with a BNF notation) of everything we’re going to define below.</description>
    </item>
    
    <item>
      <title>Making of Tiger #6, Stack frames</title>
      <link>https://vyorkin.org/posts/making-of-tiger-6-stack-frames/</link>
      <pubDate>Sun, 31 Oct 2021 12:39:00 +0300</pubDate>
      
      <guid>https://vyorkin.org/posts/making-of-tiger-6-stack-frames/</guid>
      <description>Intro In this post we&amp;rsquo;re going to add support for stack frames. Here I&amp;rsquo;ve made some notes while reading the chapter 6 to make sure I understand things clearly.
Stack A stack is a region of memory that grows downward and shrinks upward (like icicles). The top of the stack is it&amp;rsquo;s lowest memory address. We treat stack as a big array, with a special register &amp;ndash; the stack pointer (SP).</description>
    </item>
    
  </channel>
</rss>
