<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="en">
    <meta name="color-scheme" content="light dark">

    

    <meta name="author" content="Vasiliy Yorkin">
    <meta name="description" content="Intro    We need a way to translate a program written in one (human-friendly) language to another (machine-specific) language. Generally, this work is splitted into 2 parts: analysis and synthesis.
The synthesis-part (back end) is responsible for the code generation and optimizations.
Analysis-part (front end) is responsible for breaking the program apart to understand its structure and meaning. There are 3 commonly used analysis phases:
 Lexical – breaking a sequence of characters into sequence of individual tokens (words) Syntax – parsing and checking that we have a valid sequnce of tokens Semantic – gathering the program’s meaning, making sure that declarations and statements of program are semantically correct, this usually includes type checking  So, in this blog posts we’ll focus on implementing the lexical analysis phase.">
    <meta name="keywords" content="Vasiliy Yorkin">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Making of Tiger #2, Lexical Analysis"/>
<meta name="twitter:description" content="Intro    We need a way to translate a program written in one (human-friendly) language to another (machine-specific) language. Generally, this work is splitted into 2 parts: analysis and synthesis.
The synthesis-part (back end) is responsible for the code generation and optimizations.
Analysis-part (front end) is responsible for breaking the program apart to understand its structure and meaning. There are 3 commonly used analysis phases:
 Lexical – breaking a sequence of characters into sequence of individual tokens (words) Syntax – parsing and checking that we have a valid sequnce of tokens Semantic – gathering the program’s meaning, making sure that declarations and statements of program are semantically correct, this usually includes type checking  So, in this blog posts we’ll focus on implementing the lexical analysis phase."/>

    <meta property="og:title" content="Making of Tiger #2, Lexical Analysis" />
<meta property="og:description" content="Intro    We need a way to translate a program written in one (human-friendly) language to another (machine-specific) language. Generally, this work is splitted into 2 parts: analysis and synthesis.
The synthesis-part (back end) is responsible for the code generation and optimizations.
Analysis-part (front end) is responsible for breaking the program apart to understand its structure and meaning. There are 3 commonly used analysis phases:
 Lexical – breaking a sequence of characters into sequence of individual tokens (words) Syntax – parsing and checking that we have a valid sequnce of tokens Semantic – gathering the program’s meaning, making sure that declarations and statements of program are semantically correct, this usually includes type checking  So, in this blog posts we’ll focus on implementing the lexical analysis phase." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-26T19:10:00+03:00" />
<meta property="article:modified_time" content="2019-11-26T19:10:00+03:00" />



    <title>
  Making of Tiger #2, Lexical Analysis · vyorkin.org
</title>

    
      <link rel="canonical" href="https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/">
    

    <link rel="preload" href="https://vyorkin.org/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="https://vyorkin.org/css/coder.min.13fa931069bdca9a3b3787050f7afa5f02c8dfd8900275a396590b432311b980.css" integrity="sha256-E/qTEGm9ypo7N4cFD3r6XwLI39iQAnWjllkLQyMRuYA=" crossorigin="anonymous" media="screen" />
    

    

    

    

    

    <link rel="icon" type="image/png" href="https://vyorkin.org/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://vyorkin.org/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="https://vyorkin.org/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://vyorkin.org/images/apple-touch-icon.png">

    

    <meta name="generator" content="Hugo 0.88.1" />
  </head>

  
  
  <body class="preload-transitions colorscheme-light"
        onload=""
  >
    
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://vyorkin.org/">
      vyorkin.org
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://vyorkin.org/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://vyorkin.org/posts/">Blog</a>
            </li>
          
        
        
          
          
          
            
          
            
              
                <li class="navigation-item menu-separator">
                  <span>|</span>
                </li>
                
              
              <li class="navigation-item">
                <a href="https://vyorkin.org/ru-ru/">Russian</a>
              </li>
            
          
            
              
              <li class="navigation-item">
                <a href="https://vyorkin.org/de-de/">German</a>
              </li>
            
          
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/">
              Making of Tiger #2, Lexical Analysis
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime='2019-11-26T19:10:00&#43;03:00'>
                November 26, 2019
              </time>
            </span>
          </div>
          
          <div class="categories">
  <i class="fa fa-folder" aria-hidden="true"></i>
    <a href="https://vyorkin.org/categories/compilers/">compilers</a></div>

          <div class="tags">
  <i class="fa fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="https://vyorkin.org/tags/compilers/">compilers</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="https://vyorkin.org/tags/tiger/">tiger</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="https://vyorkin.org/tags/ocaml/">ocaml</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="https://vyorkin.org/tags/lexing/">lexing</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="https://vyorkin.org/tags/ocamllex/">ocamllex</a>
    </span></div>

        </div>
      </header>

      <div>
        
        <h2 id="intro">
  Intro
  <a class="heading-link" href="#intro">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>We need a way to translate a program written in one
(human-friendly) language to another (machine-specific)
language. Generally, this work is splitted into 2 parts:
<strong>analysis</strong> and <strong>synthesis</strong>.</p>
<p>The <strong>synthesis</strong>-part (back end) is responsible for the code
generation and optimizations.</p>
<p><strong>Analysis</strong>-part (front end) is responsible for breaking the
program apart to understand its structure and meaning. There are
3 commonly used <strong>analysis</strong> phases:</p>
<ol>
<li><strong>Lexical</strong> – breaking a sequence of characters into sequence
of individual <strong>tokens</strong> (words)</li>
<li><strong>Syntax</strong> – parsing and checking that we have a valid sequnce
of tokens</li>
<li><strong>Semantic</strong> – gathering the program’s meaning, making sure
that declarations and statements of program are semantically
correct, this usually includes type checking</li>
</ol>
<p>So, in this blog posts we’ll focus on implementing the <strong>lexical
analysis</strong> phase.</p>
<p>A lexical <strong>token</strong> is a string with an assigned and identified
meaning. This is a <strong>unit</strong> in a grammar of a programming
language.</p>
<ul>
<li>Example <strong>tokens</strong>: identifiers, keywords, separators, operators</li>
<li>Example <strong>non-tokens</strong>: white-spaces, tabs, newlines, comments,
preprocessor directives, macroses</li>
</ul>
<p>Now, I’m going to skip everything related to finite automata and
regular expressions and go straight to the implementation of
<strong>lexer</strong> (lexical analyzer). You can find a good intro to lexing
and parsing using <code>ocamllex</code> and <code>menhir</code> in the <a href="http://dev.realworldocaml.org/parsing-with-ocamllex-and-menhir.html">Read World
OCaml book</a>.</p>
<h2 id="example-lexer--morse-code">
  Example lexer (morse code)
  <a class="heading-link" href="#example-lexer--morse-code">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>We’ll start with the simplest possible example of building a
lexer for <a href="https://en.wikipedia.org/wiki/Morse%5Fcode">morse code</a>, the full source code is <a href="https://github.com/vyorkin/tiger/blob/master/play/menhir/morse-code-simple/lexer.mll">here</a>.</p>
<p>The <code>dune</code> file for our playground project is going to look like
this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">(ocamllex
 (modules lexer))

(executable
 (name driver)
 (libraries core stdio)
 (preprocess (pps ppx_deriving.show)))

(env (dev (flags (<span style="font-style:italic">:standard</span> -warn-error -A))))
</code></pre></div><p>Nothing fancy here. Next one is the <code>driver.ml</code> module, this is
our entry point. It simply reads the given file, runs our lexer
and displays the resulting S-expression.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="font-weight:bold">open</span> <span style="font-weight:bold">Core</span>
<span style="font-weight:bold">open</span> <span style="font-weight:bold">Syntax</span>

<span style="font-weight:bold">let</span> <span style="font-weight:bold">rec</span> tokens buf =
  <span style="font-weight:bold">match</span> <span style="font-weight:bold">Lexer</span>.read buf <span style="font-weight:bold">with</span>
  | <span style="font-weight:bold">EOF</span> -&gt; [<span style="font-weight:bold">EOF</span>]
  | tok -&gt; tok::tokens buf

<span style="font-weight:bold">let</span> lex_print ch =
  ch
  |&gt; <span style="font-weight:bold">Lexing</span>.from_channel
  |&gt; tokens
  |&gt; <span style="font-weight:bold">List</span>.iter ~f:(<span style="font-weight:bold">fun</span> e -&gt; <span style="font-weight:bold">Format</span>.printf <span style="font-style:italic">&#34;%s</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span> (show_exp e))

<span style="font-weight:bold">let</span> run filename () =
  <span style="font-weight:bold">In_channel</span>.with_file filename ~f:lex_print

<span style="font-weight:bold">let</span> () =
  <span style="font-weight:bold">let</span> spec = <span style="font-weight:bold">Command</span>.<span style="font-weight:bold">Spec</span>.(empty +&gt; anon (<span style="font-style:italic">&#34;filename&#34;</span> %: <span style="">string</span>)) <span style="font-weight:bold">in</span>
  run
  |&gt; <span style="font-weight:bold">Command</span>.basic_spec ~summary:<span style="font-style:italic">&#34;Run the lexer and display tokens&#34;</span> spec
  |&gt; <span style="font-weight:bold">Command</span>.run
</code></pre></div><p>We need a module to describe our tokens, lets call it
<code>syntax.ml</code>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="font-weight:bold">type</span> exp =
  | <span style="font-weight:bold">SYM</span> <span style="font-weight:bold">of</span> <span style="">string</span> <span style="font-style:italic">(* symbol *)</span>
  | <span style="font-weight:bold">SEP</span> <span style="font-style:italic">(* separator *)</span>
  | <span style="font-weight:bold">EOF</span> <span style="font-style:italic">(* end of file *)</span>
  [@@deriving show]
</code></pre></div><p>And the lexer generator itself:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">{
  <span style="font-weight:bold">open</span> <span style="font-weight:bold">Lexing</span>
  <span style="font-weight:bold">open</span> <span style="font-weight:bold">Syntax</span>

  <span style="font-style:italic">(* Custom exception type for lexer errors *)</span>
  <span style="font-weight:bold">exception</span> <span style="font-weight:bold">SyntaxError</span> <span style="font-weight:bold">of</span> <span style="">string</span>
}

<span style="font-style:italic">(* Regular expressions: *)</span>

<span style="font-style:italic">(* We use whitespace as a separator, so
</span><span style="font-style:italic">   it is a valid token in our language *)</span>
<span style="font-weight:bold">let</span> white   = [<span style="font-style:italic">&#39; &#39;</span> <span style="font-style:italic">&#39;\t&#39;</span>]+
<span style="font-weight:bold">let</span> newline = <span style="font-style:italic">&#39;\r&#39;</span> | <span style="font-style:italic">&#39;\n&#39;</span> | <span style="font-style:italic">&#34;</span><span style="font-weight:bold;font-style:italic">\r\n</span><span style="font-style:italic">&#34;</span>
<span style="font-weight:bold">let</span> sym     = [<span style="font-style:italic">&#39;.&#39;</span> <span style="font-style:italic">&#39;-&#39;</span>]+

<span style="font-style:italic">(* Lexing rules: *)</span>

rule read = parse
  <span style="font-style:italic">(* New lines are separators too *)</span>
  | newline { new_line lexbuf; <span style="font-weight:bold">SEP</span> }
  | sym     { <span style="font-weight:bold">SYM</span> (lexeme lexbuf) }
  | white   { <span style="font-weight:bold">SEP</span> }
  | _       { <span style="font-weight:bold">raise</span> (<span style="font-weight:bold">SyntaxError</span> (<span style="font-weight:bold">Printf</span>.sprintf <span style="font-style:italic">&#34;At offset %d: unexpected character.</span><span style="font-weight:bold;font-style:italic">\n</span><span style="font-style:italic">&#34;</span> (lexeme_start lexbuf))) }
  | eof     { <span style="font-weight:bold">EOF</span> }
</code></pre></div><p>Now we can parse the “hello world” sequence written in Morse
Code:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">.... . .-.. .-.. ---
.-- --- .-. .-.. -..
</code></pre></div><p>The output will be:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">(SYM <span style="font-style:italic">&#34;....&#34;</span>) SEP (SYM <span style="font-style:italic">&#34;.&#34;</span>) SEP (SYM <span style="font-style:italic">&#34;.-..&#34;</span>) SEP (SYM <span style="font-style:italic">&#34;.-..&#34;</span>) SEP (SYM <span style="font-style:italic">&#34;---&#34;</span>)
SEP
(SYM <span style="font-style:italic">&#34;.--&#34;</span>) SEP (SYM <span style="font-style:italic">&#34;---&#34;</span>) SEP (SYM <span style="font-style:italic">&#34;.-.&#34;</span>) SEP (SYM <span style="font-style:italic">&#34;.-..&#34;</span>) SEP (SYM <span style="font-style:italic">&#34;-..&#34;</span>)
EOF
</code></pre></div><h2 id="tiger-lexer">
  Tiger lexer
  <a class="heading-link" href="#tiger-lexer">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>Having that basic understanding of how to use the <code>ocamllex</code> to
build lexers, we can try to build one for our Tiger language.</p>
<p>The <code>dune</code> file is going to remain the same as in the “morse
code” example above. There is a <strong>Tiger Language Reference Manual
in Appendix A</strong> of the book where you can find the information
about the tokens we need: identifiers, comments, declarations,
data types, etc.</p>
<p>For now, we don’t need to define a real AST data type.</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="font-weight:bold">type</span> exp =
    | <span style="font-weight:bold">TYPE</span>
    | <span style="font-weight:bold">VAR</span>
    | <span style="font-weight:bold">FUNCTION</span>
    | <span style="font-weight:bold">BREAK</span>
    | <span style="font-weight:bold">OF</span>
    | <span style="font-weight:bold">END</span>
    | <span style="font-weight:bold">IN</span>
    | <span style="font-weight:bold">NIL</span>
    | <span style="font-weight:bold">LET</span>
    | <span style="font-weight:bold">DO</span>
    | <span style="font-weight:bold">TO</span>
    | <span style="font-weight:bold">FOR</span>
    | <span style="font-weight:bold">WHILE</span>
    | <span style="font-weight:bold">ELSE</span>
    | <span style="font-weight:bold">THEN</span>
    | <span style="font-weight:bold">IF</span>
    | <span style="font-weight:bold">ARRAY</span>
    | <span style="font-weight:bold">ASSIGN</span>
    | <span style="font-weight:bold">OR</span>
    | <span style="font-weight:bold">AND</span>
    | <span style="font-weight:bold">GE</span>
    | <span style="font-weight:bold">GT</span>
    | <span style="font-weight:bold">LE</span>
    | <span style="font-weight:bold">LT</span>
    | <span style="font-weight:bold">NEQ</span>
    | <span style="font-weight:bold">EQ</span>
    | <span style="font-weight:bold">DIVIDE</span>
    | <span style="font-weight:bold">TIMES</span>
    | <span style="font-weight:bold">MINUS</span>
    | <span style="font-weight:bold">PLUS</span>
    | <span style="font-weight:bold">DOT</span>
    | <span style="font-weight:bold">RBRACE</span>
    | <span style="font-weight:bold">LBRACE</span>
    | <span style="font-weight:bold">RBRACK</span>
    | <span style="font-weight:bold">LBRACK</span>
    | <span style="font-weight:bold">RPAREN</span>
    | <span style="font-weight:bold">LPAREN</span>
    | <span style="font-weight:bold">SEMICOLON</span>
    | <span style="font-weight:bold">COLON</span>
    | <span style="font-weight:bold">COMMA</span>
    | <span style="font-weight:bold">STRING</span> <span style="font-weight:bold">of</span> <span style="">string</span>
    | <span style="font-weight:bold">INT</span> <span style="font-weight:bold">of</span> <span style="">int</span>
    | <span style="font-weight:bold">ID</span> <span style="font-weight:bold">of</span> <span style="">string</span>
    | <span style="font-weight:bold">EOF</span>
    [@@deriving show]
</code></pre></div><!-- raw HTML omitted -->
<p>We want to focus on the lexer part. First, we might want to open
some commonly used modules and define a custom exception type
for lexing errors.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">{
<span style="font-weight:bold">open</span> <span style="font-weight:bold">Lexing</span>
<span style="font-weight:bold">open</span> <span style="font-weight:bold">Syntax</span>
<span style="font-weight:bold">open</span> <span style="font-weight:bold">Base</span>

<span style="font-weight:bold">exception</span> <span style="font-weight:bold">SyntaxError</span> <span style="font-weight:bold">of</span> <span style="">string</span>
}
</code></pre></div><p>Next, we need a few regular expressions:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">
<span style="font-weight:bold">let</span> digit = [<span style="font-style:italic">&#39;0&#39;</span>-<span style="font-style:italic">&#39;9&#39;</span>]
<span style="font-style:italic">(* There are no negative integer literals in Tiger *)</span>
<span style="font-weight:bold">let</span> <span style="">int</span> = digit+
<span style="font-weight:bold">let</span> frac = <span style="font-style:italic">&#39;.&#39;</span> digit*
<span style="font-weight:bold">let</span> exp = [<span style="font-style:italic">&#39;e&#39;</span> <span style="font-style:italic">&#39;E&#39;</span>] [<span style="font-style:italic">&#39;-&#39;</span> <span style="font-style:italic">&#39;+&#39;</span>]? <span style="">int</span>
<span style="font-weight:bold">let</span> <span style="">float</span> = digit* frac? exp?
<span style="font-weight:bold">let</span> white = [<span style="font-style:italic">&#39; &#39;</span> <span style="font-style:italic">&#39;\t&#39;</span>]+
<span style="font-weight:bold">let</span> newline = <span style="font-style:italic">&#39;\r&#39;</span> | <span style="font-style:italic">&#39;\n&#39;</span> | <span style="font-style:italic">&#34;</span><span style="font-weight:bold;font-style:italic">\r\n</span><span style="font-style:italic">&#34;</span>
</code></pre></div><p>According to <strong>Appendix A</strong>:</p>
<blockquote>
<p>An <strong>identifier</strong> is a sequence of letters, digits and
underscores, starting with a letter. Uppercase letters are
distinguished from lowercase.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="font-weight:bold">let</span> alphanum = [<span style="font-style:italic">&#39;a&#39;</span>-<span style="font-style:italic">&#39;z&#39;</span> <span style="font-style:italic">&#39;A&#39;</span>-<span style="font-style:italic">&#39;Z&#39;</span> <span style="font-style:italic">&#39;0&#39;</span>-<span style="font-style:italic">&#39;9&#39;</span> <span style="font-style:italic">&#39;_&#39;</span>]
<span style="font-weight:bold">let</span> id = [<span style="font-style:italic">&#39;a&#39;</span>-<span style="font-style:italic">&#39;z&#39;</span>] alphanum*
</code></pre></div><p>Lexing rules.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">rule read = parse
  <span style="font-style:italic">(* Whitespaces *)</span>
  | white { read lexbuf }
</code></pre></div><p>We want to skip the new lines.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  | newline { new_line lexbuf; read lexbuf }
</code></pre></div><p>We have a separate function to read strings (see the
implementation below).</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  | <span style="font-style:italic">&#39;&#34;&#39;</span> { read_string (<span style="font-weight:bold">Buffer</span>.create 16) lexbuf }
</code></pre></div><p>Again, according the <strong>Appendix A</strong>:</p>
<blockquote>
<p>A comment may appear between any two tokens.
Comments start with <code>/*</code> and end with <code>*/</code> and may be nested.</p>
</blockquote>
<p>We’ll have a separate function for reading comments (scroll down
to see its code).</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  | <span style="font-style:italic">&#34;/*&#34;</span> { read_comment [lexbuf.lex_curr_p] lexbuf }
</code></pre></div><p>Basic keywords:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  | <span style="font-style:italic">&#34;type&#34;</span>     { <span style="font-weight:bold">TYPE</span> }
  | <span style="font-style:italic">&#34;var&#34;</span>      { <span style="font-weight:bold">VAR</span> }
  | <span style="font-style:italic">&#34;function&#34;</span> { <span style="font-weight:bold">FUNCTION</span> }
  | <span style="font-style:italic">&#34;break&#34;</span>    { <span style="font-weight:bold">BREAK</span> }
  | <span style="font-style:italic">&#34;of&#34;</span>       { <span style="font-weight:bold">OF</span> }
  | <span style="font-style:italic">&#34;end&#34;</span>      { <span style="font-weight:bold">END</span> }
  | <span style="font-style:italic">&#34;in&#34;</span>       { <span style="font-weight:bold">IN</span> }
  | <span style="font-style:italic">&#34;nil&#34;</span>      { <span style="font-weight:bold">NIL</span> }
  | <span style="font-style:italic">&#34;let&#34;</span>      { <span style="font-weight:bold">LET</span> }
  | <span style="font-style:italic">&#34;array&#34;</span>    { <span style="font-weight:bold">ARRAY</span> }
</code></pre></div><p>We need 4 tokens for loops:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  | <span style="font-style:italic">&#34;do&#34;</span>    { <span style="font-weight:bold">DO</span> }
  | <span style="font-style:italic">&#34;to&#34;</span>    { <span style="font-weight:bold">TO</span> }
  | <span style="font-style:italic">&#34;for&#34;</span>   { <span style="font-weight:bold">FOR</span> }
  | <span style="font-style:italic">&#34;while&#34;</span> { <span style="font-weight:bold">WHILE</span> }
</code></pre></div><p>Conditionals (<code>if-then-else</code>):</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  | <span style="font-style:italic">&#34;else&#34;</span> { <span style="font-weight:bold">ELSE</span> }
  | <span style="font-style:italic">&#34;then&#34;</span> { <span style="font-weight:bold">THEN</span> }
  | <span style="font-style:italic">&#34;if&#34;</span>   { <span style="font-weight:bold">IF</span> }
</code></pre></div><p>Operators:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  <span style="font-style:italic">(* General *)</span>
  | <span style="font-style:italic">&#34;:=&#34;</span> { <span style="font-weight:bold">ASSIGN</span> }

  <span style="font-style:italic">(* Logical *)</span>
  | <span style="font-style:italic">&#34;|&#34;</span> { <span style="font-weight:bold">OR</span> }
  | <span style="font-style:italic">&#34;&amp;&#34;</span> { <span style="font-weight:bold">AND</span> }

  <span style="font-style:italic">(* Comparison *)</span>
  | <span style="font-style:italic">&#34;&gt;=&#34;</span> { <span style="font-weight:bold">GE</span> }
  | <span style="font-style:italic">&#34;&gt;&#34;</span>  { <span style="font-weight:bold">GT</span> }
  | <span style="font-style:italic">&#34;&lt;=&#34;</span> { <span style="font-weight:bold">LE</span> }
  | <span style="font-style:italic">&#34;&lt;&#34;</span>  { <span style="font-weight:bold">LT</span> }
  | <span style="font-style:italic">&#34;&lt;&gt;&#34;</span> { <span style="font-weight:bold">NEQ</span> }
  | <span style="font-style:italic">&#34;=&#34;</span>  { <span style="font-weight:bold">EQ</span> }

  <span style="font-style:italic">(* Arithmetics *)</span>
  | <span style="font-style:italic">&#34;/&#34;</span> { <span style="font-weight:bold">DIVIDE</span> }
  | <span style="font-style:italic">&#34;*&#34;</span> { <span style="font-weight:bold">TIMES</span> }
  | <span style="font-style:italic">&#34;-&#34;</span> { <span style="font-weight:bold">MINUS</span> }
  | <span style="font-style:italic">&#34;+&#34;</span> { <span style="font-weight:bold">PLUS</span> }
</code></pre></div><p>Separators:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  | <span style="font-style:italic">&#34;.&#34;</span> { <span style="font-weight:bold">DOT</span> }
  | <span style="font-style:italic">&#34;{&#34;</span> { <span style="font-weight:bold">LBRACE</span> }
  | <span style="font-style:italic">&#34;}&#34;</span> { <span style="font-weight:bold">RBRACE</span> }
  | <span style="font-style:italic">&#34;[&#34;</span> { <span style="font-weight:bold">LBRACK</span> }
  | <span style="font-style:italic">&#34;]&#34;</span> { <span style="font-weight:bold">RBRACK</span> }
  | <span style="font-style:italic">&#34;(&#34;</span> { <span style="font-weight:bold">LPAREN</span> }
  | <span style="font-style:italic">&#34;)&#34;</span> { <span style="font-weight:bold">RPAREN</span> }
  | <span style="font-style:italic">&#34;;&#34;</span> { <span style="font-weight:bold">SEMICOLON</span> }
  | <span style="font-style:italic">&#34;:&#34;</span> { <span style="font-weight:bold">COLON</span> }
  | <span style="font-style:italic">&#34;,&#34;</span> { <span style="font-weight:bold">COMMA</span> }
</code></pre></div><p>Numebers, identifiers, error and EOF handling:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  | <span style="">int</span> { <span style="font-weight:bold">INT</span> (<span style="font-weight:bold">Int</span>.of_string (<span style="font-weight:bold">Lexing</span>.lexeme lexbuf)) }
  | id  { <span style="font-weight:bold">ID</span> (<span style="font-weight:bold">Lexing</span>.lexeme lexbuf) }
  | _   { <span style="font-weight:bold">raise</span> (<span style="font-weight:bold">SyntaxError</span> (<span style="font-style:italic">&#34;Unexpected character: &#34;</span> ^ <span style="font-weight:bold">Lexing</span>.lexeme lexbuf)) }
  | eof { <span style="font-weight:bold">EOF</span> }
</code></pre></div><p>The rule to match string literals:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="font-weight:bold">and</span> read_string buf = parse
  <span style="font-style:italic">(* If we reach the terminating double quote, then
</span><span style="font-style:italic">   * we return the contents of the buffer as a STRING. *)</span>
  | <span style="font-style:italic">&#39;&#34;&#39;</span>       { <span style="font-weight:bold">STRING</span> (<span style="font-weight:bold">Buffer</span>.contents buf) }
  <span style="font-style:italic">(* Handling escape sequences *)</span>
  | <span style="font-style:italic">&#39;\\&#39;</span> <span style="font-style:italic">&#39;\\&#39;</span> { <span style="font-weight:bold">Buffer</span>.add_char buf <span style="font-style:italic">&#39;\\&#39;</span>; read_string buf lexbuf }
  | <span style="font-style:italic">&#39;\\&#39;</span> <span style="font-style:italic">&#39;/&#39;</span>  { <span style="font-weight:bold">Buffer</span>.add_char buf <span style="font-style:italic">&#39;/&#39;</span>;  read_string buf lexbuf }
  | <span style="font-style:italic">&#39;\\&#39;</span> <span style="font-style:italic">&#39;b&#39;</span>  { <span style="font-weight:bold">Buffer</span>.add_char buf <span style="font-style:italic">&#39;\b&#39;</span>; read_string buf lexbuf }
  | <span style="font-style:italic">&#39;\\&#39;</span> <span style="font-style:italic">&#39;f&#39;</span>  { <span style="font-weight:bold">Buffer</span>.add_char buf <span style="font-style:italic">&#39;\012&#39;</span>; read_string buf lexbuf }
  | <span style="font-style:italic">&#39;\\&#39;</span> <span style="font-style:italic">&#39;n&#39;</span>  { <span style="font-weight:bold">Buffer</span>.add_char buf <span style="font-style:italic">&#39;\n&#39;</span>; read_string buf lexbuf }
  | <span style="font-style:italic">&#39;\\&#39;</span> <span style="font-style:italic">&#39;r&#39;</span>  { <span style="font-weight:bold">Buffer</span>.add_char buf <span style="font-style:italic">&#39;\r&#39;</span>; read_string buf lexbuf }
  | <span style="font-style:italic">&#39;\\&#39;</span> <span style="font-style:italic">&#39;t&#39;</span>  { <span style="font-weight:bold">Buffer</span>.add_char buf <span style="font-style:italic">&#39;\t&#39;</span>; read_string buf lexbuf }
  | [^ <span style="font-style:italic">&#39;&#34;&#39;</span> <span style="font-style:italic">&#39;\\&#39;</span>]+
    { <span style="font-weight:bold">Buffer</span>.add_string buf (<span style="font-weight:bold">Lexing</span>.lexeme lexbuf);
      read_string buf lexbuf
    }
  | _   { <span style="font-weight:bold">raise</span> (<span style="font-weight:bold">SyntaxError</span> (<span style="font-style:italic">&#34;Illegal string character: &#34;</span> ^ <span style="font-weight:bold">Lexing</span>.lexeme lexbuf)) }
  | eof { <span style="font-weight:bold">raise</span> (<span style="font-weight:bold">SyntaxError</span> <span style="font-style:italic">&#34;String is not terminated&#34;</span>) }
</code></pre></div><p>The rule to match comments (including nested comments), keeping
a list of where comments open:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="font-weight:bold">and</span> read_comment opened = parse
  <span style="font-style:italic">(* Opening comment *)</span>
  | <span style="font-style:italic">&#34;/*&#34;</span> { read_comment (lexbuf.lex_curr_p::opened) lexbuf }
  <span style="font-style:italic">(* Closing comment *)</span>
  | <span style="font-style:italic">&#34;*/&#34;</span>
    { <span style="font-weight:bold">match</span> opened <span style="font-weight:bold">with</span>
      <span style="font-style:italic">(* No nested opened comments left, continue parsing. *)</span>
      | _::[] -&gt; read lexbuf
      <span style="font-style:italic">(* Continue parsing comment. *)</span>
      | _ -&gt; read_comment (<span style="font-weight:bold">List</span>.tl_exn opened) lexbuf
    }
  | newline { new_line lexbuf; read_comment opened lexbuf }
  | _ { read_comment opened lexbuf }
  <span style="font-style:italic">(* Unexpected end-of-file. Update the current location to
</span><span style="font-style:italic">   * point to the opening token that wasn&#39;t closed and raise an error. *)</span>
  | eof
    { lexbuf.lex_curr_p &lt;- <span style="font-weight:bold">List</span>.hd_exn opened;
      <span style="font-weight:bold">raise</span> (<span style="font-weight:bold">SyntaxError</span> <span style="font-style:italic">&#34;Unterminated comment&#34;</span>)
    }
</code></pre></div><h2 id="summary">
  Summary
  <a class="heading-link" href="#summary">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>We’ve learned some new things, like <code>ocamllex</code>, but overall, it
wasn’t too hard to follow the book. The full OCaml source code
for the second chapter can be found <a href="https://github.com/vyorkin/tiger/blob/master/chapter2/lexer.mll">here</a>. In the next part we’re
going to write a parser.</p>

      </div>


      <footer>
        



        
        
        
      </footer>
    </article>

    
  </section>

      </div>

      
  <footer class="footer">
    <section class="container">
      
      
        ©
        
        2021
         Vasiliy Yorkin 
      
      
      
    </section>
  </footer>


    </main>

    
      
      <script src="https://vyorkin.org/js/coder.min.03b17769f4f91ae35667e1f2a1ca8c16f50562576cf90ff32b3179926914daa5.js" integrity="sha256-A7F3afT5GuNWZ&#43;HyocqMFvUFYlds&#43;Q/zKzF5kmkU2qU="></script>
    

    

    

    

    

    

    

    

    
  </body>

</html>
