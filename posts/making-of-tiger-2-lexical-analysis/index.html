<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Vasiliy Yorkin">
<meta name="description" content="Intro We need a way to translate a program written in one (human-friendly) language to another (machine-specific) language. Generally, this work is splitted into 2 parts: analysis and synthesis.
The synthesis-part (back end) is responsible for the code generation and optimizations.
Analysis-part (front end) is responsible for breaking the program apart to understand its structure and meaning. There are 3 commonly used analysis phases:
Lexical – breaking a sequence of characters into sequence of individual tokens (words) Syntax – parsing and checking that we have a valid sequence of tokens Semantic – gathering the program’s meaning, making sure that declarations and statements of program are semantically correct, this usually includes type checking In this post we’ll focus on implementing the lexical analysis phase.">
<meta name="keywords" content="Vasiliy Yorkin">

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Making of Tiger #2, Lexical Analysis"/>
<meta name="twitter:description" content="Intro We need a way to translate a program written in one (human-friendly) language to another (machine-specific) language. Generally, this work is splitted into 2 parts: analysis and synthesis.
The synthesis-part (back end) is responsible for the code generation and optimizations.
Analysis-part (front end) is responsible for breaking the program apart to understand its structure and meaning. There are 3 commonly used analysis phases:
Lexical – breaking a sequence of characters into sequence of individual tokens (words) Syntax – parsing and checking that we have a valid sequence of tokens Semantic – gathering the program’s meaning, making sure that declarations and statements of program are semantically correct, this usually includes type checking In this post we’ll focus on implementing the lexical analysis phase."/>

<meta property="og:title" content="Making of Tiger #2, Lexical Analysis" />
<meta property="og:description" content="Intro We need a way to translate a program written in one (human-friendly) language to another (machine-specific) language. Generally, this work is splitted into 2 parts: analysis and synthesis.
The synthesis-part (back end) is responsible for the code generation and optimizations.
Analysis-part (front end) is responsible for breaking the program apart to understand its structure and meaning. There are 3 commonly used analysis phases:
Lexical – breaking a sequence of characters into sequence of individual tokens (words) Syntax – parsing and checking that we have a valid sequence of tokens Semantic – gathering the program’s meaning, making sure that declarations and statements of program are semantically correct, this usually includes type checking In this post we’ll focus on implementing the lexical analysis phase." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-23T00:01:00+03:00" />
<meta property="article:modified_time" content="2019-08-23T00:01:00+03:00" />



  <title>vyorkin.org</title>

  
  <link rel="canonical" href="https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/">
  

  <link rel="preload" href="https://vyorkin.org/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="https://vyorkin.org/css/coder.min.bce1ad3fd9463aca56f0ae393ff86fb2a0d51b58b56e32625fa4af028409f02d.css" integrity="sha256-vOGtP9lGOspW8K45P/hvsqDVG1i1bjJiX6SvAoQJ8C0=" crossorigin="anonymous" media="screen" />





  
  
    
    
    <link rel="stylesheet" href="https://vyorkin.org/css/coder-dark.min.e2e6584ce20683687b57e321b1116fbb5051e3534cc7846c9baccff833431b67.css" integrity="sha256-4uZYTOIGg2h7V&#43;MhsRFvu1BR41NMx4Rsm6zP&#43;DNDG2c=" crossorigin="anonymous" media="screen" />
  



   




  <link rel="icon" type="image/png" href="https://vyorkin.org/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="https://vyorkin.org/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="https://vyorkin.org/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://vyorkin.org/images/apple-touch-icon.png">

<link rel="manifest" href="https://vyorkin.org/site.webmanifest">
<link rel="mask-icon" href="https://vyorkin.org/images/safari-pinned-tab.svg" color="#5bbad5">


  

  <meta name="generator" content="Hugo 0.124.0">


  

</head>







<body class="preload-transitions colorscheme-dark">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://vyorkin.org/">
      vyorkin.org
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://vyorkin.org/about/">about</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://vyorkin.org/posts/">posts</a>
            </li>
          
        
        
          
          
          
            
          
            
              
                <li class="navigation-item menu-separator">
                  <span>|</span>
                </li>
                
              
              <li class="navigation-item">
                <a href="https://vyorkin.org/ru-ru/">ru</a>
              </li>
            
          
            
              
              <li class="navigation-item">
                <a href="https://vyorkin.org/de-de/">de</a>
              </li>
            
          
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://vyorkin.org/posts/making-of-tiger-2-lexical-analysis/">
              Making of Tiger #2, Lexical Analysis
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="2019-08-23T00:01:00&#43;03:00">
                August 23, 2019
              </time>
            </span>
          </div>
          
          <div class="categories">
  <i class="fa fa-folder" aria-hidden="true"></i>
    <a href="https://vyorkin.org/categories/compilers/">compilers</a></div>

          <div class="tags">
  <i class="fa fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="https://vyorkin.org/tags/compilers/">compilers</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="https://vyorkin.org/tags/tiger/">tiger</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="https://vyorkin.org/tags/ocaml/">ocaml</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="https://vyorkin.org/tags/lexing/">lexing</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="https://vyorkin.org/tags/ocamllex/">ocamllex</a>
    </span></div>

        </div>
      </header>

      <div>
        
        <h2 id="intro">
  Intro
  <a class="heading-link" href="#intro">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>We need a way to translate a program written in one
(human-friendly) language to another (machine-specific)
language. Generally, this work is splitted into 2 parts:
<strong>analysis</strong> and <strong>synthesis</strong>.</p>
<p>The <strong>synthesis</strong>-part (back end) is responsible for the code
generation and optimizations.</p>
<p><strong>Analysis</strong>-part (front end) is responsible for breaking the
program apart to understand its structure and meaning. There are
3 commonly used <strong>analysis</strong> phases:</p>
<ol>
<li><strong>Lexical</strong> – breaking a sequence of characters into sequence
of individual <strong>tokens</strong> (words)</li>
<li><strong>Syntax</strong> – parsing and checking that we have a valid sequence
of tokens</li>
<li><strong>Semantic</strong> – gathering the program’s meaning, making sure
that declarations and statements of program are semantically
correct, this usually includes type checking</li>
</ol>
<p>In this post we’ll focus on implementing the <strong>lexical analysis</strong>
phase.</p>
<p>A lexical <strong>token</strong> is a string with an assigned and identified
meaning. This is a <strong>unit</strong> in a grammar of a programming
language.</p>
<ul>
<li>Example <strong>tokens</strong>: identifiers, keywords, separators, operators</li>
<li>Example <strong>non-tokens</strong>: white-spaces, tabs, newlines, comments,
preprocessor directives, macroses</li>
</ul>
<p>Now, I’m going to skip everything related to finite automata and
regular expressions and go straight to the implementation of
<strong>lexer</strong> (lexical analyzer). You can find a good intro to lexing
and parsing using <code>ocamllex</code> and <code>menhir</code> in the <a href="http://dev.realworldocaml.org/parsing-with-ocamllex-and-menhir.html">Read World
OCaml book</a>.</p>
<h2 id="example-lexer--morse-code">
  Example lexer (morse code)
  <a class="heading-link" href="#example-lexer--morse-code">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>We’ll start with the simplest possible example of building a
lexer for <a href="https://en.wikipedia.org/wiki/Morse_code">morse code</a>, the full source code is <a href="https://github.com/vyorkin/tiger/blob/master/play/menhir/morse-code-simple/lexer.mll">here</a>.</p>
<p>The <code>dune</code> file for our playground project is going to look like
this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(ocamllex
</span></span><span style="display:flex;"><span> (modules lexer))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(executable
</span></span><span style="display:flex;"><span> (name driver)
</span></span><span style="display:flex;"><span> (libraries core stdio)
</span></span><span style="display:flex;"><span> (preprocess (pps ppx_deriving.show)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(env (dev (flags (<span style="color:#0ff;font-weight:bold">:standard</span> -warn-error -A))))
</span></span></code></pre></div><p>Nothing fancy here. Next one is the <code>driver.ml</code> module, this is
our entry point. It simply reads the given file, runs our lexer
and displays the resulting S-expression.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">open</span> Core
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">open</span> Syntax
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">rec</span> tokens buf =
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">match</span> Lexer.read buf <span style="color:#fff;font-weight:bold">with</span>
</span></span><span style="display:flex;"><span>  | EOF -&gt; [EOF]
</span></span><span style="display:flex;"><span>  | tok -&gt; tok::tokens buf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> lex_print ch =
</span></span><span style="display:flex;"><span>  ch
</span></span><span style="display:flex;"><span>  |&gt; Lexing.from_channel
</span></span><span style="display:flex;"><span>  |&gt; tokens
</span></span><span style="display:flex;"><span>  |&gt; List.iter ~f:(<span style="color:#fff;font-weight:bold">fun</span> e -&gt; Format.printf <span style="color:#0ff;font-weight:bold">&#34;%s</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> (show_exp e))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> run filename () =
</span></span><span style="display:flex;"><span>  In_channel.with_file filename ~f:lex_print
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> () =
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">let</span> spec = Command.Spec.(empty +&gt; anon (<span style="color:#0ff;font-weight:bold">&#34;filename&#34;</span> %: <span style="color:#fff;font-weight:bold">string</span>)) <span style="color:#fff;font-weight:bold">in</span>
</span></span><span style="display:flex;"><span>  run
</span></span><span style="display:flex;"><span>  |&gt; Command.basic_spec ~summary:<span style="color:#0ff;font-weight:bold">&#34;Run the lexer and display tokens&#34;</span> spec
</span></span><span style="display:flex;"><span>  |&gt; Command.run
</span></span></code></pre></div><p>We need a module to describe our tokens, lets call it
<code>syntax.ml</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> exp =
</span></span><span style="display:flex;"><span>  | SYM <span style="color:#fff;font-weight:bold">of</span> <span style="color:#fff;font-weight:bold">string</span> <span style="color:#007f7f">(* symbol *)</span>
</span></span><span style="display:flex;"><span>  | SEP <span style="color:#007f7f">(* separator *)</span>
</span></span><span style="display:flex;"><span>  | EOF <span style="color:#007f7f">(* end of file *)</span>
</span></span><span style="display:flex;"><span>  [@@deriving show]
</span></span></code></pre></div><p>And the lexer generator itself:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">open</span> Lexing
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">open</span> Syntax
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* Custom exception type for lexer errors *)</span>
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">exception</span> SyntaxError <span style="color:#fff;font-weight:bold">of</span> <span style="color:#fff;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">(* Regular expressions: *)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">(* We use whitespace as a separator, so
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">   it is a valid token in our language *)</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> white   = [<span style="color:#0ff;font-weight:bold">&#39; &#39;</span> <span style="color:#0ff;font-weight:bold">&#39;\t&#39;</span>]+
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> newline = <span style="color:#0ff;font-weight:bold">&#39;\r&#39;</span> | <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span> | <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">\r\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> sym     = [<span style="color:#0ff;font-weight:bold">&#39;.&#39;</span> <span style="color:#0ff;font-weight:bold">&#39;-&#39;</span>]+
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">(* Lexing rules: *)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rule read = parse
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* New lines are separators too *)</span>
</span></span><span style="display:flex;"><span>  | newline { new_line lexbuf; SEP }
</span></span><span style="display:flex;"><span>  | sym     { SYM (lexeme lexbuf) }
</span></span><span style="display:flex;"><span>  | white   { SEP }
</span></span><span style="display:flex;"><span>  | _       { <span style="color:#fff;font-weight:bold">raise</span> (SyntaxError (Printf.sprintf <span style="color:#0ff;font-weight:bold">&#34;At offset %d: unexpected character.</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span> (lexeme_start lexbuf))) }
</span></span><span style="display:flex;"><span>  | eof     { EOF }
</span></span></code></pre></div><p>Now we can parse the “hello world” sequence written in Morse
Code:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>.... . .-.. .-.. ---
</span></span><span style="display:flex;"><span>.-- --- .-. .-.. -..
</span></span></code></pre></div><p>The output will be:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(SYM <span style="color:#0ff;font-weight:bold">&#34;....&#34;</span>) SEP (SYM <span style="color:#0ff;font-weight:bold">&#34;.&#34;</span>) SEP (SYM <span style="color:#0ff;font-weight:bold">&#34;.-..&#34;</span>) SEP (SYM <span style="color:#0ff;font-weight:bold">&#34;.-..&#34;</span>) SEP (SYM <span style="color:#0ff;font-weight:bold">&#34;---&#34;</span>)
</span></span><span style="display:flex;"><span>SEP
</span></span><span style="display:flex;"><span>(SYM <span style="color:#0ff;font-weight:bold">&#34;.--&#34;</span>) SEP (SYM <span style="color:#0ff;font-weight:bold">&#34;---&#34;</span>) SEP (SYM <span style="color:#0ff;font-weight:bold">&#34;.-.&#34;</span>) SEP (SYM <span style="color:#0ff;font-weight:bold">&#34;.-..&#34;</span>) SEP (SYM <span style="color:#0ff;font-weight:bold">&#34;-..&#34;</span>)
</span></span><span style="display:flex;"><span>EOF
</span></span></code></pre></div><h2 id="tiger-lexer">
  Tiger lexer
  <a class="heading-link" href="#tiger-lexer">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>Having that basic understanding of how to use the <code>ocamllex</code> to
build lexers, we can try to build one for our Tiger language.</p>
<p>The <code>dune</code> file is going to remain the same as in the “morse
code” example above. There is a <strong>Tiger Language Reference Manual
in Appendix A</strong> of the book where you can find the information
about the tokens we need: identifiers, comments, declarations,
data types, etc.</p>
<p>For now, we don’t need to define a real AST data type.</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">type</span> exp =
</span></span><span style="display:flex;"><span>    | TYPE
</span></span><span style="display:flex;"><span>    | VAR
</span></span><span style="display:flex;"><span>    | FUNCTION
</span></span><span style="display:flex;"><span>    | BREAK
</span></span><span style="display:flex;"><span>    | OF
</span></span><span style="display:flex;"><span>    | END
</span></span><span style="display:flex;"><span>    | IN
</span></span><span style="display:flex;"><span>    | NIL
</span></span><span style="display:flex;"><span>    | LET
</span></span><span style="display:flex;"><span>    | DO
</span></span><span style="display:flex;"><span>    | TO
</span></span><span style="display:flex;"><span>    | FOR
</span></span><span style="display:flex;"><span>    | WHILE
</span></span><span style="display:flex;"><span>    | ELSE
</span></span><span style="display:flex;"><span>    | THEN
</span></span><span style="display:flex;"><span>    | IF
</span></span><span style="display:flex;"><span>    | ARRAY
</span></span><span style="display:flex;"><span>    | ASSIGN
</span></span><span style="display:flex;"><span>    | OR
</span></span><span style="display:flex;"><span>    | AND
</span></span><span style="display:flex;"><span>    | GE
</span></span><span style="display:flex;"><span>    | GT
</span></span><span style="display:flex;"><span>    | LE
</span></span><span style="display:flex;"><span>    | LT
</span></span><span style="display:flex;"><span>    | NEQ
</span></span><span style="display:flex;"><span>    | EQ
</span></span><span style="display:flex;"><span>    | DIVIDE
</span></span><span style="display:flex;"><span>    | TIMES
</span></span><span style="display:flex;"><span>    | MINUS
</span></span><span style="display:flex;"><span>    | PLUS
</span></span><span style="display:flex;"><span>    | DOT
</span></span><span style="display:flex;"><span>    | RBRACE
</span></span><span style="display:flex;"><span>    | LBRACE
</span></span><span style="display:flex;"><span>    | RBRACK
</span></span><span style="display:flex;"><span>    | LBRACK
</span></span><span style="display:flex;"><span>    | RPAREN
</span></span><span style="display:flex;"><span>    | LPAREN
</span></span><span style="display:flex;"><span>    | SEMICOLON
</span></span><span style="display:flex;"><span>    | COLON
</span></span><span style="display:flex;"><span>    | COMMA
</span></span><span style="display:flex;"><span>    | STRING <span style="color:#fff;font-weight:bold">of</span> <span style="color:#fff;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>    | INT <span style="color:#fff;font-weight:bold">of</span> <span style="color:#fff;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span>    | ID <span style="color:#fff;font-weight:bold">of</span> <span style="color:#fff;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>    | EOF
</span></span><span style="display:flex;"><span>    [@@deriving show]
</span></span></code></pre></div><!-- raw HTML omitted -->
<p>We want to focus on the lexer part. First, we might want to open
some commonly used modules and define a custom exception type
for lexing errors.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">open</span> Lexing
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">open</span> Syntax
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">open</span> Base
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">exception</span> SyntaxError <span style="color:#fff;font-weight:bold">of</span> <span style="color:#fff;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Next, we need a few regular expressions:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> digit = [<span style="color:#0ff;font-weight:bold">&#39;0&#39;</span>-<span style="color:#0ff;font-weight:bold">&#39;9&#39;</span>]
</span></span><span style="display:flex;"><span><span style="color:#007f7f">(* There are no negative integer literals in Tiger *)</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">int</span> = digit+
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> frac = <span style="color:#0ff;font-weight:bold">&#39;.&#39;</span> digit*
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> exp = [<span style="color:#0ff;font-weight:bold">&#39;e&#39;</span> <span style="color:#0ff;font-weight:bold">&#39;E&#39;</span>] [<span style="color:#0ff;font-weight:bold">&#39;-&#39;</span> <span style="color:#0ff;font-weight:bold">&#39;+&#39;</span>]? <span style="color:#fff;font-weight:bold">int</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">float</span> = digit* frac? exp?
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> white = [<span style="color:#0ff;font-weight:bold">&#39; &#39;</span> <span style="color:#0ff;font-weight:bold">&#39;\t&#39;</span>]+
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> newline = <span style="color:#0ff;font-weight:bold">&#39;\r&#39;</span> | <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span> | <span style="color:#0ff;font-weight:bold">&#34;</span><span style="color:#0ff;font-weight:bold">\r\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>
</span></span></code></pre></div><p>According to <strong>Appendix A</strong>:</p>
<p><em>An <strong>identifier</strong> is a sequence of letters, digits and underscores, starting with a letter. Uppercase letters are distinguished from lowercase</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> alphanum = [<span style="color:#0ff;font-weight:bold">&#39;a&#39;</span>-<span style="color:#0ff;font-weight:bold">&#39;z&#39;</span> <span style="color:#0ff;font-weight:bold">&#39;A&#39;</span>-<span style="color:#0ff;font-weight:bold">&#39;Z&#39;</span> <span style="color:#0ff;font-weight:bold">&#39;0&#39;</span>-<span style="color:#0ff;font-weight:bold">&#39;9&#39;</span> <span style="color:#0ff;font-weight:bold">&#39;_&#39;</span>]
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> id = [<span style="color:#0ff;font-weight:bold">&#39;a&#39;</span>-<span style="color:#0ff;font-weight:bold">&#39;z&#39;</span>] alphanum*
</span></span></code></pre></div><p>Lexing rules.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>rule read = parse
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* Whitespaces *)</span>
</span></span><span style="display:flex;"><span>  | white { read lexbuf }
</span></span></code></pre></div><p>We want to skip the new lines.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>  | newline { new_line lexbuf; read lexbuf }
</span></span></code></pre></div><p>We have a separate function to read strings (see the
implementation below).</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#39;&#34;&#39;</span> { read_string (Buffer.create 16) lexbuf }
</span></span></code></pre></div><p>Again, according the <strong>Appendix A</strong>:</p>
<p><em>A comment may appear between any two tokens. Comments start with <code>/*</code> and end with <code>*/</code> and may be nested.</em></p>
<p>We’ll have a separate function for reading comments (scroll down
to see its code).</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;/*&#34;</span> { read_comment [lexbuf.lex_curr_p] lexbuf }
</span></span></code></pre></div><p>Basic keywords:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;type&#34;</span>     { TYPE }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;var&#34;</span>      { VAR }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;function&#34;</span> { FUNCTION }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;break&#34;</span>    { BREAK }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;of&#34;</span>       { OF }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;end&#34;</span>      { END }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;in&#34;</span>       { IN }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;nil&#34;</span>      { NIL }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;let&#34;</span>      { LET }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;array&#34;</span>    { ARRAY }
</span></span></code></pre></div><p>We need 4 tokens for loops:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;do&#34;</span>    { DO }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;to&#34;</span>    { TO }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;for&#34;</span>   { FOR }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;while&#34;</span> { WHILE }
</span></span></code></pre></div><p>Conditionals (<code>if-then-else</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;else&#34;</span> { ELSE }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;then&#34;</span> { THEN }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;if&#34;</span>   { IF }
</span></span></code></pre></div><p>Operators:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>  <span style="color:#007f7f">(* General *)</span>
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;:=&#34;</span> { ASSIGN }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* Logical *)</span>
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;|&#34;</span> { OR }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;&amp;&#34;</span> { AND }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* Comparison *)</span>
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;&gt;=&#34;</span> { GE }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;&gt;&#34;</span>  { GT }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;&lt;=&#34;</span> { LE }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;&lt;&#34;</span>  { LT }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;&lt;&gt;&#34;</span> { NEQ }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;=&#34;</span>  { EQ }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* Arithmetics *)</span>
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;/&#34;</span> { DIVIDE }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;*&#34;</span> { TIMES }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;-&#34;</span> { MINUS }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;+&#34;</span> { PLUS }
</span></span></code></pre></div><p>Separators:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;.&#34;</span> { DOT }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;{&#34;</span> { LBRACE }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;}&#34;</span> { RBRACE }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;[&#34;</span> { LBRACK }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;]&#34;</span> { RBRACK }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;(&#34;</span> { LPAREN }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;)&#34;</span> { RPAREN }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;;&#34;</span> { SEMICOLON }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;:&#34;</span> { COLON }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;,&#34;</span> { COMMA }
</span></span></code></pre></div><p>Numbers, identifiers, error and EOF handling:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>  | <span style="color:#fff;font-weight:bold">int</span> { INT (Int.of_string (Lexing.lexeme lexbuf)) }
</span></span><span style="display:flex;"><span>  | id  { ID (Lexing.lexeme lexbuf) }
</span></span><span style="display:flex;"><span>  | _   { <span style="color:#fff;font-weight:bold">raise</span> (SyntaxError (<span style="color:#0ff;font-weight:bold">&#34;Unexpected character: &#34;</span> ^ Lexing.lexeme lexbuf)) }
</span></span><span style="display:flex;"><span>  | eof { EOF }
</span></span></code></pre></div><p>The rule to match string literals:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>and read_string buf = parse
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* If we reach the terminating double quote, then
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">   * we return the contents of the buffer as a STRING. *)</span>
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#39;&#34;&#39;</span>       { STRING (Buffer.contents buf) }
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* Handling escape sequences *)</span>
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#39;\\&#39;</span> <span style="color:#0ff;font-weight:bold">&#39;\\&#39;</span> { Buffer.add_char buf <span style="color:#0ff;font-weight:bold">&#39;\\&#39;</span>; read_string buf lexbuf }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#39;\\&#39;</span> <span style="color:#0ff;font-weight:bold">&#39;/&#39;</span>  { Buffer.add_char buf <span style="color:#0ff;font-weight:bold">&#39;/&#39;</span>;  read_string buf lexbuf }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#39;\\&#39;</span> <span style="color:#0ff;font-weight:bold">&#39;b&#39;</span>  { Buffer.add_char buf <span style="color:#0ff;font-weight:bold">&#39;\b&#39;</span>; read_string buf lexbuf }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#39;\\&#39;</span> <span style="color:#0ff;font-weight:bold">&#39;f&#39;</span>  { Buffer.add_char buf <span style="color:#0ff;font-weight:bold">&#39;\012&#39;</span>; read_string buf lexbuf }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#39;\\&#39;</span> <span style="color:#0ff;font-weight:bold">&#39;n&#39;</span>  { Buffer.add_char buf <span style="color:#0ff;font-weight:bold">&#39;\n&#39;</span>; read_string buf lexbuf }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#39;\\&#39;</span> <span style="color:#0ff;font-weight:bold">&#39;r&#39;</span>  { Buffer.add_char buf <span style="color:#0ff;font-weight:bold">&#39;\r&#39;</span>; read_string buf lexbuf }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#39;\\&#39;</span> <span style="color:#0ff;font-weight:bold">&#39;t&#39;</span>  { Buffer.add_char buf <span style="color:#0ff;font-weight:bold">&#39;\t&#39;</span>; read_string buf lexbuf }
</span></span><span style="display:flex;"><span>  | [^ <span style="color:#0ff;font-weight:bold">&#39;&#34;&#39;</span> <span style="color:#0ff;font-weight:bold">&#39;\\&#39;</span>]+
</span></span><span style="display:flex;"><span>    { Buffer.add_string buf (Lexing.lexeme lexbuf);
</span></span><span style="display:flex;"><span>      read_string buf lexbuf
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  | _   { <span style="color:#fff;font-weight:bold">raise</span> (SyntaxError (<span style="color:#0ff;font-weight:bold">&#34;Illegal string character: &#34;</span> ^ Lexing.lexeme lexbuf)) }
</span></span><span style="display:flex;"><span>  | eof { <span style="color:#fff;font-weight:bold">raise</span> (SyntaxError <span style="color:#0ff;font-weight:bold">&#34;String is not terminated&#34;</span>) }
</span></span></code></pre></div><p>The rule to match comments (including nested comments), keeping
a list of where comments open:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>and read_comment opened = parse
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* Opening comment *)</span>
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;/*&#34;</span> { read_comment (lexbuf.lex_curr_p::opened) lexbuf }
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* Closing comment *)</span>
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;*/&#34;</span>
</span></span><span style="display:flex;"><span>    { <span style="color:#fff;font-weight:bold">match</span> opened <span style="color:#fff;font-weight:bold">with</span>
</span></span><span style="display:flex;"><span>      <span style="color:#007f7f">(* No nested opened comments left, continue parsing. *)</span>
</span></span><span style="display:flex;"><span>      | _::[] -&gt; read lexbuf
</span></span><span style="display:flex;"><span>      <span style="color:#007f7f">(* Continue parsing comment. *)</span>
</span></span><span style="display:flex;"><span>      | _ -&gt; read_comment (List.tl_exn opened) lexbuf
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  | newline { new_line lexbuf; read_comment opened lexbuf }
</span></span><span style="display:flex;"><span>  | _ { read_comment opened lexbuf }
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* Unexpected end-of-file. Update the current location to
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">   * point to the opening token that wasn&#39;t closed and raise an error. *)</span>
</span></span><span style="display:flex;"><span>  | eof
</span></span><span style="display:flex;"><span>    { lexbuf.lex_curr_p &lt;- List.hd_exn opened;
</span></span><span style="display:flex;"><span>      <span style="color:#fff;font-weight:bold">raise</span> (SyntaxError <span style="color:#0ff;font-weight:bold">&#34;Unterminated comment&#34;</span>)
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><h2 id="summary">
  Summary
  <a class="heading-link" href="#summary">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<p>We’ve learned some new things, like <code>ocamllex</code>, but overall, it
wasn’t too hard to follow the book. The full OCaml source code
for the second chapter can be found <a href="https://github.com/vyorkin/tiger/blob/master/chapter2/lexer.mll">here</a>. In the next part we’re
going to write a parser.</p>

        
      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"
    integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"
    integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js"
    integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script>
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      1985 -
    
    2024
     Vasiliy Yorkin 
    
  </section>
</footer>

  </main>

  
  
  <script src="https://vyorkin.org/js/coder.min.b9a9a8f029e2fd416957bf8489db1b684799393553df358655a1b614ec7c5ef9.js" integrity="sha256-uamo8Cni/UFpV7&#43;EidsbaEeZOTVT3zWGVaG2FOx8Xvk="></script>
  

  

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-F8R77TYF8B"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-F8R77TYF8B', { 'anonymize_ip': false });
}
</script>


  

  

  

  

  

  

  
</body>

</html>
