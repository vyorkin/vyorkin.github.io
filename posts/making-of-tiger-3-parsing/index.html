<!DOCTYPE html>
<html lang="en">

<head>
  <title>
  Making of Tiger #3, Parsing · transcendental kyberautism
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Vasiliy Yorkin">
<meta name="description" content="
  Intro
  
    
    Link to heading
  

In this chapter we’re going to build a parser for our Tiger
language. First, let’s do a quick recap of some important
concepts of the theory behind programming language parsers:

Parser generator is the most common type of
compiler-compiler’s. It takes some formal grammar (typically
it is a context-free grammar in BNF or EBNF form), that
defines a syntax of a programming language.


  Tiger grammar with Menhir
  
    
    Link to heading
  

While reading the current paragraph I highly recommend
consulting the Tiger Language Reference Manual that has a
precise description (along with a BNF notation) of everything
we’re going to define below.">
<meta name="keywords" content="Vasiliy Yorkin">
<meta name="fediverse:creator" content="" />


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Making of Tiger #3, Parsing">
  <meta name="twitter:description" content="Intro Link to heading In this chapter we’re going to build a parser for our Tiger language. First, let’s do a quick recap of some important concepts of the theory behind programming language parsers:
Parser generator is the most common type of compiler-compiler’s. It takes some formal grammar (typically it is a context-free grammar in BNF or EBNF form), that defines a syntax of a programming language. Tiger grammar with Menhir Link to heading While reading the current paragraph I highly recommend consulting the Tiger Language Reference Manual that has a precise description (along with a BNF notation) of everything we’re going to define below.">

<meta property="og:url" content="https://vyorkin.org/posts/making-of-tiger-3-parsing/">
  <meta property="og:site_name" content="transcendental kyberautism">
  <meta property="og:title" content="Making of Tiger #3, Parsing">
  <meta property="og:description" content="Intro Link to heading In this chapter we’re going to build a parser for our Tiger language. First, let’s do a quick recap of some important concepts of the theory behind programming language parsers:
Parser generator is the most common type of compiler-compiler’s. It takes some formal grammar (typically it is a context-free grammar in BNF or EBNF form), that defines a syntax of a programming language. Tiger grammar with Menhir Link to heading While reading the current paragraph I highly recommend consulting the Tiger Language Reference Manual that has a precise description (along with a BNF notation) of everything we’re going to define below.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-09-08T15:58:00+03:00">
    <meta property="article:modified_time" content="2019-09-08T15:58:00+03:00">
    <meta property="article:tag" content="Compilers">
    <meta property="article:tag" content="Tiger">
    <meta property="article:tag" content="Ocaml">
    <meta property="article:tag" content="Parsing">
    <meta property="article:tag" content="Menhir">




<link rel="canonical" href="https://vyorkin.org/posts/making-of-tiger-3-parsing/">


<link rel="preload" href="https://vyorkin.org/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://vyorkin.org/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="https://vyorkin.org/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="https://vyorkin.org/css/coder.min.07092c1350ffd254998dc43a44ae96e617d14af4df4602626878df89189c5e1a.css" integrity="sha256-BwksE1D/0lSZjcQ6RK6W5hfRSvTfRgJiaHjfiRicXho=" crossorigin="anonymous" media="screen" />





  
    
    
    <link rel="stylesheet" href="https://vyorkin.org/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css" integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin="anonymous" media="screen" />
  




  
  <link rel="stylesheet" href="https://vyorkin.org/custom.min.cf4424ca575c8638b55547ace7bc3ab68c44ff1c808b1f1bb2358cdbcdbd8c41.css" integrity="sha256-z0Qkyldchji1VUes57w6toxE/xyAix8bsjWM2829jEE=" crossorigin="anonymous" media="screen" />


<link rel="icon" type="image/svg+xml" href="https://vyorkin.org/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="https://vyorkin.org/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="https://vyorkin.org/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="https://vyorkin.org/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://vyorkin.org/images/apple-touch-icon.png">

<link rel="manifest" href="https://vyorkin.org/site.webmanifest">
<link rel="mask-icon" href="https://vyorkin.org/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="https://vyorkin.org/">
      transcendental kyberautism
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://vyorkin.org/about/">about</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="https://vyorkin.org/posts/">posts</a>
            </li>
          
        
        
          
          
          
            
          
            
              
                <li class="navigation-item menu-separator">
                  <span>|</span>
                </li>
                
              
              <li class="navigation-item">
                <a href="https://vyorkin.org/ru-ru/">ru</a>
              </li>
            
          
            
              
              <li class="navigation-item">
                <a href="https://vyorkin.org/de-de/">de</a>
              </li>
            
          
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://vyorkin.org/posts/making-of-tiger-3-parsing/">
              Making of Tiger #3, Parsing
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="September 8, 2019">
                September 8, 2019
              </time>
            </span>
          </div>
          
          
          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="https://vyorkin.org/tags/compilers/">Compilers</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="https://vyorkin.org/tags/tiger/">Tiger</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="https://vyorkin.org/tags/ocaml/">Ocaml</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="https://vyorkin.org/tags/parsing/">Parsing</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="https://vyorkin.org/tags/menhir/">Menhir</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <h2 id="intro">
  Intro
  <a class="heading-link" href="#intro">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>In this chapter we’re going to build a parser for our Tiger
language. First, let’s do a quick recap of some important
concepts of the theory behind programming language parsers:</p>
<ul>
<li><strong>Parser generator</strong> is the most common type of
<a href="https://en.wikipedia.org/wiki/Compiler-compiler"  class="external-link" target="_blank" rel="noopener">compiler-compiler’s</a>. It takes some formal grammar (typically
it is a <a href="https://en.wikipedia.org/wiki/Context-free_grammar"  class="external-link" target="_blank" rel="noopener">context-free grammar</a> in <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form"  class="external-link" target="_blank" rel="noopener">BNF</a> or <a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form"  class="external-link" target="_blank" rel="noopener">EBNF </a>form), that
defines a syntax of a programming language.</li>
</ul>
<h2 id="tiger-grammar-with-menhir">
  Tiger grammar with Menhir
  <a class="heading-link" href="#tiger-grammar-with-menhir">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>While reading the current paragraph I highly recommend
consulting the <strong>Tiger Language Reference Manual</strong> that has a
precise description (along with a BNF notation) of everything
we’re going to define below.</p>
<p><a href="http://gallium.inria.fr/~fpottier/menhir/"  class="external-link" target="_blank" rel="noopener">Menhir</a> is an LR(1) parser generator library for OCaml. It
<a href="https://dune.readthedocs.io/en/stable/dune-files.html#menhir"  class="external-link" target="_blank" rel="noopener">integrates with Dune</a> quiet nicely. All we need to do is to add
the <code>menhir</code> stanza to our <code>dune</code> file (the one from the
previous chapter). So the whole file will look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(menhir
</span></span><span style="display:flex;"><span> (modules parser)
</span></span><span style="display:flex;"><span> (flags (<span style="color:#0ff;font-weight:bold">&#34;--dump&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;--explain&#34;</span>)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(ocamllex
</span></span><span style="display:flex;"><span> (modules lexer))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(library
</span></span><span style="display:flex;"><span> (name ch3)
</span></span><span style="display:flex;"><span> (inline_tests)
</span></span><span style="display:flex;"><span> (libraries core stdio)
</span></span><span style="display:flex;"><span> (preprocess (pps ppx_inline_test ppx_expect)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(env (dev (flags (<span style="color:#0ff;font-weight:bold">:standard</span> -warn-error -A))))
</span></span></code></pre></div><p>Notice the <code>--dump</code> and <code>--explain</code> switches:</p>
<ul>
<li>The <code>--dump</code> switch means to write a description of the
automaton to the <code>.automaton</code> file.</li>
<li>The <code>--explain</code> switch helps us to understand severe conflicts in
terms of a grammar (rather than in terms of automaton),
enabling it means to write a textual explanation of detected
shift-reduce conflicts to the <code>.conflicts</code> file. <a href="http://ix.io/1SAS"  class="external-link" target="_blank" rel="noopener">Here is
the example</a> of how it looks.</li>
</ul>
<p>See the <a href="http://gallium.inria.fr/~fpottier/menhir/manual.html#sec37"  class="external-link" target="_blank" rel="noopener">conflicts</a> part of the Menhir manual for details.</p>
<p>We’ll use the
<a href="http://gallium.inria.fr/~fpottier/menhir/manual.html#sec23"  class="external-link" target="_blank" rel="noopener">new
syntax</a> for rules (despite the fact that it is considered
experimental). First, let’s define some
<a href="http://gallium.inria.fr/~fpottier/menhir/manual.html#sec9"  class="external-link" target="_blank" rel="noopener">token
aliases</a>, priorities and associativity levels. Basically these
are the same tokens we used in our lexer.</p>
<p>Base keywords:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>%token TYPE     <span style="color:#0ff;font-weight:bold">&#34;type&#34;</span>
</span></span><span style="display:flex;"><span>%token VAR      <span style="color:#0ff;font-weight:bold">&#34;var&#34;</span>
</span></span><span style="display:flex;"><span>%token FUNCTION <span style="color:#0ff;font-weight:bold">&#34;function&#34;</span>
</span></span><span style="display:flex;"><span>%token BREAK    <span style="color:#0ff;font-weight:bold">&#34;break&#34;</span>
</span></span><span style="display:flex;"><span>%token OF       <span style="color:#0ff;font-weight:bold">&#34;of&#34;</span>
</span></span><span style="display:flex;"><span>%token END      <span style="color:#0ff;font-weight:bold">&#34;end&#34;</span>
</span></span><span style="display:flex;"><span>%token IN       <span style="color:#0ff;font-weight:bold">&#34;in&#34;</span>
</span></span><span style="display:flex;"><span>%token NIL      <span style="color:#0ff;font-weight:bold">&#34;nil&#34;</span> <span style="color:#007f7f">(* nil denotes a value belonging to every record type *)</span>
</span></span><span style="display:flex;"><span>%token LET      <span style="color:#0ff;font-weight:bold">&#34;let&#34;</span>
</span></span><span style="display:flex;"><span>%token ARRAY    <span style="color:#0ff;font-weight:bold">&#34;array&#34;</span>
</span></span></code></pre></div><p>Loop-related keywords:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>%token DO    <span style="color:#0ff;font-weight:bold">&#34;do&#34;</span>
</span></span><span style="display:flex;"><span>%token TO    <span style="color:#0ff;font-weight:bold">&#34;to&#34;</span>
</span></span><span style="display:flex;"><span>%token FOR   <span style="color:#0ff;font-weight:bold">&#34;for&#34;</span>
</span></span><span style="display:flex;"><span>%token WHILE <span style="color:#0ff;font-weight:bold">&#34;while&#34;</span>
</span></span></code></pre></div><p>Keywords for conditional expression:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>%token IF   <span style="color:#0ff;font-weight:bold">&#34;if&#34;</span>
</span></span><span style="display:flex;"><span>%token THEN <span style="color:#0ff;font-weight:bold">&#34;then&#34;</span>
</span></span><span style="display:flex;"><span>%token ELSE <span style="color:#0ff;font-weight:bold">&#34;else&#34;</span>
</span></span></code></pre></div><p>Operator tokens:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#007f7f">(* General *)</span>
</span></span><span style="display:flex;"><span>%token ASSIGN <span style="color:#0ff;font-weight:bold">&#34;:=&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">(* Logical *)</span>
</span></span><span style="display:flex;"><span>%token OR  <span style="color:#0ff;font-weight:bold">&#34;|&#34;</span>
</span></span><span style="display:flex;"><span>%token AND <span style="color:#0ff;font-weight:bold">&#34;&amp;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">(* Comparison *)</span>
</span></span><span style="display:flex;"><span>%token GE  <span style="color:#0ff;font-weight:bold">&#34;&gt;=&#34;</span>
</span></span><span style="display:flex;"><span>%token GT  <span style="color:#0ff;font-weight:bold">&#34;&gt;&#34;</span>
</span></span><span style="display:flex;"><span>%token LE  <span style="color:#0ff;font-weight:bold">&#34;&lt;=&#34;</span>
</span></span><span style="display:flex;"><span>%token LT  <span style="color:#0ff;font-weight:bold">&#34;&lt;&#34;</span>
</span></span><span style="display:flex;"><span>%token NEQ <span style="color:#0ff;font-weight:bold">&#34;&lt;&gt;&#34;</span>
</span></span><span style="display:flex;"><span>%token EQ  <span style="color:#0ff;font-weight:bold">&#34;=&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">(* Arithmetics *)</span>
</span></span><span style="display:flex;"><span>%token DIVIDE <span style="color:#0ff;font-weight:bold">&#34;/&#34;</span>
</span></span><span style="display:flex;"><span>%token TIMES  <span style="color:#0ff;font-weight:bold">&#34;*&#34;</span>
</span></span><span style="display:flex;"><span>%token PLUS   <span style="color:#0ff;font-weight:bold">&#34;+&#34;</span>
</span></span><span style="display:flex;"><span>%token MINUS  <span style="color:#0ff;font-weight:bold">&#34;-&#34;</span>
</span></span></code></pre></div><p>Tokens for separators:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>%token DOT       <span style="color:#0ff;font-weight:bold">&#34;.&#34;</span>
</span></span><span style="display:flex;"><span>%token LBRACE    <span style="color:#0ff;font-weight:bold">&#34;{&#34;</span>
</span></span><span style="display:flex;"><span>%token RBRACE    <span style="color:#0ff;font-weight:bold">&#34;}&#34;</span>
</span></span><span style="display:flex;"><span>%token LBRACK    <span style="color:#0ff;font-weight:bold">&#34;[&#34;</span>
</span></span><span style="display:flex;"><span>%token RBRACK    <span style="color:#0ff;font-weight:bold">&#34;]&#34;</span>
</span></span><span style="display:flex;"><span>%token LPAREN    <span style="color:#0ff;font-weight:bold">&#34;(&#34;</span>
</span></span><span style="display:flex;"><span>%token RPAREN    <span style="color:#0ff;font-weight:bold">&#34;)&#34;</span>
</span></span><span style="display:flex;"><span>%token SEMICOLON <span style="color:#0ff;font-weight:bold">&#34;;&#34;</span>
</span></span><span style="display:flex;"><span>%token COLON     <span style="color:#0ff;font-weight:bold">&#34;:&#34;</span>
</span></span><span style="display:flex;"><span>%token COMMA     <span style="color:#0ff;font-weight:bold">&#34;,&#34;</span>
</span></span></code></pre></div><p>Strings, numbers, identifiers and the <code>EOF</code> token:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>%token &lt;<span style="color:#fff;font-weight:bold">string</span>&gt; STRING <span style="color:#0ff;font-weight:bold">&#34;string&#34;</span>
</span></span><span style="display:flex;"><span>%token &lt;<span style="color:#fff;font-weight:bold">int</span>&gt;    INT    <span style="color:#0ff;font-weight:bold">&#34;int&#34;</span>
</span></span><span style="display:flex;"><span>%token &lt;<span style="color:#fff;font-weight:bold">string</span>&gt; ID     <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>%token EOF
</span></span></code></pre></div><p>Associativity of operators:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>%nonassoc <span style="color:#0ff;font-weight:bold">&#34;of&#34;</span>
</span></span><span style="display:flex;"><span>%nonassoc <span style="color:#0ff;font-weight:bold">&#34;then&#34;</span>
</span></span><span style="display:flex;"><span>%nonassoc <span style="color:#0ff;font-weight:bold">&#34;else&#34;</span>
</span></span><span style="display:flex;"><span>%nonassoc <span style="color:#0ff;font-weight:bold">&#34;do&#34;</span>
</span></span><span style="display:flex;"><span>%nonassoc <span style="color:#0ff;font-weight:bold">&#34;:=&#34;</span>
</span></span><span style="display:flex;"><span>%left     <span style="color:#0ff;font-weight:bold">&#34;|&#34;</span>
</span></span><span style="display:flex;"><span>%left     <span style="color:#0ff;font-weight:bold">&#34;&amp;&#34;</span>
</span></span><span style="display:flex;"><span>%nonassoc <span style="color:#0ff;font-weight:bold">&#34;&gt;=&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;&gt;&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;&lt;=&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;&lt;&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;&lt;&gt;&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;=&#34;</span>
</span></span><span style="display:flex;"><span>%left     <span style="color:#0ff;font-weight:bold">&#34;+&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;-&#34;</span>
</span></span><span style="display:flex;"><span>%left     <span style="color:#0ff;font-weight:bold">&#34;*&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;/&#34;</span>
</span></span></code></pre></div><p>The grammar rules:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>%start &lt;<span style="color:#fff;font-weight:bold">unit</span>&gt; main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>%%
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> main :=
</span></span><span style="display:flex;"><span>  ~ = expr; EOF; &lt;&gt;
</span></span></code></pre></div><p>Top-level expression:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> expr :=
</span></span><span style="display:flex;"><span>  | primitive
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;nil&#34;</span>
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;break&#34;</span>
</span></span><span style="display:flex;"><span>  | create_rec
</span></span><span style="display:flex;"><span>  | create_arr
</span></span><span style="display:flex;"><span>  | lvalue
</span></span><span style="display:flex;"><span>  | assignment
</span></span><span style="display:flex;"><span>  | local
</span></span><span style="display:flex;"><span>  | conditional
</span></span><span style="display:flex;"><span>  | loop
</span></span><span style="display:flex;"><span>  | fun_call
</span></span><span style="display:flex;"><span>  | unary
</span></span><span style="display:flex;"><span>  | binary
</span></span><span style="display:flex;"><span>  | seq
</span></span></code></pre></div><p>It might not be obvious from the <code>expr</code> definition, but it also
includes a thing called <code>no value</code> (an expression that yields no
value). So when looking at the top-level expression and
comparing it to the language reference manual, please note that
in our grammar <code>no_val := &quot;(&quot; &quot;)&quot;</code> (empty <code>seq</code>).</p>
<p>There are two built-in (predefined) primitive types: <code>int</code> and
<code>string</code>. The grammar rule for those is pretty straightforward:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> primitive :=
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;string&#34;</span>; { () }
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;int&#34;</span>; { () }
</span></span></code></pre></div><p>In our language we have only one unary operator – minus:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> unary := <span style="color:#0ff;font-weight:bold">&#34;-&#34;</span>; expr
</span></span></code></pre></div><p>But we have two kinds of binary operators: <code>boolean</code> and
“logical + arithmetic”, which we’ll simply call <code>bin</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> binary :=
</span></span><span style="display:flex;"><span>  | bin
</span></span><span style="display:flex;"><span>  | boolean
</span></span></code></pre></div><p>Scroll down to see the definitions of <code>bin</code> and <code>boolean</code>.</p>
<p>We have 2 kinds of loops: the <code>while</code> loop and the <code>for</code> loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> loop :=
</span></span><span style="display:flex;"><span>  | while_loop
</span></span><span style="display:flex;"><span>  | for_loop
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> while_loop := <span style="color:#0ff;font-weight:bold">&#34;while&#34;</span>; expr; <span style="color:#0ff;font-weight:bold">&#34;do&#34;</span>; expr
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> for_loop   := <span style="color:#0ff;font-weight:bold">&#34;for&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;:=&#34;</span>; expr; <span style="color:#0ff;font-weight:bold">&#34;to&#34;</span>; expr; <span style="color:#0ff;font-weight:bold">&#34;do&#34;</span>; expr
</span></span></code></pre></div><p>Nothing new or unusual. And the conditional expression rule is
also quite trivial:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> conditional :=
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;if&#34;</span>; expr; <span style="color:#0ff;font-weight:bold">&#34;then&#34;</span>; expr; <span style="color:#0ff;font-weight:bold">&#34;else&#34;</span>; expr
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;if&#34;</span>; expr; <span style="color:#0ff;font-weight:bold">&#34;then&#34;</span>; expr
</span></span></code></pre></div><p>Syntax for local bindings is going to be exactly like in OCaml
or SML:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> local := <span style="color:#0ff;font-weight:bold">&#34;let&#34;</span>; decs; <span style="color:#0ff;font-weight:bold">&#34;in&#34;</span>; expr_seq; <span style="color:#0ff;font-weight:bold">&#34;end&#34;</span>
</span></span></code></pre></div><p>Now, a slightly more complex part – declarations.</p>
<p>As stated in the Tiger language reference manual, a
declaration-sequence is a sequence of <strong>type</strong>, <strong>value</strong>, and
<strong>function declarations</strong>. No punctuation separates or terminates
individual declarations.</p>
<p>In terms of Menhir we can express it like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> decs := <span style="color:#fff;font-weight:bold">list</span>(dec); { () }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> dec :=
</span></span><span style="display:flex;"><span>  | ty_dec  <span style="color:#007f7f">(* type *)</span>
</span></span><span style="display:flex;"><span>  | var_dec <span style="color:#007f7f">(* value *)</span>
</span></span><span style="display:flex;"><span>  | fun_dec <span style="color:#007f7f">(* function declaration *)</span>
</span></span></code></pre></div><p>Ok, we need to define a separate rule for each declaration
mentioned above.</p>
<p>To declare a data type in the Tiger language we start with the
keyword <code>type</code>, after which comes the identifier, the equality
token and the type declaration body:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> ty_dec := <span style="color:#0ff;font-weight:bold">&#34;type&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;=&#34;</span>; ty
</span></span></code></pre></div><p>The type declaration could be a <strong>record</strong>, an <strong>array</strong> or a <strong>type
alias</strong> (any identifier):</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> ty :=
</span></span><span style="display:flex;"><span>  | braced(ty_fields) <span style="color:#007f7f">(* records *)</span>
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;array&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;of&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; { () } <span style="color:#007f7f">(* arrays *)</span>
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; { () }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> ty_fields := separated_list(<span style="color:#0ff;font-weight:bold">&#34;,&#34;</span>, ty_field); { () }
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> ty_field  := <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; ty_ann
</span></span></code></pre></div><p>As per language reference manual, there are two possible ways to
declare a variable: with or without type annotation. The
following rule reflects this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> var_dec :=
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;var&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>;         <span style="color:#0ff;font-weight:bold">&#34;:=&#34;</span>; expr
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;var&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; ty_ann; <span style="color:#0ff;font-weight:bold">&#34;:=&#34;</span>; expr
</span></span></code></pre></div><p>The record and array creation rules below are also considered
top-level expressions:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> create_rec := <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; braced(init_rec_fields)
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> create_arr := <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; bracketed(expr); <span style="color:#0ff;font-weight:bold">&#34;of&#34;</span>; expr
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> init_rec_fields := separated_list(<span style="color:#0ff;font-weight:bold">&#34;,&#34;</span>, init_rec_field); { () }
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> init_rec_field  := <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;=&#34;</span>; expr
</span></span></code></pre></div><p>Next, we need a function declaration rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> fun_dec :=
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* procedures doesn&#39;t return values *)</span>
</span></span><span style="display:flex;"><span>  | fun_head; <span style="color:#0ff;font-weight:bold">&#34;=&#34;</span>; fun_body
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* functions return values and the type is specified after the colon *)</span>
</span></span><span style="display:flex;"><span>  | fun_head; <span style="color:#0ff;font-weight:bold">&#34;:&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;=&#34;</span>; fun_body
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> fun_head   := <span style="color:#0ff;font-weight:bold">&#34;function&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; fun_params
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> fun_body   := expr
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> fun_params := parenthesized(ty_fields)
</span></span></code></pre></div><p>According to our language spec:</p>
<p>&gt; An <code>l-value</code> is a location, whose value may be read or assigned.
&gt; Variables, procedure parameters, fields or records, and
elements are all <code>l-values</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> lvalue :=
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* variable *)</span>
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; { () }
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* everything else *)</span>
</span></span><span style="display:flex;"><span>  | lvalue_t
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> lvalue_t :=
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* simple record field *)</span>
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;.&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; { () }
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* compound record field *)</span>
</span></span><span style="display:flex;"><span>  | lvalue_t; <span style="color:#0ff;font-weight:bold">&#34;.&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; { () }
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* simple array subscript *)</span>
</span></span><span style="display:flex;"><span>  | <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; bracketed(expr)
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">(* compund array subscript *)</span>
</span></span><span style="display:flex;"><span>  | lvalue_t; bracketed(expr)
</span></span></code></pre></div><p>Assignment of an expression to <code>lvalue</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> assignment := lvalue; <span style="color:#0ff;font-weight:bold">&#34;:=&#34;</span>; expr
</span></span></code></pre></div><p>Sequence of expressions delimited by semicolon:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> expr_seq := separated_list(<span style="color:#0ff;font-weight:bold">&#34;;&#34;</span>, expr); { () }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> seq := parenthesized(expr_seq)
</span></span></code></pre></div><p>Function call rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> fun_call := <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>; parenthesized(fun_args)
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> fun_args := separated_list(<span style="color:#0ff;font-weight:bold">&#34;,&#34;</span>, expr); { () }
</span></span></code></pre></div><p>Arithmetic, comparison and equality expressions:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> bin := expr; bin_op; expr
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> bin_op == <span style="color:#0ff;font-weight:bold">&#34;+&#34;</span> | <span style="color:#0ff;font-weight:bold">&#34;-&#34;</span> | <span style="color:#0ff;font-weight:bold">&#34;*&#34;</span> | <span style="color:#0ff;font-weight:bold">&#34;/&#34;</span> | <span style="color:#0ff;font-weight:bold">&#34;&gt;=&#34;</span> | <span style="color:#0ff;font-weight:bold">&#34;&gt;&#34;</span> | <span style="color:#0ff;font-weight:bold">&#34;&lt;=&#34;</span> | <span style="color:#0ff;font-weight:bold">&#34;&lt;&#34;</span> | <span style="color:#0ff;font-weight:bold">&#34;&lt;&gt;&#34;</span> | <span style="color:#0ff;font-weight:bold">&#34;=&#34;</span>
</span></span></code></pre></div><p>Boolean expressions:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> boolean := expr; boolean_op; expr
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> boolean_op == <span style="color:#0ff;font-weight:bold">&#34;&amp;&#34;</span> | <span style="color:#0ff;font-weight:bold">&#34;|&#34;</span>
</span></span></code></pre></div><p>Helper rule for a type annotation which we used in the <code>var_dec</code>
and <code>ty_field</code> above:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> ty_ann := <span style="color:#0ff;font-weight:bold">&#34;:&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;id&#34;</span>
</span></span></code></pre></div><p>Menhir allows us to declare functions, so these are three helper
functions that we used everywhere else for delimited
expressions:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> parenthesized(x) == delimited(<span style="color:#0ff;font-weight:bold">&#34;(&#34;</span>, x, <span style="color:#0ff;font-weight:bold">&#34;)&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> bracketed(x)     == delimited(<span style="color:#0ff;font-weight:bold">&#34;[&#34;</span>, x, <span style="color:#0ff;font-weight:bold">&#34;]&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> braced(x)        == delimited(<span style="color:#0ff;font-weight:bold">&#34;{&#34;</span>, x, <span style="color:#0ff;font-weight:bold">&#34;}&#34;</span>)
</span></span></code></pre></div><h2 id="test-suite">
  Test suite
  <a class="heading-link" href="#test-suite">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>In order to iterate on our parser quickly we want to automate
the process of testing it against the <a href="https://github.com/vyorkin/tiger/blob/master/book/testcases/test1.tig"  class="external-link" target="_blank" rel="noopener">provided example programs</a>.
The most convenient way to do that would be to create a test
suite that we could run after every change we make.</p>
<p>Some of the provided example Tiger programs are intentionally
broken, so we want to skip those:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> skipped =
</span></span><span style="display:flex;"><span>  [<span style="color:#0ff;font-weight:bold">&#34;test16.tig&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;test17.tig&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;test19.tig&#34;</span>;
</span></span><span style="display:flex;"><span>   <span style="color:#0ff;font-weight:bold">&#34;test20.tig&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;test25.tig&#34;</span>;
</span></span><span style="display:flex;"><span>   <span style="color:#0ff;font-weight:bold">&#34;test45.tig&#34;</span>; <span style="color:#0ff;font-weight:bold">&#34;test49.tig&#34;</span>]
</span></span></code></pre></div><p>A couple of helper functions to list the example programs
(recursively):</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> is_tig_ext filename =
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">let</span> (_, ext) = Filename.split_extension filename <span style="color:#fff;font-weight:bold">in</span>
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">match</span> ext <span style="color:#fff;font-weight:bold">with</span>
</span></span><span style="display:flex;"><span>  | Some <span style="color:#0ff;font-weight:bold">&#34;tig&#34;</span> -&gt; true
</span></span><span style="display:flex;"><span>  | _ -&gt; false
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> is_tig_file f =
</span></span><span style="display:flex;"><span>  Sys.is_file_exn ~follow_symlinks:true f &amp;&amp;
</span></span><span style="display:flex;"><span>  is_tig_ext f
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> <span style="color:#fff;font-weight:bold">rec</span> ls_rec dir =
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">if</span> is_tig_file dir
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">then</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> not(List.mem skipped (Filename.basename dir) ~equal:(=)) <span style="color:#fff;font-weight:bold">then</span>
</span></span><span style="display:flex;"><span>      [dir]
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>      []
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>    dir
</span></span><span style="display:flex;"><span>    |&gt; Sys.ls_dir
</span></span><span style="display:flex;"><span>    |&gt; List.concat_map
</span></span><span style="display:flex;"><span>      ~f:(<span style="color:#fff;font-weight:bold">fun</span> sub -&gt; ls_rec (Filename.concat dir sub))
</span></span></code></pre></div><p>Let’s add another helper function to get current position along
with a filename as a string. We’ll need it later to output an
error location:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> position lexbuf =
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">let</span> pos = lexbuf.lex_curr_p <span style="color:#fff;font-weight:bold">in</span>
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">let</span> col = pos.pos_cnum - pos.pos_bol + 1 <span style="color:#fff;font-weight:bold">in</span>
</span></span><span style="display:flex;"><span>  Printf.sprintf <span style="color:#0ff;font-weight:bold">&#34;%s:%d:%d&#34;</span> pos.pos_fname pos.pos_lnum col
</span></span></code></pre></div><p>And another two functions to run the parser and print the error
details in case of failure:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> parse_with_error lexbuf =
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">try</span>
</span></span><span style="display:flex;"><span>    Parser.main Lexer.read lexbuf;
</span></span><span style="display:flex;"><span>    assert_bool <span style="color:#0ff;font-weight:bold">&#34;Ok&#34;</span> true
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">with</span>
</span></span><span style="display:flex;"><span>  | SyntaxError msg -&gt;
</span></span><span style="display:flex;"><span>    assert_failure (position lexbuf ^ <span style="color:#0ff;font-weight:bold">&#34; : &#34;</span> ^ msg)
</span></span><span style="display:flex;"><span>  | Parser.Error -&gt;
</span></span><span style="display:flex;"><span>    assert_failure (<span style="color:#0ff;font-weight:bold">&#34;Syntax error: &#34;</span> ^ position lexbuf)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> parse filename ch =
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">let</span> lexbuf = Lexing.from_channel ch <span style="color:#fff;font-weight:bold">in</span>
</span></span><span style="display:flex;"><span>  lexbuf.lex_curr_p &lt;- {
</span></span><span style="display:flex;"><span>    lexbuf.lex_curr_p <span style="color:#fff;font-weight:bold">with</span> pos_fname = Filename.basename filename
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  parse_with_error lexbuf
</span></span></code></pre></div><p>Here is the function that we’re going to call for each <code>.tig</code>
file:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> run_parser filename _ =
</span></span><span style="display:flex;"><span>  In_channel.with_file filename ~f:(parse filename)
</span></span></code></pre></div><p>Finally, the test suite is going to look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> suite =
</span></span><span style="display:flex;"><span>  <span style="color:#0ff;font-weight:bold">&#34;tiger programs&#34;</span> &gt;:::
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">let</span> tests_dir = <span style="color:#0ff;font-weight:bold">&#34;../../../book&#34;</span> ^ Filename.dir_sep ^ <span style="color:#0ff;font-weight:bold">&#34;testcases&#34;</span> <span style="color:#fff;font-weight:bold">in</span>
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">let</span> tests_path = Filename.(concat parent_dir_name tests_dir) <span style="color:#fff;font-weight:bold">in</span>
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">let</span> tig_files = ls_rec tests_path <span style="color:#fff;font-weight:bold">in</span>
</span></span><span style="display:flex;"><span>  (List.map ~f:
</span></span><span style="display:flex;"><span>     (<span style="color:#fff;font-weight:bold">fun</span> filename -&gt;
</span></span><span style="display:flex;"><span>        Filename.basename filename &gt;:: run_parser filename)
</span></span><span style="display:flex;"><span>     tig_files)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">let</span> () =
</span></span><span style="display:flex;"><span>  run_test_tt_main suite
</span></span></code></pre></div><p>The dune file for our test suite project will simply run the
<code>testsuite.exe</code> executable:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lisp" data-lang="lisp"><span style="display:flex;"><span>(executable
</span></span><span style="display:flex;"><span> (name testsuite)
</span></span><span style="display:flex;"><span> (libraries base core ch3 oUnit))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(alias
</span></span><span style="display:flex;"><span> (name runtest)
</span></span><span style="display:flex;"><span> (action (run ./testsuite.exe)))
</span></span></code></pre></div><p>Now it’ll be much easier to work on the parser implementation.
Also this test suite might be useful to detect possible
regressions if we want to change the parser in the future.</p>
<h2 id="conclusion">
  Conclusion
  <a class="heading-link" href="#conclusion">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Of course, I didn’t come up with this grammar right away. I
spent almost a week implementing this parser. I started with a
simple parser for “straightline programs” and iterated on it
until it evolved to the fully functional Tiger-language grammar.
And it took some time for me to figure out how to resolve all
the shift-reduce conflicts.</p>
<p>Another cool feature of Menhir is its REPL, which might be
helpful for debugging. This is especially useful when you
already caught a parser error by running the test suite and now
you want to try constructing an invalid expression to check your
hypothesis. I used this kind of workflow a lot while working on
this grammar.</p>
<p>You can run the interpreter like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>menhir --interpret --interpret-show-cst parser.mly
</span></span></code></pre></div><p>Now you can start typing expressions until you find something
that breaks your parser. Note that you can’t use token aliases
inside this REPL.</p>
<p>For example, here is how you can test a function declaration:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ocaml" data-lang="ocaml"><span style="display:flex;"><span>LET FUNCTION ID LPAREN ID COLON ID RPAREN COLON ID EQ IF ID EQ INT THEN INT ELSE INT TIMES ID LPAREN ID MINUS INT RPAREN IN ID LPAREN INT RPAREN END
</span></span></code></pre></div><p>That’s it for now. The full source code for this chapter
<a href="https://github.com/vyorkin/tiger/blob/master/chapter3/lib/parser.mly"  class="external-link" target="_blank" rel="noopener">is
here</a>. Next time we’re going to work on the AST for our Tiger
language.</p>

        
      </div>


      <footer>
        


        
        
        
        
        

        
        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
    integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"
    integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script>
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      1985 -
    
    2024
     Vasiliy Yorkin 
    
  </section>
</footer>

  </main>

  

  
  
  <script src="https://vyorkin.org/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-F8R77TYF8B"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-F8R77TYF8B');
        }
      </script>

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
