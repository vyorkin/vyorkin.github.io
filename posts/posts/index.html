<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Language" content="en">
    <meta name="color-scheme" content="light dark">

    

    <meta name="author" content="Vasiliy Yorkin">
    <meta name="description" content="Making of Tiger    DONEMaking of Tiger #1, Intro    Recently I&rsquo;ve started reading the book by Andrew W. Appel titled Modern compiler implementation in ML. I&rsquo;ve picked it up because I&rsquo;ve heard some really good reviews about the ML version of it. Also there are other editions available that use C and Java. Each chapter covers a single phase of the compilation process and comes with some initial ML code and programming excercies.">
    <meta name="keywords" content="Vasiliy Yorkin">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="Making of Tiger    DONEMaking of Tiger #1, Intro    Recently I&rsquo;ve started reading the book by Andrew W. Appel titled Modern compiler implementation in ML. I&rsquo;ve picked it up because I&rsquo;ve heard some really good reviews about the ML version of it. Also there are other editions available that use C and Java. Each chapter covers a single phase of the compilation process and comes with some initial ML code and programming excercies."/>

    <meta property="og:title" content="" />
<meta property="og:description" content="Making of Tiger    DONEMaking of Tiger #1, Intro    Recently I&rsquo;ve started reading the book by Andrew W. Appel titled Modern compiler implementation in ML. I&rsquo;ve picked it up because I&rsquo;ve heard some really good reviews about the ML version of it. Also there are other editions available that use C and Java. Each chapter covers a single phase of the compilation process and comes with some initial ML code and programming excercies." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://vyorkin.org/posts/posts/" /><meta property="article:section" content="posts" />





    <title>
   Â· vyorkin.org
</title>

    
      <link rel="canonical" href="https://vyorkin.org/posts/posts/">
    

    <link rel="preload" href="https://vyorkin.org/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>

    
      
      
      <link rel="stylesheet" href="https://vyorkin.org/css/coder.min.708686f8ab8176e91d44fcbe488a0fe0333b94f405cf18a52383d67ba22f0ccb.css" integrity="sha256-cIaG&#43;KuBdukdRPy&#43;SIoP4DM7lPQFzxilI4PWe6IvDMs=" crossorigin="anonymous" media="screen" />
    

    

    

    

    

    <link rel="icon" type="image/png" href="https://vyorkin.org/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://vyorkin.org/images/favicon-16x16.png" sizes="16x16">

    <link rel="apple-touch-icon" href="https://vyorkin.org/images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://vyorkin.org/images/apple-touch-icon.png">

    

    <meta name="generator" content="Hugo 0.88.1" />
  </head>

  
  
  <body class="preload-transitions colorscheme-light"
        onload=""
  >
    
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://vyorkin.org/">
      vyorkin.org
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://vyorkin.org/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://vyorkin.org/posts/">Blog</a>
            </li>
          
        
        
          
          
          
            
          
            
              
                <li class="navigation-item menu-separator">
                  <span>|</span>
                </li>
                
              
              <li class="navigation-item">
                <a href="https://vyorkin.org/ru-ru/">Russian</a>
              </li>
            
          
            
              
              <li class="navigation-item">
                <a href="https://vyorkin.org/de-de/">German</a>
              </li>
            
          
        
      </ul>
    
  </section>
</nav>


      <div class="content">
        
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://vyorkin.org/posts/posts/">
              
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime='0001-01-01T00:00:00Z'>
                January 1, 0001
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              55-minute read
            </span>
          </div>
          
          
          
        </div>
      </header>

      <div>
        
        <h2 id="making-of-tiger">
  Making of Tiger
  <a class="heading-link" href="#making-of-tiger">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<h3 id="making-of-tiger-1-intro">
  <!-- raw HTML omitted -->DONE<!-- raw HTML omitted --> Making of Tiger #1, Intro
  <a class="heading-link" href="#making-of-tiger-1-intro">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Recently I&rsquo;ve started reading the book by <a href="https://en.wikipedia.org/wiki/Andrew%5FAppel">Andrew W. Appel</a> titled
<a href="https://www.amazon.com/Modern-Compiler-Implement-Andrew-Appel/dp/0521607647">Modern compiler implementation in ML</a>. I&rsquo;ve picked it up because
I&rsquo;ve heard some really good reviews about the ML version of it.
Also there are other editions available that use C and Java.
Each chapter covers a single phase of the compilation process
and comes with some initial ML code and programming excercies.
At the end you will have a working optimizing compiler.</p>
<p>I&rsquo;m building a compiler for the first time and it is a
lot of fun. In these blog post series, I&rsquo;ll be working through
the book and explaining my solutions to each chapter.</p>
<h4 id="getting-started">
  Getting started
  <a class="heading-link" href="#getting-started">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>The author describes Tiger as a simple (but nontrivial) language
of the <a href="https://en.wikipedia.org/wiki/ALGOL">Algol family</a>, which could be easily modified to be
functional or object-oriented (maybe I&rsquo;ll skip the OO-part of
the book).</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-F90" data-lang="F90"><span style="color:#66d9ef">type </span>tree <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">{</span>
  key: string,
  left: tree,
  right: tree
<span style="color:#960050;background-color:#1e0010">}</span>

<span style="color:#66d9ef">function </span>prettyprint(tree: tree) : string <span style="color:#f92672">=</span>
  let
    var output :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>

    <span style="color:#66d9ef">function write</span>(s: string) <span style="color:#f92672">=</span>
      output :<span style="color:#f92672">=</span> concat(output, s)

    <span style="color:#66d9ef">function </span>show(n: int, t: tree) <span style="color:#f92672">=</span>
      let
        <span style="color:#66d9ef">function </span>indent(s: string) <span style="color:#f92672">=</span> (
          for i :<span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> to n <span style="color:#66d9ef">do
</span><span style="color:#66d9ef">             write</span>(<span style="color:#e6db74">&#34; &#34;</span>);
             output :<span style="color:#f92672">=</span> concat(output, s);
             <span style="color:#66d9ef">write</span>(<span style="color:#e6db74">&#34;\n&#34;</span>)
        )
      in
        <span style="color:#66d9ef">if </span>t <span style="color:#f92672">=</span> nil
        <span style="color:#66d9ef">then </span>ident(<span style="color:#e6db74">&#34;.&#34;</span>)
        <span style="color:#66d9ef">else</span> (
          indent(t.key);
          show(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, t.left);
          show(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, t.right)
        )
      <span style="color:#66d9ef">end
</span><span style="color:#66d9ef">  </span>in
    show(<span style="color:#ae81ff">0</span>, tree);
    output
  <span style="color:#66d9ef">end</span>
</code></pre></div><!-- raw HTML omitted -->
<p>For my implementation I&rsquo;ve decided to use OCaml. It is <a href="http://adam.chlipala.net/mlcomp/">close</a>
<a href="https://stackoverflow.com/questions/699689/what-are-the-differences-between-sml-and-ocaml/699755#699755">enough</a> to SML so with even basic ML experience it should be
fairly straightworward to port the code examples.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Straight-line programs</p>
<p>The first &ldquo;warm-up&rdquo; assignment is to implement a program
analyzer and interpreter for the <strong>straight-line</strong> programming
language. We have the following types:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">type</span> id <span style="color:#f92672">=</span> <span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">type</span> binop <span style="color:#f92672">=</span> <span style="color:#a6e22e">Plus</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Minus</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Times</span> <span style="color:#f92672">|</span> <span style="color:#a6e22e">Div</span>

<span style="color:#66d9ef">type</span> stm <span style="color:#f92672">=</span> <span style="color:#a6e22e">Compound</span> <span style="color:#66d9ef">of</span> stm <span style="color:#f92672">*</span> stm
         <span style="color:#f92672">|</span> <span style="color:#a6e22e">Assign</span> <span style="color:#66d9ef">of</span> id <span style="color:#f92672">*</span> exp
         <span style="color:#f92672">|</span> <span style="color:#a6e22e">Print</span> <span style="color:#66d9ef">of</span> exp <span style="color:#66d9ef">list</span>

 <span style="color:#f92672">and</span> exp <span style="color:#f92672">=</span> <span style="color:#a6e22e">Id</span> <span style="color:#66d9ef">of</span> id
         <span style="color:#f92672">|</span> <span style="color:#a6e22e">Num</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">int</span>
         <span style="color:#f92672">|</span> <span style="color:#a6e22e">Op</span> <span style="color:#66d9ef">of</span> exp <span style="color:#f92672">*</span> binop <span style="color:#f92672">*</span> exp
         <span style="color:#f92672">|</span> <span style="color:#a6e22e">Eseq</span> <span style="color:#66d9ef">of</span> stm <span style="color:#f92672">*</span> exp
</code></pre></div><p>So for the following sample straight-line program</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-F90" data-lang="F90">a :<span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>;
b :<span style="color:#f92672">=</span> (<span style="color:#66d9ef">print</span>(a, a <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>), a <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>);
<span style="color:#66d9ef">print</span>(b)
</code></pre></div><p>The corresponding AST would be</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#a6e22e">Compound</span><span style="color:#f92672">(</span>
  <span style="color:#a6e22e">Assign</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">,</span> <span style="color:#a6e22e">Op</span><span style="color:#f92672">(</span><span style="color:#a6e22e">Num</span> 5<span style="color:#f92672">,</span> <span style="color:#a6e22e">Plus</span><span style="color:#f92672">,</span> <span style="color:#a6e22e">Num</span> 3<span style="color:#f92672">)),</span>
  <span style="color:#a6e22e">Compound</span><span style="color:#f92672">(</span>
    <span style="color:#a6e22e">Assign</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">,</span>
      <span style="color:#a6e22e">Eseq</span><span style="color:#f92672">(</span>
        <span style="color:#a6e22e">Print</span> <span style="color:#f92672">[</span><span style="color:#a6e22e">Id</span> <span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">;</span> <span style="color:#a6e22e">Op</span><span style="color:#f92672">(</span><span style="color:#a6e22e">Id</span> <span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">,</span> <span style="color:#a6e22e">Minus</span><span style="color:#f92672">,</span> <span style="color:#a6e22e">Num</span> 1<span style="color:#f92672">)],</span>
        <span style="color:#a6e22e">Op</span><span style="color:#f92672">(</span><span style="color:#a6e22e">Num</span> 10<span style="color:#f92672">,</span> <span style="color:#a6e22e">Times</span><span style="color:#f92672">,</span> <span style="color:#a6e22e">Id</span> <span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">))),</span>
    <span style="color:#a6e22e">Print</span> <span style="color:#f92672">[</span><span style="color:#a6e22e">Id</span> <span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">]))</span>
</code></pre></div><p>The first task is to write a function</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">val</span> maxargs <span style="color:#f92672">:</span> stm <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">int</span>
</code></pre></div><p>This function tells the maximum number of args of any <code>print</code>
statement within any subexpression of a given statement.</p>
<p>Sounds easy, right? The implementation is pretty straightforward
too:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Base</span>
<span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Straightline</span>

<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> maxargs stm <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> maxargs_exp <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">Eseq</span> <span style="color:#f92672">(</span>stm<span style="color:#f92672">,</span> <span style="color:#f92672">_)</span> <span style="color:#f92672">-&gt;</span> maxargs stm
    <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> 0
  <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">match</span> stm <span style="color:#66d9ef">with</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Print</span> exps <span style="color:#f92672">-&gt;</span>
    <span style="color:#66d9ef">let</span> len <span style="color:#f92672">=</span> List.length exps <span style="color:#66d9ef">in</span>
    <span style="color:#66d9ef">let</span> exp_lens <span style="color:#f92672">=</span> List.map <span style="color:#f92672">~</span>f<span style="color:#f92672">:</span>maxargs_exp exps <span style="color:#66d9ef">in</span>
    <span style="color:#66d9ef">let</span> max_exp_len <span style="color:#f92672">=</span> List.max_elt <span style="color:#f92672">~</span>compare<span style="color:#f92672">:</span>Int.compare exp_lens <span style="color:#66d9ef">in</span>
    Int.max len <span style="color:#f92672">(</span>Option.value <span style="color:#f92672">~</span>default<span style="color:#f92672">:</span>0 max_exp_len<span style="color:#f92672">)</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Compound</span> <span style="color:#f92672">(</span>exp1<span style="color:#f92672">,</span> exp2<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span>
    <span style="color:#66d9ef">let</span> l1 <span style="color:#f92672">=</span> maxargs exp1 <span style="color:#66d9ef">in</span>
    <span style="color:#66d9ef">let</span> l2 <span style="color:#f92672">=</span> maxargs exp2 <span style="color:#66d9ef">in</span>
    Int.max l1 l2
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Assign</span> <span style="color:#f92672">(_,</span> exp<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span>
    maxargs_exp exp
</code></pre></div><p>Next, we need to write another function that &ldquo;interprets&rdquo;
program in this language.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">val</span> eval <span style="color:#f92672">:</span> stm <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">unit</span>
</code></pre></div><p>The code</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Base</span>
<span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Stdio</span>
<span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Straightline</span>

<span style="color:#66d9ef">let</span> eval x op y <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">match</span> op <span style="color:#66d9ef">with</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Plus</span>  <span style="color:#f92672">-&gt;</span> x <span style="color:#f92672">+</span> y
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Minus</span> <span style="color:#f92672">-&gt;</span> x <span style="color:#f92672">-</span> y
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Times</span> <span style="color:#f92672">-&gt;</span> x <span style="color:#f92672">*</span> y
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Div</span>   <span style="color:#f92672">-&gt;</span> x <span style="color:#f92672">/</span> y

<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> interp_stm stm env <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> print env0 exp <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> <span style="color:#f92672">(</span>v<span style="color:#f92672">,</span> env1<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> interp_exp exp env0 <span style="color:#66d9ef">in</span>
    print_endline <span style="color:#f92672">(</span>Int.to_string v<span style="color:#f92672">);</span>
    env1
  <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">match</span> stm <span style="color:#66d9ef">with</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Print</span> exps <span style="color:#f92672">-&gt;</span>
    List.fold_left <span style="color:#f92672">~</span>init<span style="color:#f92672">:</span>env <span style="color:#f92672">~</span>f<span style="color:#f92672">:</span>print exps
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Assign</span> <span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> exp<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span>
    <span style="color:#66d9ef">let</span> <span style="color:#f92672">(</span>data<span style="color:#f92672">,</span> env1<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> interp_exp exp env <span style="color:#66d9ef">in</span>
    Map.set env1 <span style="color:#f92672">~</span>key <span style="color:#f92672">~</span>data
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Compound</span> <span style="color:#f92672">(</span>stm1<span style="color:#f92672">,</span> stm2<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span>
    <span style="color:#66d9ef">let</span> env1 <span style="color:#f92672">=</span> interp_stm stm1 env <span style="color:#66d9ef">in</span>
    interp_stm stm2 env1

<span style="color:#f92672">and</span> interp_exp exp env <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">match</span> exp <span style="color:#66d9ef">with</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Id</span> k <span style="color:#f92672">-&gt;</span>
    <span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> Map.find_exn env k <span style="color:#66d9ef">in</span> <span style="color:#f92672">(</span>v<span style="color:#f92672">,</span> env<span style="color:#f92672">)</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Num</span> x <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> env<span style="color:#f92672">)</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Op</span> <span style="color:#f92672">(</span>exp1<span style="color:#f92672">,</span> op<span style="color:#f92672">,</span> exp2<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span>
    <span style="color:#66d9ef">let</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> env1<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> interp_exp exp1 env <span style="color:#66d9ef">in</span>
    <span style="color:#66d9ef">let</span> <span style="color:#f92672">(</span>y<span style="color:#f92672">,</span> env2<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> interp_exp exp2 env1 <span style="color:#66d9ef">in</span>
    <span style="color:#66d9ef">let</span> r <span style="color:#f92672">=</span> eval x op y <span style="color:#66d9ef">in</span>
    <span style="color:#f92672">(</span>r<span style="color:#f92672">,</span> env2<span style="color:#f92672">)</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Eseq</span> <span style="color:#f92672">(</span>stm<span style="color:#f92672">,</span> exp<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span>
    <span style="color:#66d9ef">let</span> env1 <span style="color:#f92672">=</span> interp_stm stm env <span style="color:#66d9ef">in</span>
    interp_exp exp env1
</code></pre></div><p>Here we&rsquo;re just recursively traversing a tree, keeping a map of
identifiers, evaluating arithmetic operations and printing
values.</p>
</li>
</ul>
<h4 id="excersises">
  Excersises
  <a class="heading-link" href="#excersises">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>A couple of more excercises about trees, nothing super exciting.
So I won&rsquo;t paste the rest of my solutions here. To implement a
balanced-tree (ex. d) I&rsquo;ve read the chapter about Red-Black
Trees in <a href="https://www.amazon.com/Purely-Functional-Data-Structures-Okasaki/dp/0521663504">Okasaki book.</a> The code is <a href="https://github.com/vyorkin/tiger/blob/master/chapter1/rb%5Ftree.ml">here</a>.</p>
<p>Well, thats all for part 1! The next one is about lexical
analysis where we&rsquo;ll write a simple lexer for the Tiger
language.</p>
<h4 id="conclusion">
  Conclusion
  <a class="heading-link" href="#conclusion">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>By the time I&rsquo;ve decided to start writing this post I&rsquo;ve already
finished reading 6th chapter and here are some first impressions:</p>
<ul>
<li>The book is clear and enjoyable to read. Programming
assignments and exercises are well thought out</li>
<li>Implementing the typechecker (chapter 5) wasn&rsquo;t easy, for me
it took a week to make it work and typecheck correctly every
given example program</li>
<li>Chapter 6 feels easier (less code to write), but requires some
basic knowledge about microprocessor architectures (SPARK,
MIPS)</li>
</ul>
<p>I wouldn&rsquo;t recommend starting with this book to someone with
zero compiler design knowledge. But it is definitely a must read
for people who already know the basics of compiler construction.</p>
<h3 id="making-of-tiger-2-lexical-analysis">
  <!-- raw HTML omitted -->DONE<!-- raw HTML omitted --> Making of Tiger #2, Lexical Analysis
  <a class="heading-link" href="#making-of-tiger-2-lexical-analysis">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<h4 id="intro">
  Intro
  <a class="heading-link" href="#intro">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>We need a way to translate a program written in one
(human-friendly) language to another (machine-specific)
language. Generally, this work is splitted into 2 parts:
<strong>analysis</strong> and <strong>synthesis</strong>.</p>
<p>The <strong>synthesis</strong>-part (back end) is responsible for the code
generation and optimizations.</p>
<p><strong>Analysis</strong>-part (front end) is responsible for breaking the
program apart to understand its structure and meaning. There are
3 commonly used <strong>analysis</strong> phases:</p>
<ol>
<li><strong>Lexical</strong> â breaking a sequence of characters into sequence
of individual <strong>tokens</strong> (words)</li>
<li><strong>Syntax</strong> â parsing and checking that we have a valid sequnce
of tokens</li>
<li><strong>Semantic</strong> â gathering the programâs meaning, making sure
that declarations and statements of program are semantically
correct, this usually includes type checking</li>
</ol>
<p>So, in this blog posts weâll focus on implementing the <strong>lexical
analysis</strong> phase.</p>
<p>A lexical <strong>token</strong> is a string with an assigned and identified
meaning. This is a <strong>unit</strong> in a grammar of a programming
language.</p>
<ul>
<li>Example <strong>tokens</strong>: identifiers, keywords, separators, operators</li>
<li>Example <strong>non-tokens</strong>: white-spaces, tabs, newlines, comments,
preprocessor directives, macroses</li>
</ul>
<p>Now, Iâm going to skip everything related to finite automata and
regular expressions and go straight to the implementation of
<strong>lexer</strong> (lexical analyzer). You can find a good intro to lexing
and parsing using <code>ocamllex</code> and <code>menhir</code> in the <a href="http://dev.realworldocaml.org/parsing-with-ocamllex-and-menhir.html">Read World
OCaml book</a>.</p>
<h4 id="example-lexer--morse-code">
  Example lexer (morse code)
  <a class="heading-link" href="#example-lexer--morse-code">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>Weâll start with the simplest possible example of building a
lexer for <a href="https://en.wikipedia.org/wiki/Morse%5Fcode">morse code</a>, the full source code is <a href="https://github.com/vyorkin/tiger/blob/master/play/menhir/morse-code-simple/lexer.mll">here</a>.</p>
<p>The <code>dune</code> file for our playground project is going to look like
this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">(ocamllex
 (modules lexer))

(executable
 (name driver)
 (libraries core stdio)
 (preprocess (pps ppx_deriving.show)))

(env (dev (flags (<span style="color:#e6db74">:standard</span> -warn-error -A))))
</code></pre></div><p>Nothing fancy here. Next one is the <code>driver.ml</code> module, this is
our entry point. It simply reads the given file, runs our lexer
and displays the resulting S-expression.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Core</span>
<span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Syntax</span>

<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> tokens buf <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">match</span> Lexer.read buf <span style="color:#66d9ef">with</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">EOF</span> <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">[</span><span style="color:#a6e22e">EOF</span><span style="color:#f92672">]</span>
  <span style="color:#f92672">|</span> tok <span style="color:#f92672">-&gt;</span> tok<span style="color:#f92672">::</span>tokens buf

<span style="color:#66d9ef">let</span> lex_print ch <span style="color:#f92672">=</span>
  ch
  <span style="color:#f92672">|&gt;</span> Lexing.from_channel
  <span style="color:#f92672">|&gt;</span> tokens
  <span style="color:#f92672">|&gt;</span> List.iter <span style="color:#f92672">~</span>f<span style="color:#f92672">:(</span><span style="color:#66d9ef">fun</span> e <span style="color:#f92672">-&gt;</span> Format.printf <span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">(</span>show_exp e<span style="color:#f92672">))</span>

<span style="color:#66d9ef">let</span> run filename () <span style="color:#f92672">=</span>
  In_channel.with_file filename <span style="color:#f92672">~</span>f<span style="color:#f92672">:</span>lex_print

<span style="color:#66d9ef">let</span> () <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> spec <span style="color:#f92672">=</span> Command.Spec.<span style="color:#f92672">(</span>empty <span style="color:#f92672">+&gt;</span> anon <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;filename&#34;</span> <span style="color:#f92672">%:</span> <span style="color:#66d9ef">string</span><span style="color:#f92672">))</span> <span style="color:#66d9ef">in</span>
  run
  <span style="color:#f92672">|&gt;</span> Command.basic_spec <span style="color:#f92672">~</span>summary<span style="color:#f92672">:</span><span style="color:#e6db74">&#34;Run the lexer and display tokens&#34;</span> spec
  <span style="color:#f92672">|&gt;</span> Command.run
</code></pre></div><p>We need a module to describe our tokens, lets call it
<code>syntax.ml</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">type</span> exp <span style="color:#f92672">=</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">SYM</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span> <span style="color:#75715e">(* symbol *)</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">SEP</span> <span style="color:#75715e">(* separator *)</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">EOF</span> <span style="color:#75715e">(* end of file *)</span>
  <span style="color:#f92672">[@@</span>deriving show<span style="color:#f92672">]</span>
</code></pre></div><p>And the lexer generator itself:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">{</span>
  <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Lexing</span>
  <span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Syntax</span>

  <span style="color:#75715e">(* Custom exception type for lexer errors *)</span>
  <span style="color:#66d9ef">exception</span> <span style="color:#a6e22e">SyntaxError</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">(* Regular expressions: *)</span>

<span style="color:#75715e">(* We use whitespace as a separator, so
</span><span style="color:#75715e">   it is a valid token in our language *)</span>
<span style="color:#66d9ef">let</span> white   <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#39; &#39;</span> <span style="color:#e6db74">&#39;\t&#39;</span><span style="color:#f92672">]+</span>
<span style="color:#66d9ef">let</span> newline <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\r&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;\n&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>
<span style="color:#66d9ef">let</span> sym     <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#39;.&#39;</span> <span style="color:#e6db74">&#39;-&#39;</span><span style="color:#f92672">]+</span>

<span style="color:#75715e">(* Lexing rules: *)</span>

rule read <span style="color:#f92672">=</span> parse
  <span style="color:#75715e">(* New lines are separators too *)</span>
  <span style="color:#f92672">|</span> newline <span style="color:#f92672">{</span> new_line lexbuf<span style="color:#f92672">;</span> <span style="color:#a6e22e">SEP</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> sym     <span style="color:#f92672">{</span> <span style="color:#a6e22e">SYM</span> <span style="color:#f92672">(</span>lexeme lexbuf<span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> white   <span style="color:#f92672">{</span> <span style="color:#a6e22e">SEP</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#f92672">_</span>       <span style="color:#f92672">{</span> <span style="color:#66d9ef">raise</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">SyntaxError</span> <span style="color:#f92672">(</span>Printf.sprintf <span style="color:#e6db74">&#34;At offset %d: unexpected character.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">(</span>lexeme_start lexbuf<span style="color:#f92672">)))</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> eof     <span style="color:#f92672">{</span> <span style="color:#a6e22e">EOF</span> <span style="color:#f92672">}</span>
</code></pre></div><p>Now we can parse the âhello worldâ sequence written in Morse
Code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">.... . .-.. .-.. ---
.-- --- .-. .-.. -..
</code></pre></div><p>The output will be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">(SYM <span style="color:#e6db74">&#34;....&#34;</span>) SEP (SYM <span style="color:#e6db74">&#34;.&#34;</span>) SEP (SYM <span style="color:#e6db74">&#34;.-..&#34;</span>) SEP (SYM <span style="color:#e6db74">&#34;.-..&#34;</span>) SEP (SYM <span style="color:#e6db74">&#34;---&#34;</span>)
SEP
(SYM <span style="color:#e6db74">&#34;.--&#34;</span>) SEP (SYM <span style="color:#e6db74">&#34;---&#34;</span>) SEP (SYM <span style="color:#e6db74">&#34;.-.&#34;</span>) SEP (SYM <span style="color:#e6db74">&#34;.-..&#34;</span>) SEP (SYM <span style="color:#e6db74">&#34;-..&#34;</span>)
EOF
</code></pre></div><h4 id="tiger-lexer">
  Tiger lexer
  <a class="heading-link" href="#tiger-lexer">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>Having that basic understanding of how to use the <code>ocamllex</code> to
build lexers, we can try to build one for our Tiger language.</p>
<p>The <code>dune</code> file is going to remain the same as in the âmorse
codeâ example above. There is a <strong>Tiger Language Reference Manual
in Appendix A</strong> of the book where you can find the information
about the tokens we need: identifiers, comments, declarations,
data types, etc.</p>
<p>For now, we donât need to define a real AST data type.</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">type</span> exp <span style="color:#f92672">=</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">TYPE</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">VAR</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">FUNCTION</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">BREAK</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">OF</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">END</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">IN</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">NIL</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">LET</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">DO</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">TO</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">FOR</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">WHILE</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">ELSE</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">THEN</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">IF</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">ARRAY</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">ASSIGN</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">OR</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">AND</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">GE</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">GT</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">LE</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">LT</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">NEQ</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">EQ</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">DIVIDE</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">TIMES</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">MINUS</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">PLUS</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">DOT</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">RBRACE</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">LBRACE</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">RBRACK</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">LBRACK</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">RPAREN</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">LPAREN</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">SEMICOLON</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">COLON</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">COMMA</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">STRING</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">INT</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">int</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">ID</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span>
    <span style="color:#f92672">|</span> <span style="color:#a6e22e">EOF</span>
    <span style="color:#f92672">[@@</span>deriving show<span style="color:#f92672">]</span>
</code></pre></div><!-- raw HTML omitted -->
<p>We want to focus on the lexer part. First, we might want to open
some commonly used modules and define a custom exception type
for lexing errors.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">{</span>
<span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Lexing</span>
<span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Syntax</span>
<span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Base</span>

<span style="color:#66d9ef">exception</span> <span style="color:#a6e22e">SyntaxError</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">string</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Next, we need a few regular expressions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">
<span style="color:#66d9ef">let</span> digit <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">-</span><span style="color:#e6db74">&#39;9&#39;</span><span style="color:#f92672">]</span>
<span style="color:#75715e">(* There are no negative integer literals in Tiger *)</span>
<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">=</span> digit<span style="color:#f92672">+</span>
<span style="color:#66d9ef">let</span> frac <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;.&#39;</span> digit<span style="color:#f92672">*</span>
<span style="color:#66d9ef">let</span> exp <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#39;e&#39;</span> <span style="color:#e6db74">&#39;E&#39;</span><span style="color:#f92672">]</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#e6db74">&#39;+&#39;</span><span style="color:#f92672">]?</span> <span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">float</span> <span style="color:#f92672">=</span> digit<span style="color:#f92672">*</span> frac<span style="color:#f92672">?</span> exp<span style="color:#f92672">?</span>
<span style="color:#66d9ef">let</span> white <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#39; &#39;</span> <span style="color:#e6db74">&#39;\t&#39;</span><span style="color:#f92672">]+</span>
<span style="color:#66d9ef">let</span> newline <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\r&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;\n&#39;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\r\n</span><span style="color:#e6db74">&#34;</span>
</code></pre></div><p>According to <strong>Appendix A</strong>:</p>
<blockquote>
<p>An <strong>identifier</strong> is a sequence of letters, digits and
underscores, starting with a letter. Uppercase letters are
distinguished from lowercase.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> alphanum <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">-</span><span style="color:#e6db74">&#39;z&#39;</span> <span style="color:#e6db74">&#39;A&#39;</span><span style="color:#f92672">-</span><span style="color:#e6db74">&#39;Z&#39;</span> <span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">-</span><span style="color:#e6db74">&#39;9&#39;</span> <span style="color:#e6db74">&#39;_&#39;</span><span style="color:#f92672">]</span>
<span style="color:#66d9ef">let</span> id <span style="color:#f92672">=</span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">-</span><span style="color:#e6db74">&#39;z&#39;</span><span style="color:#f92672">]</span> alphanum<span style="color:#f92672">*</span>
</code></pre></div><p>Lexing rules.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">rule read <span style="color:#f92672">=</span> parse
  <span style="color:#75715e">(* Whitespaces *)</span>
  <span style="color:#f92672">|</span> white <span style="color:#f92672">{</span> read lexbuf <span style="color:#f92672">}</span>
</code></pre></div><p>We want to skip the new lines.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  <span style="color:#f92672">|</span> newline <span style="color:#f92672">{</span> new_line lexbuf<span style="color:#f92672">;</span> read lexbuf <span style="color:#f92672">}</span>
</code></pre></div><p>We have a separate function to read strings (see the
implementation below).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;&#34;&#39;</span> <span style="color:#f92672">{</span> read_string <span style="color:#f92672">(</span>Buffer.create 16<span style="color:#f92672">)</span> lexbuf <span style="color:#f92672">}</span>
</code></pre></div><p>Again, according the <strong>Appendix A</strong>:</p>
<blockquote>
<p>A comment may appear between any two tokens.
Comments start with <code>/*</code> and end with <code>*/</code> and may be nested.</p>
</blockquote>
<p>Weâll have a separate function for reading comments (scroll down
to see its code).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;/*&#34;</span> <span style="color:#f92672">{</span> read_comment <span style="color:#f92672">[</span>lexbuf<span style="color:#f92672">.</span>lex_curr_p<span style="color:#f92672">]</span> lexbuf <span style="color:#f92672">}</span>
</code></pre></div><p>Basic keywords:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;type&#34;</span>     <span style="color:#f92672">{</span> <span style="color:#a6e22e">TYPE</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;var&#34;</span>      <span style="color:#f92672">{</span> <span style="color:#a6e22e">VAR</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;function&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">FUNCTION</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;break&#34;</span>    <span style="color:#f92672">{</span> <span style="color:#a6e22e">BREAK</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;of&#34;</span>       <span style="color:#f92672">{</span> <span style="color:#a6e22e">OF</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;end&#34;</span>      <span style="color:#f92672">{</span> <span style="color:#a6e22e">END</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;in&#34;</span>       <span style="color:#f92672">{</span> <span style="color:#a6e22e">IN</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;nil&#34;</span>      <span style="color:#f92672">{</span> <span style="color:#a6e22e">NIL</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;let&#34;</span>      <span style="color:#f92672">{</span> <span style="color:#a6e22e">LET</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;array&#34;</span>    <span style="color:#f92672">{</span> <span style="color:#a6e22e">ARRAY</span> <span style="color:#f92672">}</span>
</code></pre></div><p>We need 4 tokens for loops:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;do&#34;</span>    <span style="color:#f92672">{</span> <span style="color:#a6e22e">DO</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;to&#34;</span>    <span style="color:#f92672">{</span> <span style="color:#a6e22e">TO</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;for&#34;</span>   <span style="color:#f92672">{</span> <span style="color:#a6e22e">FOR</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;while&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">WHILE</span> <span style="color:#f92672">}</span>
</code></pre></div><p>Conditionals (<code>if-then-else</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;else&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">ELSE</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;then&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">THEN</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;if&#34;</span>   <span style="color:#f92672">{</span> <span style="color:#a6e22e">IF</span> <span style="color:#f92672">}</span>
</code></pre></div><p>Operators:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  <span style="color:#75715e">(* General *)</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;:=&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">ASSIGN</span> <span style="color:#f92672">}</span>

  <span style="color:#75715e">(* Logical *)</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;|&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">OR</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;&amp;&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">AND</span> <span style="color:#f92672">}</span>

  <span style="color:#75715e">(* Comparison *)</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;&gt;=&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">GE</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;&gt;&#34;</span>  <span style="color:#f92672">{</span> <span style="color:#a6e22e">GT</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;&lt;=&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">LE</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;&lt;&#34;</span>  <span style="color:#f92672">{</span> <span style="color:#a6e22e">LT</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;&lt;&gt;&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">NEQ</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;=&#34;</span>  <span style="color:#f92672">{</span> <span style="color:#a6e22e">EQ</span> <span style="color:#f92672">}</span>

  <span style="color:#75715e">(* Arithmetics *)</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;/&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">DIVIDE</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;*&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">TIMES</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;-&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">MINUS</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;+&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">PLUS</span> <span style="color:#f92672">}</span>
</code></pre></div><p>Separators:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">DOT</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;{&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">LBRACE</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;}&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">RBRACE</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;[&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">LBRACK</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;]&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">RBRACK</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;(&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">LPAREN</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;)&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">RPAREN</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;;&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">SEMICOLON</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">COLON</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;,&#34;</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">COMMA</span> <span style="color:#f92672">}</span>
</code></pre></div><p>Numebers, identifiers, error and EOF handling:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">  <span style="color:#f92672">|</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">{</span> <span style="color:#a6e22e">INT</span> <span style="color:#f92672">(</span>Int.of_string <span style="color:#f92672">(</span>Lexing.lexeme lexbuf<span style="color:#f92672">))</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> id  <span style="color:#f92672">{</span> <span style="color:#a6e22e">ID</span> <span style="color:#f92672">(</span>Lexing.lexeme lexbuf<span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#f92672">_</span>   <span style="color:#f92672">{</span> <span style="color:#66d9ef">raise</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">SyntaxError</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Unexpected character: &#34;</span> <span style="color:#f92672">^</span> Lexing.lexeme lexbuf<span style="color:#f92672">))</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> eof <span style="color:#f92672">{</span> <span style="color:#a6e22e">EOF</span> <span style="color:#f92672">}</span>
</code></pre></div><p>The rule to match string literals:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">and</span> read_string buf <span style="color:#f92672">=</span> parse
  <span style="color:#75715e">(* If we reach the terminating double quote, then
</span><span style="color:#75715e">   * we return the contents of the buffer as a STRING. *)</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;&#34;&#39;</span>       <span style="color:#f92672">{</span> <span style="color:#a6e22e">STRING</span> <span style="color:#f92672">(</span>Buffer.contents buf<span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
  <span style="color:#75715e">(* Handling escape sequences *)</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;\\&#39;</span> <span style="color:#e6db74">&#39;\\&#39;</span> <span style="color:#f92672">{</span> Buffer.add_char buf <span style="color:#e6db74">&#39;\\&#39;</span><span style="color:#f92672">;</span> read_string buf lexbuf <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;\\&#39;</span> <span style="color:#e6db74">&#39;/&#39;</span>  <span style="color:#f92672">{</span> Buffer.add_char buf <span style="color:#e6db74">&#39;/&#39;</span><span style="color:#f92672">;</span>  read_string buf lexbuf <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;\\&#39;</span> <span style="color:#e6db74">&#39;b&#39;</span>  <span style="color:#f92672">{</span> Buffer.add_char buf <span style="color:#e6db74">&#39;\b&#39;</span><span style="color:#f92672">;</span> read_string buf lexbuf <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;\\&#39;</span> <span style="color:#e6db74">&#39;f&#39;</span>  <span style="color:#f92672">{</span> Buffer.add_char buf <span style="color:#e6db74">&#39;\012&#39;</span><span style="color:#f92672">;</span> read_string buf lexbuf <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;\\&#39;</span> <span style="color:#e6db74">&#39;n&#39;</span>  <span style="color:#f92672">{</span> Buffer.add_char buf <span style="color:#e6db74">&#39;\n&#39;</span><span style="color:#f92672">;</span> read_string buf lexbuf <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;\\&#39;</span> <span style="color:#e6db74">&#39;r&#39;</span>  <span style="color:#f92672">{</span> Buffer.add_char buf <span style="color:#e6db74">&#39;\r&#39;</span><span style="color:#f92672">;</span> read_string buf lexbuf <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#39;\\&#39;</span> <span style="color:#e6db74">&#39;t&#39;</span>  <span style="color:#f92672">{</span> Buffer.add_char buf <span style="color:#e6db74">&#39;\t&#39;</span><span style="color:#f92672">;</span> read_string buf lexbuf <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#f92672">[^</span> <span style="color:#e6db74">&#39;&#34;&#39;</span> <span style="color:#e6db74">&#39;\\&#39;</span><span style="color:#f92672">]+</span>
    <span style="color:#f92672">{</span> Buffer.add_string buf <span style="color:#f92672">(</span>Lexing.lexeme lexbuf<span style="color:#f92672">);</span>
      read_string buf lexbuf
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#f92672">_</span>   <span style="color:#f92672">{</span> <span style="color:#66d9ef">raise</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">SyntaxError</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Illegal string character: &#34;</span> <span style="color:#f92672">^</span> Lexing.lexeme lexbuf<span style="color:#f92672">))</span> <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> eof <span style="color:#f92672">{</span> <span style="color:#66d9ef">raise</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">SyntaxError</span> <span style="color:#e6db74">&#34;String is not terminated&#34;</span><span style="color:#f92672">)</span> <span style="color:#f92672">}</span>
</code></pre></div><p>The rule to match comments (including nested comments), keeping
a list of where comments open:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">and</span> read_comment opened <span style="color:#f92672">=</span> parse
  <span style="color:#75715e">(* Opening comment *)</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;/*&#34;</span> <span style="color:#f92672">{</span> read_comment <span style="color:#f92672">(</span>lexbuf<span style="color:#f92672">.</span>lex_curr_p<span style="color:#f92672">::</span>opened<span style="color:#f92672">)</span> lexbuf <span style="color:#f92672">}</span>
  <span style="color:#75715e">(* Closing comment *)</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;*/&#34;</span>
    <span style="color:#f92672">{</span> <span style="color:#66d9ef">match</span> opened <span style="color:#66d9ef">with</span>
      <span style="color:#75715e">(* No nested opened comments left, continue parsing. *)</span>
      <span style="color:#f92672">|</span> <span style="color:#f92672">_::</span>[] <span style="color:#f92672">-&gt;</span> read lexbuf
      <span style="color:#75715e">(* Continue parsing comment. *)</span>
      <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> read_comment <span style="color:#f92672">(</span>List.tl_exn opened<span style="color:#f92672">)</span> lexbuf
    <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> newline <span style="color:#f92672">{</span> new_line lexbuf<span style="color:#f92672">;</span> read_comment opened lexbuf <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">{</span> read_comment opened lexbuf <span style="color:#f92672">}</span>
  <span style="color:#75715e">(* Unexpected end-of-file. Update the current location to
</span><span style="color:#75715e">   * point to the opening token that wasn&#39;t closed and raise an error. *)</span>
  <span style="color:#f92672">|</span> eof
    <span style="color:#f92672">{</span> lexbuf<span style="color:#f92672">.</span>lex_curr_p <span style="color:#f92672">&lt;-</span> List.hd_exn opened<span style="color:#f92672">;</span>
      <span style="color:#66d9ef">raise</span> <span style="color:#f92672">(</span><span style="color:#a6e22e">SyntaxError</span> <span style="color:#e6db74">&#34;Unterminated comment&#34;</span><span style="color:#f92672">)</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h4 id="summary">
  Summary
  <a class="heading-link" href="#summary">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>Weâve learned some new things, like <code>ocamllex</code>, but overall, it
wasnât too hard to follow the book. The full OCaml source code
for the second chapter can be found <a href="https://github.com/vyorkin/tiger/blob/master/chapter2/lexer.mll">here</a>. In the next part weâre
going to write a parser.</p>
<h3 id="making-of-tiger-3-parsing">
  <!-- raw HTML omitted -->DONE<!-- raw HTML omitted --> Making of Tiger #3, Parsing
  <a class="heading-link" href="#making-of-tiger-3-parsing">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<h4 id="intro">
  Intro
  <a class="heading-link" href="#intro">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>In this chapter weâre going to build a parser for our Tiger
language. First, letâs do a quick recap of some important
concepts of the theory behind programming language parsers:</p>
<ul>
<li><strong>Parser generator</strong> is the most common type of
<a href="https://en.wikipedia.org/wiki/Compiler-compiler">compiler-compilerâs</a>. It takes some formal grammar (typically
it is a <a href="https://en.wikipedia.org/wiki/Context-free%5Fgrammar">context-free grammar</a> in <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur%5Fform">BNF</a> or <a href="https://en.wikipedia.org/wiki/Extended%5FBackus%E2%80%93Naur%5Fform">EBNF </a>form), that
defines a syntax of a programming language.</li>
</ul>
<h4 id="tiger-grammar-with-menhir">
  Tiger grammar with Menhir
  <a class="heading-link" href="#tiger-grammar-with-menhir">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>While reading the current paragraph I highly recommend
consulting the <strong>Tiger Language Reference Manual</strong> that has a
precise description (along with a BNF notation) of everything
weâre going to define below.</p>
<p><a href="http://gallium.inria.fr/~fpottier/menhir/">Menhir</a> is an LR(1) parser generator library for OCaml. It
<a href="https://dune.readthedocs.io/en/stable/dune-files.html#menhir">integrates with Dune</a> quiet nicely. All we need to do is to add
the <code>menhir</code> stanza to our <code>dune</code> file (the one from the
previous chapter). So the whole file will look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">(menhir
 (modules parser)
 (flags (<span style="color:#e6db74">&#34;--dump&#34;</span> <span style="color:#e6db74">&#34;--explain&#34;</span>)))

(ocamllex
 (modules lexer))

(library
 (name ch3)
 (inline_tests)
 (libraries core stdio)
 (preprocess (pps ppx_inline_test ppx_expect)))

(env (dev (flags (<span style="color:#e6db74">:standard</span> -warn-error -A))))
</code></pre></div><p>Notice the <code>--dump</code> and <code>--explain</code> switches:</p>
<ul>
<li>The <code>--dump</code> switch means to write a description of the
automaton to the <code>.automaton</code> file.</li>
<li>The <code>--explain</code> switch helps us to understand severe conflicts in
terms of a grammar (rather than in terms of automaton),
enabling it means to write a textual explanation of detected
shift-reduce conflicts to the <code>.conflicts</code> file. <a href="http://ix.io/1SAS">Here is
the example</a> of how it looks.</li>
</ul>
<p>See the <a href="http://gallium.inria.fr/~fpottier/menhir/manual.html#sec37">conflicts</a> part of the Menhir manual for details.</p>
<p>Weâll use the
<a href="http://gallium.inria.fr/~fpottier/menhir/manual.html#sec23">new
syntax</a> for rules (despite the fact that it is considered
experimental). First, letâs define some
<a href="http://gallium.inria.fr/~fpottier/menhir/manual.html#sec9">token
aliases</a>, priorities and associativity levels. Basically these
are the same tokens we used in our lexer.</p>
<p>Base keywords:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">%</span>token <span style="color:#a6e22e">TYPE</span>     <span style="color:#e6db74">&#34;type&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">VAR</span>      <span style="color:#e6db74">&#34;var&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">FUNCTION</span> <span style="color:#e6db74">&#34;function&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">BREAK</span>    <span style="color:#e6db74">&#34;break&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">OF</span>       <span style="color:#e6db74">&#34;of&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">END</span>      <span style="color:#e6db74">&#34;end&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">IN</span>       <span style="color:#e6db74">&#34;in&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">NIL</span>      <span style="color:#e6db74">&#34;nil&#34;</span> <span style="color:#75715e">(* nil denotes a value belonging to every record type *)</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">LET</span>      <span style="color:#e6db74">&#34;let&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">ARRAY</span>    <span style="color:#e6db74">&#34;array&#34;</span>
</code></pre></div><p>Loop-related keywords:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">%</span>token <span style="color:#a6e22e">DO</span>    <span style="color:#e6db74">&#34;do&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">TO</span>    <span style="color:#e6db74">&#34;to&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">FOR</span>   <span style="color:#e6db74">&#34;for&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">WHILE</span> <span style="color:#e6db74">&#34;while&#34;</span>
</code></pre></div><p>Keywords for conditional expression:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">%</span>token <span style="color:#a6e22e">IF</span>   <span style="color:#e6db74">&#34;if&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">THEN</span> <span style="color:#e6db74">&#34;then&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">ELSE</span> <span style="color:#e6db74">&#34;else&#34;</span>
</code></pre></div><p>Operator tokens:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#75715e">(* General *)</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">ASSIGN</span> <span style="color:#e6db74">&#34;:=&#34;</span>

<span style="color:#75715e">(* Logical *)</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">OR</span>  <span style="color:#e6db74">&#34;|&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">AND</span> <span style="color:#e6db74">&#34;&amp;&#34;</span>

<span style="color:#75715e">(* Comparison *)</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">GE</span>  <span style="color:#e6db74">&#34;&gt;=&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">GT</span>  <span style="color:#e6db74">&#34;&gt;&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">LE</span>  <span style="color:#e6db74">&#34;&lt;=&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">LT</span>  <span style="color:#e6db74">&#34;&lt;&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">NEQ</span> <span style="color:#e6db74">&#34;&lt;&gt;&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">EQ</span>  <span style="color:#e6db74">&#34;=&#34;</span>

<span style="color:#75715e">(* Arithmetics *)</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">DIVIDE</span> <span style="color:#e6db74">&#34;/&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">TIMES</span>  <span style="color:#e6db74">&#34;*&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">PLUS</span>   <span style="color:#e6db74">&#34;+&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">MINUS</span>  <span style="color:#e6db74">&#34;-&#34;</span>
</code></pre></div><p>Tokens for separators:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">%</span>token <span style="color:#a6e22e">DOT</span>       <span style="color:#e6db74">&#34;.&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">LBRACE</span>    <span style="color:#e6db74">&#34;{&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">RBRACE</span>    <span style="color:#e6db74">&#34;}&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">LBRACK</span>    <span style="color:#e6db74">&#34;[&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">RBRACK</span>    <span style="color:#e6db74">&#34;]&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">LPAREN</span>    <span style="color:#e6db74">&#34;(&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">RPAREN</span>    <span style="color:#e6db74">&#34;)&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">SEMICOLON</span> <span style="color:#e6db74">&#34;;&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">COLON</span>     <span style="color:#e6db74">&#34;:&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#a6e22e">COMMA</span>     <span style="color:#e6db74">&#34;,&#34;</span>
</code></pre></div><p>Strings, numbers, identifiers and the <code>EOF</code> token:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">%</span>token <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">string</span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">STRING</span> <span style="color:#e6db74">&#34;string&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>    <span style="color:#a6e22e">INT</span>    <span style="color:#e6db74">&#34;int&#34;</span>
<span style="color:#f92672">%</span>token <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">string</span><span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">ID</span>     <span style="color:#e6db74">&#34;id&#34;</span>

<span style="color:#f92672">%</span>token <span style="color:#a6e22e">EOF</span>
</code></pre></div><p>Associativity of operators:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">%</span>nonassoc <span style="color:#e6db74">&#34;of&#34;</span>
<span style="color:#f92672">%</span>nonassoc <span style="color:#e6db74">&#34;then&#34;</span>
<span style="color:#f92672">%</span>nonassoc <span style="color:#e6db74">&#34;else&#34;</span>
<span style="color:#f92672">%</span>nonassoc <span style="color:#e6db74">&#34;do&#34;</span>
<span style="color:#f92672">%</span>nonassoc <span style="color:#e6db74">&#34;:=&#34;</span>
<span style="color:#f92672">%</span>left     <span style="color:#e6db74">&#34;|&#34;</span>
<span style="color:#f92672">%</span>left     <span style="color:#e6db74">&#34;&amp;&#34;</span>
<span style="color:#f92672">%</span>nonassoc <span style="color:#e6db74">&#34;&gt;=&#34;</span> <span style="color:#e6db74">&#34;&gt;&#34;</span> <span style="color:#e6db74">&#34;&lt;=&#34;</span> <span style="color:#e6db74">&#34;&lt;&#34;</span> <span style="color:#e6db74">&#34;&lt;&gt;&#34;</span> <span style="color:#e6db74">&#34;=&#34;</span>
<span style="color:#f92672">%</span>left     <span style="color:#e6db74">&#34;+&#34;</span> <span style="color:#e6db74">&#34;-&#34;</span>
<span style="color:#f92672">%</span>left     <span style="color:#e6db74">&#34;*&#34;</span> <span style="color:#e6db74">&#34;/&#34;</span>
</code></pre></div><p>Now, the grammar rules:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">%</span>start <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unit</span><span style="color:#f92672">&gt;</span> main

<span style="color:#f92672">%%</span>

<span style="color:#66d9ef">let</span> main <span style="color:#f92672">:=</span>
  <span style="color:#f92672">~</span> <span style="color:#f92672">=</span> expr<span style="color:#f92672">;</span> <span style="color:#a6e22e">EOF</span><span style="color:#f92672">;</span> <span style="color:#f92672">&lt;&gt;</span>
</code></pre></div><p>Top-level expression:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> expr <span style="color:#f92672">:=</span>
  <span style="color:#f92672">|</span> primitive
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;nil&#34;</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;break&#34;</span>
  <span style="color:#f92672">|</span> create_rec
  <span style="color:#f92672">|</span> create_arr
  <span style="color:#f92672">|</span> lvalue
  <span style="color:#f92672">|</span> assignment
  <span style="color:#f92672">|</span> local
  <span style="color:#f92672">|</span> conditional
  <span style="color:#f92672">|</span> loop
  <span style="color:#f92672">|</span> fun_call
  <span style="color:#f92672">|</span> unary
  <span style="color:#f92672">|</span> binary
  <span style="color:#f92672">|</span> seq
</code></pre></div><p>It might not be obvious from the <code>expr</code> definition, but it also
includes a thing called <code>no value</code> (an expression that yields no
value). So when looking at the top-level expression and
comparing it to the language reference manual, please note that
in our grammar <code>no_val := &quot;(&quot; &quot;)&quot;</code> (empty <code>seq</code>).</p>
<p>There are two built-in (predefined) primitive types: <code>int</code> and
<code>string</code>. The grammar rule for those is pretty straightforward:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> primitive <span style="color:#f92672">:=</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;string&#34;</span><span style="color:#f92672">;</span> <span style="color:#f92672">{</span> () <span style="color:#f92672">}</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;int&#34;</span><span style="color:#f92672">;</span> <span style="color:#f92672">{</span> () <span style="color:#f92672">}</span>
</code></pre></div><p>In our language we have only one unary operator â minus:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> unary <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;-&#34;</span><span style="color:#f92672">;</span> expr
</code></pre></div><p>But we have two kinds of binary operators: <code>boolean</code> and
âlogical + arithmeticâ, which weâll simply call <code>bin</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> binary <span style="color:#f92672">:=</span>
  <span style="color:#f92672">|</span> bin
  <span style="color:#f92672">|</span> boolean
</code></pre></div><p>Scroll down to see the definitions of <code>bin</code> and <code>boolean</code>.</p>
<p>We have 2 kinds of loops: the <code>while</code> loop and the <code>for</code> loop:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> loop <span style="color:#f92672">:=</span>
  <span style="color:#f92672">|</span> while_loop
  <span style="color:#f92672">|</span> for_loop

<span style="color:#66d9ef">let</span> while_loop <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;while&#34;</span><span style="color:#f92672">;</span> expr<span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;do&#34;</span><span style="color:#f92672">;</span> expr
<span style="color:#66d9ef">let</span> for_loop   <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;for&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;:=&#34;</span><span style="color:#f92672">;</span> expr<span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;to&#34;</span><span style="color:#f92672">;</span> expr<span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;do&#34;</span><span style="color:#f92672">;</span> expr
</code></pre></div><p>Nothing new or unusual. And the conditional expression rule is
also quite trivial:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> conditional <span style="color:#f92672">:=</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;if&#34;</span><span style="color:#f92672">;</span> expr<span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;then&#34;</span><span style="color:#f92672">;</span> expr<span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;else&#34;</span><span style="color:#f92672">;</span> expr
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;if&#34;</span><span style="color:#f92672">;</span> expr<span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;then&#34;</span><span style="color:#f92672">;</span> expr
</code></pre></div><p>Syntax for local bindings is going to be exactly like in OCaml
or SML:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> local <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;let&#34;</span><span style="color:#f92672">;</span> decs<span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;in&#34;</span><span style="color:#f92672">;</span> expr_seq<span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;end&#34;</span>
</code></pre></div><p>Now, a slightly more complex part â declarations.</p>
<p>As stated in the Tiger language reference manual, a
declaration-sequence is a sequence of <strong>type</strong>, <strong>value</strong>, and
<strong>function declarations</strong>. No punctuation separates or terminates
individual declarations.</p>
<p>In terms of Menhir we can express it like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> decs <span style="color:#f92672">:=</span> <span style="color:#66d9ef">list</span><span style="color:#f92672">(</span>dec<span style="color:#f92672">);</span> <span style="color:#f92672">{</span> () <span style="color:#f92672">}</span>

<span style="color:#66d9ef">let</span> dec <span style="color:#f92672">:=</span>
  <span style="color:#f92672">|</span> ty_dec  <span style="color:#75715e">(* type *)</span>
  <span style="color:#f92672">|</span> var_dec <span style="color:#75715e">(* value *)</span>
  <span style="color:#f92672">|</span> fun_dec <span style="color:#75715e">(* function declaration *)</span>
</code></pre></div><p>Ok, we need to define a separate rule for each declaration
mentioned above.</p>
<p>To declare a data type in the Tiger language we start with the
keyword <code>type</code>, after which comes the identifier, the equality
token and the type declaration body:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> ty_dec <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;type&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;=&#34;</span><span style="color:#f92672">;</span> ty
</code></pre></div><p>The type declaration could be a <strong>record</strong>, an <strong>array</strong> or a <strong>type
alias</strong> (any identifier):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> ty <span style="color:#f92672">:=</span>
  <span style="color:#f92672">|</span> braced<span style="color:#f92672">(</span>ty_fields<span style="color:#f92672">)</span> <span style="color:#75715e">(* records *)</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;array&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;of&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> <span style="color:#f92672">{</span> () <span style="color:#f92672">}</span> <span style="color:#75715e">(* arrays *)</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> <span style="color:#f92672">{</span> () <span style="color:#f92672">}</span>

<span style="color:#66d9ef">let</span> ty_fields <span style="color:#f92672">:=</span> separated_list<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;,&#34;</span><span style="color:#f92672">,</span> ty_field<span style="color:#f92672">);</span> <span style="color:#f92672">{</span> () <span style="color:#f92672">}</span>
<span style="color:#66d9ef">let</span> ty_field  <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> ty_ann
</code></pre></div><p>As per language reference manual, there are two possible ways to
declare a variable: with or without type annotation. The
following rule reflects this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> var_dec <span style="color:#f92672">:=</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;var&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span>         <span style="color:#e6db74">&#34;:=&#34;</span><span style="color:#f92672">;</span> expr
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;var&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> ty_ann<span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;:=&#34;</span><span style="color:#f92672">;</span> expr
</code></pre></div><p>The record and array creation rules below are also considered
top-level expressions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> create_rec <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> braced<span style="color:#f92672">(</span>init_rec_fields<span style="color:#f92672">)</span>
<span style="color:#66d9ef">let</span> create_arr <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> bracketed<span style="color:#f92672">(</span>expr<span style="color:#f92672">);</span> <span style="color:#e6db74">&#34;of&#34;</span><span style="color:#f92672">;</span> expr

<span style="color:#66d9ef">let</span> init_rec_fields <span style="color:#f92672">:=</span> separated_list<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;,&#34;</span><span style="color:#f92672">,</span> init_rec_field<span style="color:#f92672">);</span> <span style="color:#f92672">{</span> () <span style="color:#f92672">}</span>
<span style="color:#66d9ef">let</span> init_rec_field  <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;=&#34;</span><span style="color:#f92672">;</span> expr
</code></pre></div><p>Next, we need a function declaration rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> fun_dec <span style="color:#f92672">:=</span>
  <span style="color:#75715e">(* procedures doesn&#39;t return values *)</span>
  <span style="color:#f92672">|</span> fun_head<span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;=&#34;</span><span style="color:#f92672">;</span> fun_body
  <span style="color:#75715e">(* functions return values and the type is specified after the colon *)</span>
  <span style="color:#f92672">|</span> fun_head<span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;:&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;=&#34;</span><span style="color:#f92672">;</span> fun_body

<span style="color:#66d9ef">let</span> fun_head   <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;function&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> fun_params
<span style="color:#66d9ef">let</span> fun_body   <span style="color:#f92672">:=</span> expr
<span style="color:#66d9ef">let</span> fun_params <span style="color:#f92672">:=</span> parenthesized<span style="color:#f92672">(</span>ty_fields<span style="color:#f92672">)</span>
</code></pre></div><p>According to our language spec:</p>
<blockquote>
<p>An <code>l-value</code> is a location, whose value may be read or assigned.
Variables, procedure parameters, fields or records, and
elements are all <code>l-values</code>.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> lvalue <span style="color:#f92672">:=</span>
  <span style="color:#75715e">(* variable *)</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> <span style="color:#f92672">{</span> () <span style="color:#f92672">}</span>
  <span style="color:#75715e">(* everything else *)</span>
  <span style="color:#f92672">|</span> lvalue_t

<span style="color:#66d9ef">let</span> lvalue_t <span style="color:#f92672">:=</span>
  <span style="color:#75715e">(* simple record field *)</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;.&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> <span style="color:#f92672">{</span> () <span style="color:#f92672">}</span>
  <span style="color:#75715e">(* compound record field *)</span>
  <span style="color:#f92672">|</span> lvalue_t<span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;.&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> <span style="color:#f92672">{</span> () <span style="color:#f92672">}</span>
  <span style="color:#75715e">(* simple array subscript *)</span>
  <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> bracketed<span style="color:#f92672">(</span>expr<span style="color:#f92672">)</span>
  <span style="color:#75715e">(* compund array subscript *)</span>
  <span style="color:#f92672">|</span> lvalue_t<span style="color:#f92672">;</span> bracketed<span style="color:#f92672">(</span>expr<span style="color:#f92672">)</span>
</code></pre></div><p>Assignment of an expression to <code>lvalue</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> assignment <span style="color:#f92672">:=</span> lvalue<span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;:=&#34;</span><span style="color:#f92672">;</span> expr
</code></pre></div><p>Sequence of expressions delimited by semicolon:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> expr_seq <span style="color:#f92672">:=</span> separated_list<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;;&#34;</span><span style="color:#f92672">,</span> expr<span style="color:#f92672">);</span> <span style="color:#f92672">{</span> () <span style="color:#f92672">}</span>

<span style="color:#66d9ef">let</span> seq <span style="color:#f92672">:=</span> parenthesized<span style="color:#f92672">(</span>expr_seq<span style="color:#f92672">)</span>
</code></pre></div><p>Function call rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> fun_call <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;id&#34;</span><span style="color:#f92672">;</span> parenthesized<span style="color:#f92672">(</span>fun_args<span style="color:#f92672">)</span>
<span style="color:#66d9ef">let</span> fun_args <span style="color:#f92672">:=</span> separated_list<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;,&#34;</span><span style="color:#f92672">,</span> expr<span style="color:#f92672">);</span> <span style="color:#f92672">{</span> () <span style="color:#f92672">}</span>
</code></pre></div><p>Arithmetic, comparison and equality expressions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> bin <span style="color:#f92672">:=</span> expr<span style="color:#f92672">;</span> bin_op<span style="color:#f92672">;</span> expr
<span style="color:#66d9ef">let</span> bin_op <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;+&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;-&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;*&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;/&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;&gt;=&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;&gt;&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;&lt;=&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;&lt;&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;&lt;&gt;&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;=&#34;</span>
</code></pre></div><p>Boolean expressions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> boolean <span style="color:#f92672">:=</span> expr<span style="color:#f92672">;</span> boolean_op<span style="color:#f92672">;</span> expr
<span style="color:#66d9ef">let</span> boolean_op <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;&amp;&#34;</span> <span style="color:#f92672">|</span> <span style="color:#e6db74">&#34;|&#34;</span>
</code></pre></div><p>Helper rule for a type annotation which we used in the <code>var_dec</code>
and <code>ty_field</code> above:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> ty_ann <span style="color:#f92672">:=</span> <span style="color:#e6db74">&#34;:&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;id&#34;</span>
</code></pre></div><p>Menhir allows us to declare functions, so these are three helper
functions that we used everywhere else for delimited
expressions:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> parenthesized<span style="color:#f92672">(</span>x<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> delimited<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;(&#34;</span><span style="color:#f92672">,</span> x<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;)&#34;</span><span style="color:#f92672">)</span>
<span style="color:#66d9ef">let</span> bracketed<span style="color:#f92672">(</span>x<span style="color:#f92672">)</span>     <span style="color:#f92672">==</span> delimited<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;[&#34;</span><span style="color:#f92672">,</span> x<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;]&#34;</span><span style="color:#f92672">)</span>
<span style="color:#66d9ef">let</span> braced<span style="color:#f92672">(</span>x<span style="color:#f92672">)</span>        <span style="color:#f92672">==</span> delimited<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;{&#34;</span><span style="color:#f92672">,</span> x<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;}&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><h4 id="test-suite">
  Test suite
  <a class="heading-link" href="#test-suite">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>In order to iterate on our parser quickly we want to automate
the process of testing it against the <a href="https://github.com/vyorkin/tiger/blob/master/book/testcases/test1.tig">provided example programs</a>.
The most convenient way to do that would be to create a test
suite that we could run after every change we make.</p>
<p>Some of the provided example Tiger programs are intentionally
broken, so we want to skip those:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> skipped <span style="color:#f92672">=</span>
  <span style="color:#f92672">[</span><span style="color:#e6db74">&#34;test16.tig&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;test17.tig&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;test19.tig&#34;</span><span style="color:#f92672">;</span>
   <span style="color:#e6db74">&#34;test20.tig&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;test25.tig&#34;</span><span style="color:#f92672">;</span>
   <span style="color:#e6db74">&#34;test45.tig&#34;</span><span style="color:#f92672">;</span> <span style="color:#e6db74">&#34;test49.tig&#34;</span><span style="color:#f92672">]</span>
</code></pre></div><p>A couple of helper functions to list the example programs
(recursively):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> is_tig_ext filename <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> <span style="color:#f92672">(_,</span> ext<span style="color:#f92672">)</span> <span style="color:#f92672">=</span> Filename.split_extension filename <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">match</span> ext <span style="color:#66d9ef">with</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Some</span> <span style="color:#e6db74">&#34;tig&#34;</span> <span style="color:#f92672">-&gt;</span> true
  <span style="color:#f92672">|</span> <span style="color:#f92672">_</span> <span style="color:#f92672">-&gt;</span> false

<span style="color:#66d9ef">let</span> is_tig_file f <span style="color:#f92672">=</span>
  Sys.is_file_exn <span style="color:#f92672">~</span>follow_symlinks<span style="color:#f92672">:</span>true f <span style="color:#f92672">&amp;&amp;</span>
  is_tig_ext f

<span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> ls_rec dir <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">if</span> is_tig_file dir
  <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">if</span> not<span style="color:#f92672">(</span>List.mem skipped <span style="color:#f92672">(</span>Filename.basename dir<span style="color:#f92672">)</span> <span style="color:#f92672">~</span>equal<span style="color:#f92672">:(=))</span> <span style="color:#66d9ef">then</span>
      <span style="color:#f92672">[</span>dir<span style="color:#f92672">]</span>
    <span style="color:#66d9ef">else</span>
      []
  <span style="color:#66d9ef">else</span>
    dir
    <span style="color:#f92672">|&gt;</span> Sys.ls_dir
    <span style="color:#f92672">|&gt;</span> List.concat_map
      <span style="color:#f92672">~</span>f<span style="color:#f92672">:(</span><span style="color:#66d9ef">fun</span> sub <span style="color:#f92672">-&gt;</span> ls_rec <span style="color:#f92672">(</span>Filename.concat dir sub<span style="color:#f92672">))</span>
</code></pre></div><p>Letâs add another helper function to get current position along
with a filename as a string. Weâll need it later to output an
error location:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> position lexbuf <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> pos <span style="color:#f92672">=</span> lexbuf<span style="color:#f92672">.</span>lex_curr_p <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> col <span style="color:#f92672">=</span> pos<span style="color:#f92672">.</span>pos_cnum <span style="color:#f92672">-</span> pos<span style="color:#f92672">.</span>pos_bol <span style="color:#f92672">+</span> 1 <span style="color:#66d9ef">in</span>
  Printf.sprintf <span style="color:#e6db74">&#34;%s:%d:%d&#34;</span> pos<span style="color:#f92672">.</span>pos_fname pos<span style="color:#f92672">.</span>pos_lnum col
</code></pre></div><p>And another two functions to run the parser and print the error
details in case of failure:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> parse_with_error lexbuf <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">try</span>
    Parser.main Lexer.read lexbuf<span style="color:#f92672">;</span>
    assert_bool <span style="color:#e6db74">&#34;Ok&#34;</span> true
  <span style="color:#66d9ef">with</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">SyntaxError</span> msg <span style="color:#f92672">-&gt;</span>
    assert_failure <span style="color:#f92672">(</span>position lexbuf <span style="color:#f92672">^</span> <span style="color:#e6db74">&#34; : &#34;</span> <span style="color:#f92672">^</span> msg<span style="color:#f92672">)</span>
  <span style="color:#f92672">|</span> Parser.<span style="color:#a6e22e">Error</span> <span style="color:#f92672">-&gt;</span>
    assert_failure <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Syntax error: &#34;</span> <span style="color:#f92672">^</span> position lexbuf<span style="color:#f92672">)</span>

<span style="color:#66d9ef">let</span> parse filename ch <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> lexbuf <span style="color:#f92672">=</span> Lexing.from_channel ch <span style="color:#66d9ef">in</span>
  lexbuf<span style="color:#f92672">.</span>lex_curr_p <span style="color:#f92672">&lt;-</span> <span style="color:#f92672">{</span>
    lexbuf<span style="color:#f92672">.</span>lex_curr_p <span style="color:#66d9ef">with</span> pos_fname <span style="color:#f92672">=</span> Filename.basename filename
  <span style="color:#f92672">};</span>
  parse_with_error lexbuf
</code></pre></div><p>Here is the function that weâre going to call for each <code>.tig</code>
file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> run_parser filename <span style="color:#f92672">_</span> <span style="color:#f92672">=</span>
  In_channel.with_file filename <span style="color:#f92672">~</span>f<span style="color:#f92672">:(</span>parse filename<span style="color:#f92672">)</span>
</code></pre></div><p>Finally, the test suite is going to look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> suite <span style="color:#f92672">=</span>
  <span style="color:#e6db74">&#34;tiger programs&#34;</span> <span style="color:#f92672">&gt;:::</span>
  <span style="color:#66d9ef">let</span> tests_dir <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;../../../book&#34;</span> <span style="color:#f92672">^</span> Filename.dir_sep <span style="color:#f92672">^</span> <span style="color:#e6db74">&#34;testcases&#34;</span> <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> tests_path <span style="color:#f92672">=</span> Filename.<span style="color:#f92672">(</span>concat parent_dir_name tests_dir<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> tig_files <span style="color:#f92672">=</span> ls_rec tests_path <span style="color:#66d9ef">in</span>
  <span style="color:#f92672">(</span>List.map <span style="color:#f92672">~</span>f<span style="color:#f92672">:</span>
     <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> filename <span style="color:#f92672">-&gt;</span>
        Filename.basename filename <span style="color:#f92672">&gt;::</span> run_parser filename<span style="color:#f92672">)</span>
     tig_files<span style="color:#f92672">)</span>

<span style="color:#66d9ef">let</span> () <span style="color:#f92672">=</span>
  run_test_tt_main suite
</code></pre></div><p>The dune file for our test suite project will simply run the
<code>testsuite.exe</code> executable:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp">(executable
 (name testsuite)
 (libraries base core ch3 oUnit))

(alias
 (name runtest)
 (action (run <span style="color:#f92672">.</span>/testsuite.exe)))
</code></pre></div><p>Now itâll be much easier to work on the parser implementation.
Also this test suite might be useful to detect possible
regressions if we want to change the parser in the future.</p>
<h4 id="conclusion">
  Conclusion
  <a class="heading-link" href="#conclusion">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>Of course, I didnât come up with this grammar right away. I
spent almost a week implementing this parser. I started with a
simple parser for âstraightline programsâ and iterated on it
until it evolved to the fully functional Tiger-language grammar.
And it took some time for me to figure out how to resolve all
the shift-reduce conflicts.</p>
<p>Another cool feature of Menhir is its REPL, which might be
helpful for debugging. This is especially useful when you
already caught a parser error by running the test suite and now
you want to try constructing an invalid expression to check your
hypothesis. I used this kind of workflow a lot while working on
this grammar.</p>
<p>You can run the interpreter like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh">menhir --interpret --interpret-show-cst parser.mly
</code></pre></div><p>Now you can start typing expressions until you find something
that breaks your parser. Note that you canât use token aliases
inside this REPL.</p>
<p>For example, here is how you can test a function declaration:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">LET FUNCTION ID LPAREN ID COLON ID RPAREN COLON ID EQ IF ID EQ INT THEN INT ELSE INT TIMES ID LPAREN ID MINUS INT RPAREN IN ID LPAREN INT RPAREN END
</code></pre></div><p>Thatâs it for now. The full source code for this chapter <a href="https://github.com/vyorkin/tiger/blob/master/chapter3/lib/parser.mly">is
here</a>. Next time weâre going to work on the AST for our Tiger
language.</p>
<h3 id="making-of-tiger-4-abstract-syntax">
  <!-- raw HTML omitted -->DRAFT<!-- raw HTML omitted --> Making of Tiger #4, Abstract Syntax
  <a class="heading-link" href="#making-of-tiger-4-abstract-syntax">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<h4 id="intro">
  Intro
  <a class="heading-link" href="#intro">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<h3 id="making-of-tiger-5-semantic-analysis">
  <!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> Making of Tiger #5, Semantic Analysis
  <a class="heading-link" href="#making-of-tiger-5-semantic-analysis">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<h4 id="intro">
  Intro
  <a class="heading-link" href="#intro">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>I really enjoyed working through this chapter, but at the same
time implementing the type-checking phase was a bit more
difficult than working on AST, parser or lexer from the previous
chapters.</p>
<h3 id="making-of-tiger-6-stack-frames">
  <!-- raw HTML omitted -->DONE<!-- raw HTML omitted --> Making of Tiger #6, Stack frames
  <a class="heading-link" href="#making-of-tiger-6-stack-frames">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<h4 id="intro">
  Intro
  <a class="heading-link" href="#intro">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>In this post we&rsquo;re going to add support for stack frames.
Here I&rsquo;ve made some notes while reading the chapter 6 to make sure I
understand things clearly.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Stack</p>
<p>A stack is a region of memory that grows downward and shrinks
upward (like icicles). The top of the stack is it&rsquo;s <code>lowest</code>
memory address. We treat stack as a big array, with a
special register &ndash; the <strong>stack pointer (SP)</strong>.</p>
<p>The stack <strong>grows</strong> only at the entry to a function, by the
increment large enough to hold all the local variables for that
function. The stack <strong>shrinks</strong> at the exit from the function by
the same amount.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Stack frame (SF)</p>
<p>We need a stack frame abstraction because:</p>
<ul>
<li>Local variables are pushed/popped in large batches on function
entry/exit</li>
<li>When local variables created they are not always initialized
right away</li>
<li>After many variables have been pushed, we want to continue
accessing variables deep within the stack</li>
</ul>
<p>A stack frame consists of:</p>
<ul>
<li>Some of local variables (others are kept in CPU registers)</li>
<li>Return address (where control should return after completion
of the current function)</li>
<li><a href="#temporaries-and-labels">Temporaries</a> and saved registers</li>
<li>Outgoing/incoming arguments</li>
</ul>
<p>Another name for a stack frame is a function <strong>activation
record</strong>. Stack frame layout depends on the <a href="https://en.wikipedia.org/wiki/Instruction%5Fset%5Farchitecture">ISA</a> and the
programming language being compiled.</p>
<p>Here is a typical stack frame layout:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">:    :             (higher addresses)
:    :             previous frame
| i1 | [FP+8]      (2-nd argument)
| i2 | [FP+4]      (1-st argument)
| SL | [FP]        (static link)
-------------------------------------------------
| l1 | [FP-4]      (1-st local variable)
| l2 | [FP-8]      (2-nd local variable)
:    :
| lk | [FP-k*4]    (k-nd local variable)
| RA | [FP-k*4-k]  (return address)
:    :
| t1 |             (1-st temp) temporaries and
| t2 |             (2-nd temp) saved registers
:    :
| o1 |             (1-st outgoing arg) outgoing
| o2 |             (2-nd outgoing arg) arguments
:    :
| SP | [FP-?]      (current stack pointer)
-------------------------------------------------
:    :             next frame
:    :             (lower addresses)
</code></pre></div></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Stack pointer (SP)</p>
<p>Always points to the top of the stack (lowest memory address in
a stack).</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Frame pointer (FP)</p>
<p>A term we use for convenience.</p>
<p>On entry to some function <code>f</code> we allocate a new stack frame (SF) by
subtracting the frame size from the SP and the old FP is saved
in the stack frame (SF).</p>
<p>Basically, if the frame size is fixed: <code>FP = SP + size(SF)</code>.</p>
<p>On function <strong>enter</strong>:</p>
<ul>
<li><code>SF[0...k] = V[0...k]</code> (put local variables in SF)</li>
<li><code>SF[k + 1] = FP</code> (save the current FP in SF)</li>
<li><code>FP = SP</code> (old SP becomes the current FP)</li>
</ul>
<p>On function <strong>exit</strong>:</p>
<ul>
<li><code>SP = FP</code> (copy FP back to SP)</li>
<li><code>FP = SF[k + 1]</code> (fetch back the saved FP)</li>
</ul>
<p>The size of stack frame (SF) is not known until quite late in the compilation
process, but we want to know the offsets of function arguments
and local variables much earlier. We put args and locals right
near the FP at offsets that are known early (<a href="#temporaries-and-labels">temporaries</a> and
saved registers are known later).</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Registers</p>
<p>We want to use CPU registers as much as possible to make
compiled programs run faster. Also we have a limited set of
registers available and many functions that use them. We must be
able to save and restore them (to/from a stack frame).</p>
<p>We say that a register is <strong>caller-save</strong> if the caller must save
and restore it, otherwhise it is <strong>callee-save</strong>. Which registers
are preserved depends on the machine architecture.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Parameters and returns addresses</p>
<p>In the early days (in 70&rsquo;s) on most machines function arguments
and return addresses were always passed on the stack. On modern
machines, for efficiency (to avoid high memory traffic), the
first several arguments, result and return address are passed in
registers. The rest args are passed in memory.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Why and how usage of registers helps</p>
<p>Suppose <code>f(a, b, c)</code> calls <code>g(x, y, z)</code>.</p>
<p>The <code>f</code> receives its args in registers \( r_1, r_2 \) and \( r_3
\), but it must pass the args <code>x</code>, <code>y</code> and <code>z</code> in the same
registers \( r_1, r_2 \) and \( r_3 \). So the <code>f</code> should save
those registers to its stack frame before calling <code>g</code> and we&rsquo;re back
to the memory traffic problem.</p>
<p>So how the usage of registers saved any time?</p>
<ol>
<li><strong>Leaf</strong> procedures &ndash; those that don&rsquo;t call other procedures.
The most procedures called are leafs which need not write
their incoming args to memory. And often they don&rsquo;t need to
allocatie a stack frame at all.</li>
<li>Interprocedural <a href="https://en.wikipedia.org/wiki/Register%5Fallocation">register allocation</a>. A technique used by some
optimizing compilers to analyze all the functions in an
entire program at once and assign them different registers in
which to receive parameters and hold local variables.</li>
<li>Sometimes <code>f</code> doesn&rsquo;t need its args anymore by the time it
calls <code>g</code>, so it can just overwrite corresponding registers.</li>
<li><a href="https://en.wikipedia.org/wiki/Register%5Fwindow">Register windows</a> available on some architectures. Each
function can allocate a fresh set of registers without memory
traffic.</li>
</ol>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>How incoming parameters are passed</p>
<p>The first <code>k</code> args \( a_1, \dots, a_k \) are passed in registers and
the rest \( a_{k+1} ,\dots, a_n \) are placed at the end of the
callers own frame.</p>
<p>If the callee needed to write any of these arguments
(including those passed in registers) to memory, it would write
them to the very beginning of its own stack frame.</p>
<p>For simplicity we&rsquo;ll assume that by default everything is passed
and kept in registers, except for cases when:</p>
<ul>
<li>variable is passed by reference</li>
<li>variable is accessed by a nested function</li>
<li>variable is too big to fit into a single register</li>
<li>array variables</li>
<li>register holding the variable is needed for some other purpose</li>
<li>there are many local variables and temporary values that they
won&rsquo;t all fit in registers</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Escaping variables</p>
<p>Variable <strong>escapes</strong> if:</p>
<ul>
<li>It is passed by reference</li>
<li>It is accessed from a nested function</li>
<li>Its address is taken (not applicable for Tiger)</li>
</ul>
<p>But when the compiler sees a formal parameter or local variable
for the first time it doesn&rsquo;t yet know whether it escapes and
how many registers the calculation will require.</p>
<p>So we must assign some provisional locations (see the
<code>alloc_local</code> function) to all formals and locals, and decide
later which of them should really go in registers.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Static link (SL)</p>
<ul>
<li><strong>Block structure</strong> &ndash; a feature that allow the inner functions
use variables declared in outer functions</li>
<li><strong>Static link (SL)</strong> &ndash; a pointer to the function statically
enclosing the current one</li>
</ul>
<p>Static links are stored in stack frames.</p>
<p>Example of program with nested functions in Tiger.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-F90" data-lang="F90"><span style="color:#66d9ef">type </span>tree <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">{</span>
  key: string,
  left: tree,
  right: tree
<span style="color:#960050;background-color:#1e0010">}</span>

<span style="color:#66d9ef">function </span>prettyprint(tree: tree) : string <span style="color:#f92672">=</span>
  let
    var output :<span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>

    <span style="color:#66d9ef">function write</span>(s: string) <span style="color:#f92672">=</span>
      output :<span style="color:#f92672">=</span> concat(output, s)

    <span style="color:#66d9ef">function </span>show(n: int, t: tree) <span style="color:#f92672">=</span>       <span style="color:#f92672">&lt;---</span> [<span style="color:#ae81ff">2</span>]
      let
        <span style="color:#66d9ef">function </span>indent(s: string) <span style="color:#f92672">=</span> (
          for i :<span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> to n <span style="color:#66d9ef">do</span>               <span style="color:#f92672">&lt;---</span> [<span style="color:#ae81ff">5</span>]
             <span style="color:#66d9ef">write</span>(<span style="color:#e6db74">&#34; &#34;</span>);
             output :<span style="color:#f92672">=</span> concat(output, s);
             <span style="color:#66d9ef">write</span>(<span style="color:#e6db74">&#34;\n&#34;</span>)
        )
      in
        <span style="color:#66d9ef">if </span>t <span style="color:#f92672">=</span> nil
        <span style="color:#66d9ef">then </span>ident(<span style="color:#e6db74">&#34;.&#34;</span>)                    <span style="color:#f92672">&lt;---</span> [<span style="color:#ae81ff">3</span>]
        <span style="color:#66d9ef">else</span> (
          indent(t.key);
          show(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, t.left);             <span style="color:#f92672">&lt;---</span> [<span style="color:#ae81ff">4</span>]
          show(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, t.right)
        )
      <span style="color:#66d9ef">end
</span><span style="color:#66d9ef">  </span>in
    show(<span style="color:#ae81ff">0</span>, tree);                         <span style="color:#f92672">&lt;---</span> [<span style="color:#ae81ff">1</span>]
    output
  <span style="color:#66d9ef">end</span>
</code></pre></div><ul>
<li><strong>1</strong>: <code>prettyprint</code> calls <code>show</code>, passing <code>prettyprint</code>&rsquo;s own
frame pointer (FP) as <code>show</code>&rsquo;s static link (SL)</li>
<li><strong>2</strong>: <code>show</code> stores its static link (SL) into its own stack frame</li>
<li><strong>3</strong>: <code>show</code> calls <code>indent</code>, passing its own frame pointer (FP) as <code>indent</code>&rsquo;s
SL</li>
<li><strong>4</strong>: <code>show</code> calls <code>show</code>, passing its own static link as
SL</li>
<li><strong>5</strong>: <code>indent</code> uses the value <code>n</code> from <code>show</code>&rsquo;s frame, it can
find <code>n</code> by using the SL (which points at the stack frame of <code>show</code>)</li>
</ul>
<p>Each call requires a one or more fetches using static links to resolve
variables declared in outer functions.</p>
</li>
</ul>
<h4 id="interface">
  Interface
  <a class="heading-link" href="#interface">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Stack frame and calling conventions</p>
<p>Every machine architecture might have a different standart stack
frame layout.</p>
<p>Suppose we have a call of the following function <code>g(x1, x2, x3)</code>
where the 1-st parameter escapes. Here is an example of how the
<code>Frame.mk g [true; false; false]</code> works on three different
architecture.</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<table>
<thead>
<tr>
<th>Architecture</th>
<th>Formals</th>
</tr>
</thead>
<tbody>
<tr>
<td>Pentium</td>
<td><code>[InFrame 8; InFrame 12; InFrame 16]</code></td>
</tr>
<tr>
<td>MIPS</td>
<td><code>[InFrame 0; InReg t157; InReg t158]</code></td>
</tr>
<tr>
<td>SPARC</td>
<td><code>[InFrame 8; InReg t157; InReg t158]</code></td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<hr>
<!-- raw HTML omitted -->
<table>
<thead>
<tr>
<th>Pentium</th>
<th>MIPS</th>
<th>SPARC</th>
</tr>
</thead>
<tbody>
<tr>
<td>\( SF_{SP+0} \leftarrow FP \)</td>
<td>\( SP \leftarrow SP-k \)</td>
<td>SAVE \(\ SP \), \( -k \), \(\ SP \)</td>
</tr>
<tr>
<td>\( FP \leftarrow SP \)</td>
<td>\( SF_{SP+k+0} \leftarrow r_2 \)</td>
<td>\( SF_{FP+68} \leftarrow i_0 \)</td>
</tr>
<tr>
<td>\( SP \leftarrow SP-k \)</td>
<td>\( t_{157} \leftarrow r_4 \)</td>
<td>\( t_{157} \leftarrow i_1 \)</td>
</tr>
<tr>
<td></td>
<td>\( t_{157} \leftarrow r_5 \)</td>
<td>\( t_{158 }\leftarrow i_2 \)</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<hr>
<!-- raw HTML omitted -->
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>\(SF\)</td>
<td>&ndash; stack frame memory region</td>
</tr>
<tr>
<td>\(k\)</td>
<td>&ndash; number of formal parameters</td>
</tr>
<tr>
<td>\(t\)</td>
<td>&ndash; temporary location</td>
</tr>
<tr>
<td>\(r_i\)</td>
<td>&ndash; MIPS registers</td>
</tr>
<tr>
<td>\(i_i\)</td>
<td>&ndash; SPARC registers</td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<p>Thats why we&rsquo;ll use an abstract interface for stack frames.</p>
<p>Most of PC&rsquo;s and laptops are based on the x86 and x64 ISA.
Mobile devices usually based on the ARM ISA.</p>
<ul>
<li><strong>x86</strong> &ndash; family of (32-bit) ISA based on the Intel 8086 and 8088 microprocessors</li>
<li><strong>x64</strong> &ndash; a 64-bit version of the x86 ISA supporting larger
amounts of virtual and physical memory + additional
general-purpose registers</li>
</ul>
<p><strong>x86</strong></p>
<ul>
<li>Has 8 general-purpose registers: <code>eax, ebx, ecx, edx, ebp, esp, esi, edi</code></li>
<li>32-bit (4-byte) <a href="https://en.wikipedia.org/wiki/Word%5F(computer%5Farchitecture)">words</a></li>
</ul>
<p><strong>x64</strong></p>
<ul>
<li>Has 16 general-purpose registers: <code>rax, rbx, rcx, rdx, rbp, rsp, rsi, rdi</code>, <code>r8 - r15</code></li>
<li>64-bit (8-byte) words</li>
</ul>
<p>Lets use the x64 ISA, there are 2 flavors of it:</p>
<ul>
<li>Microsoft x64</li>
<li>System V AMD64 (which I prefer)</li>
</ul>
<p>According to the System V AMD64 ABI, the first 6 integer
arguments are passed in left-to-right order in <code>rdi</code>, <code>rsi</code>, <code>rdx</code>,
<code>rcx</code>, <code>r8</code> and <code>r9</code> registers, respectively.</p>
<p>Arguments 5 and higher are passed in memory. They are pushed
onto the stack in reversed (right-to-left) order.</p>
<p>Helpful links:</p>
<ul>
<li><a href="http://refspecs.linuxfoundation.org/elf/x86%5F64-abi-0.99.pdf">System
V AMD64 ABI</a> (page 12)</li>
<li><a href="https://en.wikipedia.org/wiki/X86%5Fcalling%5Fconventions">Calling
conventions (Wikipedia)</a></li>
<li><a href="https://wiki.osdev.org/Calling%5FConventions">Calling
conventions (OS Dev)</a></li>
</ul>
<p>Here is our interface for a stack frame:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#75715e">(** Holds information about formal parameters and
</span><span style="color:#75715e">    local variables allocated in this frame *)</span>
<span style="color:#66d9ef">type</span> t <span style="color:#f92672">[@@</span>deriving show<span style="color:#f92672">]</span>

<span style="color:#75715e">(** Abstract location of a formal parameter (function argument) or
</span><span style="color:#75715e">    a local variable that may be placed in a frame or in a register *)</span>
<span style="color:#66d9ef">type</span> access <span style="color:#f92672">[@@</span>deriving show<span style="color:#f92672">]</span>

<span style="color:#75715e">(** Makes a new frame for a function with the
</span><span style="color:#75715e">    given label and formal parameters *)</span>
<span style="color:#66d9ef">val</span> mk <span style="color:#f92672">:</span> Temp.label <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">list</span> <span style="color:#f92672">-&gt;</span> t

<span style="color:#75715e">(** Extracts a list of accesses denoting
</span><span style="color:#75715e">    the locations where the formal parameters will be
</span><span style="color:#75715e">    kept at runtime, as seen from inside the callee *)</span>
<span style="color:#66d9ef">val</span> formals <span style="color:#f92672">:</span> t <span style="color:#f92672">-&gt;</span> access <span style="color:#66d9ef">list</span>

<span style="color:#75715e">(** Allocates a new local variable in the given frame or in a register.
</span><span style="color:#75715e">    The boolean argument specifies whether the new variable
</span><span style="color:#75715e">    escapes and needs to go in the frame.
</span><span style="color:#75715e">    Returns &#34;in-memory&#34; access with an offset from the frame pointer or
</span><span style="color:#75715e">    &#34;in-register&#34; access in case if it can be allocated in a register *)</span>
<span style="color:#66d9ef">val</span> alloc_local <span style="color:#f92672">:</span> t <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span> <span style="color:#f92672">-&gt;</span> access
</code></pre></div><p>To make a new frame for some function <code>f</code> we&rsquo;ll call <code>Frame.mk label formals</code>, where:</p>
<ul>
<li><code>label: Temp.label</code> &ndash; static memory address of the <code>f</code>
function (that is yet to be determined)</li>
<li><code>formals: bool list</code> &ndash; <code>true</code> for each parameter
that escapes and <code>false</code> for each that doesn&rsquo;t</li>
</ul>
<p>The stack frame should contain information about formal
parameters and local variables allocated:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  <span style="color:#75715e">(* label at which the function&#39;s machine code begins *)</span>
  label<span style="color:#f92672">:</span> Temp.label<span style="color:#f92672">;</span>
  <span style="color:#75715e">(* locations of all the formals *)</span>
  formals<span style="color:#f92672">:</span> access <span style="color:#66d9ef">list</span><span style="color:#f92672">;</span>
  <span style="color:#75715e">(* number of locals allocated so far *)</span>
  locals<span style="color:#f92672">:</span> <span style="color:#66d9ef">int</span> ref<span style="color:#f92672">;</span>
  <span style="color:#75715e">(* instructions required to implement the &#34;view shift&#34; *)</span>
  instrs<span style="color:#f92672">:</span> Instruction.t <span style="color:#66d9ef">list</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span> <span style="color:#f92672">[@@</span>deriving show<span style="color:#f92672">]</span>
</code></pre></div><p>We don&rsquo;t want to implement the <a href="#view-shift">view shift</a> right now, so the
<code>Instruction.t</code> is defined like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">unit</span> <span style="color:#f92672">[@@</span>deriving show<span style="color:#f92672">]</span>
</code></pre></div></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>ABI</p>
<p>Lets add some constants for System V ADM64 ABI to the <code>Frame</code>
module. We&rsquo;ll need them later.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#75715e">(* word size in bytes *)</span>
<span style="color:#66d9ef">let</span> word_size <span style="color:#f92672">=</span> 64 <span style="color:#f92672">/</span> 8 <span style="color:#75715e">(* = 8 bytes *)</span>

<span style="color:#75715e">(* special registers *)</span>
<span style="color:#66d9ef">let</span> fp <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;rbp&#34;</span> <span style="color:#75715e">(* frame pointer *)</span>
<span style="color:#66d9ef">let</span> sp <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;rsp&#34;</span> <span style="color:#75715e">(* stack pointer *)</span>

<span style="color:#75715e">(* x64 &#34;parameter&#34;-registers *)</span>
<span style="color:#66d9ef">let</span> rdi <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;rdi&#34;</span>
<span style="color:#66d9ef">let</span> rsi <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;rsi&#34;</span>
<span style="color:#66d9ef">let</span> rdx <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;rdx&#34;</span>
<span style="color:#66d9ef">let</span> rcx <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;rcx&#34;</span>
<span style="color:#66d9ef">let</span>	r8  <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;r8&#34;</span>
<span style="color:#66d9ef">let</span> r9  <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;r9&#34;</span>
<span style="color:#66d9ef">let</span> arg_regs <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>rdi<span style="color:#f92672">;</span> rsi<span style="color:#f92672">;</span> rdx<span style="color:#f92672">;</span> r8<span style="color:#f92672">;</span> r9<span style="color:#f92672">]</span>

<span style="color:#75715e">(* other x64 registers *)</span>
<span style="color:#66d9ef">let</span> rbx <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;rbx&#34;</span>
<span style="color:#66d9ef">let</span> r10 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;r10&#34;</span>
<span style="color:#66d9ef">let</span> r11 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;r11&#34;</span>
<span style="color:#66d9ef">let</span> r12 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;r12&#34;</span>
<span style="color:#66d9ef">let</span> r13 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;r13&#34;</span>
<span style="color:#66d9ef">let</span> r14 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;r14&#34;</span>
<span style="color:#66d9ef">let</span> r15 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;r15&#34;</span>

<span style="color:#75715e">(* registers that are preserved by the caller *)</span>
<span style="color:#66d9ef">let</span> caller_regs <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>r10<span style="color:#f92672">;</span> r11<span style="color:#f92672">]</span>

<span style="color:#75715e">(* registers that are preserved by the callee *)</span>
<span style="color:#66d9ef">let</span> callee_regs <span style="color:#f92672">=</span> <span style="color:#f92672">[</span>rbx<span style="color:#f92672">;</span> r12<span style="color:#f92672">;</span> r13<span style="color:#f92672">;</span> r14<span style="color:#f92672">;</span> r15<span style="color:#f92672">]</span>
</code></pre></div></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Access</p>
<p>The <code>access</code> data type describes location of a formal parameter
or a local variable that may be placed in a frame or in a
register:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">type</span> access <span style="color:#f92672">=</span>
   <span style="color:#75715e">(* memory location at the specific offset from the frame pointer *)</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">InFrame</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">int</span>
  <span style="color:#75715e">(* register location *)</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">InReg</span> <span style="color:#66d9ef">of</span> Temp.t
  <span style="color:#f92672">[@@</span>deriving show<span style="color:#f92672">]</span>
</code></pre></div><p>The rest of the <code>Frame</code> module implementation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#75715e">(* creates a new location for a formal parameter or
</span><span style="color:#75715e">   a local variable, given its index and [esc] flag *)</span>
<span style="color:#66d9ef">let</span> mk_access i <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>
  <span style="color:#f92672">|</span> true <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">InFrame</span> <span style="color:#f92672">((</span>i <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">*</span> <span style="color:#f92672">(-</span>word_size<span style="color:#f92672">))</span> <span style="color:#75715e">(* escapes - alloc in frame *)</span>
  <span style="color:#f92672">|</span> false <span style="color:#f92672">-&gt;</span> <span style="color:#a6e22e">InReg</span> <span style="color:#f92672">(</span>Temp.mk ()<span style="color:#f92672">)</span> <span style="color:#75715e">(* doesn&#39;t escape - use temp (register) *)</span>

<span style="color:#75715e">(* makes a new stack frame *)</span>
<span style="color:#66d9ef">let</span> mk label formals <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> formals <span style="color:#f92672">=</span> List.mapi mk_access formals <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> locals <span style="color:#f92672">=</span> ref 0 <span style="color:#66d9ef">in</span>
  <span style="color:#75715e">(* don&#39;t know yet what instructions we need,
</span><span style="color:#75715e">     so just leave it empty for now *)</span>
  <span style="color:#66d9ef">let</span> instrs <span style="color:#f92672">=</span> [] <span style="color:#66d9ef">in</span>
  <span style="color:#f92672">{</span> label<span style="color:#f92672">;</span> formals<span style="color:#f92672">;</span> locals<span style="color:#f92672">;</span> instrs <span style="color:#f92672">}</span>

<span style="color:#66d9ef">let</span> formals <span style="color:#f92672">{</span> formals<span style="color:#f92672">;</span> <span style="color:#f92672">_</span> <span style="color:#f92672">}</span> <span style="color:#f92672">=</span> formals

<span style="color:#75715e">(* local variables that do not escape can be allocated in a register,
</span><span style="color:#75715e">   escaping variables must be allocated in the frame *)</span>
<span style="color:#66d9ef">let</span> alloc_local <span style="color:#f92672">{</span> locals<span style="color:#f92672">;</span> <span style="color:#f92672">_</span> <span style="color:#f92672">}</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">function</span>
  <span style="color:#f92672">|</span> true <span style="color:#f92672">-&gt;</span>
    incr locals<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">let</span> offset <span style="color:#f92672">=</span> <span style="color:#f92672">(!</span>locals <span style="color:#f92672">+</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">*</span> <span style="color:#f92672">(-</span>word_size<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
    <span style="color:#a6e22e">InFrame</span> offset
  <span style="color:#f92672">|</span> false <span style="color:#f92672">-&gt;</span>
    <span style="color:#a6e22e">InReg</span> <span style="color:#f92672">(</span>Temp.mk ()<span style="color:#f92672">)</span>
</code></pre></div><p><code>alloc_local</code> allocates a new local variable in the given frame
or <a href="#temporaries-and-labels">in a register</a>. The boolean argument specifies whether the new
variable escapes and needs to go in the frame. Returns in-memory
access with an offset from the frame pointer.</p>
<p><code>alloc_local t true</code>
: â <code>InFrame -4</code></p>
<p><code>alloc_local t true</code>
: â <code>InFrame -8</code></p>
<p><code>alloc_local t false</code>
: â <code>InReg t1</code></p>
<p><code>alloc_local t false</code>
: â <code>InReg t2</code></p>
<p>A clever compiler might optimize the frame size by noticing when
two frame-resident variables could be allocated to the same
slot.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Temporaries and labels</p>
<p>We need a couple of more abstractions to represent a
&ldquo;not known yet&rdquo; register and machine-language locations:</p>
<ul>
<li><strong>Temporary</strong> &ndash; an abstract name for a value that is
temporarily held in some register</li>
<li><strong>Label</strong> (just like label in assembly language) &ndash; an abstract
name for a static machine-language location whose exact
address is yet to be determined</li>
</ul>
<p>The <code>Temp</code> module manages these two distinct sets of names:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#75715e">(** Abstract name for a local variable that
</span><span style="color:#75715e">    is temporarily held in a register *)</span>
<span style="color:#66d9ef">type</span> t <span style="color:#f92672">[@@</span>deriving show<span style="color:#f92672">]</span>

<span style="color:#75715e">(** Abstract name for a static memory address that
</span><span style="color:#75715e">    is yet to be determined *)</span>
<span style="color:#66d9ef">type</span> label <span style="color:#f92672">[@@</span>deriving show<span style="color:#f92672">]</span>

<span style="color:#75715e">(** Returns a new temporary from an infinite set of temporaries *)</span>
<span style="color:#66d9ef">val</span> mk <span style="color:#f92672">:</span> <span style="color:#66d9ef">unit</span> <span style="color:#f92672">-&gt;</span> t

<span style="color:#75715e">(** Returns a new [label], whose assembly-language name is
</span><span style="color:#75715e">    the given string (if given), otherwise it is generated. *)</span>
<span style="color:#66d9ef">val</span> mk_label <span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> option <span style="color:#f92672">-&gt;</span> label
</code></pre></div><p>The implementation is trivial:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">S</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Symbol</span>

<span style="color:#66d9ef">type</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">[@@</span>deriving show<span style="color:#f92672">]</span>
<span style="color:#66d9ef">type</span> label <span style="color:#f92672">=</span> Symbol.t <span style="color:#f92672">[@@</span>deriving show<span style="color:#f92672">]</span>

<span style="color:#66d9ef">let</span> mk <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> idx <span style="color:#f92672">=</span> ref <span style="color:#f92672">(-</span>1<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">fun</span> () <span style="color:#f92672">-&gt;</span>
    incr idx<span style="color:#f92672">;</span>
    <span style="color:#f92672">!</span>idx

<span style="color:#66d9ef">let</span> mk_label name <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> idx <span style="color:#f92672">=</span> ref <span style="color:#f92672">(-</span>1<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">match</span> name <span style="color:#66d9ef">with</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Some</span> s <span style="color:#f92672">-&gt;</span>
    S.symbol s
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">None</span> <span style="color:#f92672">-&gt;</span>
    incr idx<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">let</span> name <span style="color:#f92672">=</span> string_of_int <span style="color:#f92672">!</span>idx <span style="color:#66d9ef">in</span>
    S.symbol name
</code></pre></div></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>View shift</p>
<p>Function arguments are seen differently by the caller and the
callee. In the book this is referred to as the view shift. For
example, a caller my put a parameter into register \(r_6\), but
the callee may want to access it from register \(r_9\). We want
to handle this view shift in the <code>Frame</code> module.</p>
<p>For each formal parameter we should calculate:</p>
<ul>
<li>How it will be seen by callee (in a register, or in a frame
location)</li>
<li>What instructions are required to implement this view shift</li>
</ul>
<p>To keep things simple, we are not going to implement this right
now.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Static links</p>
<p>The <code>Frame</code> module should not know anything about <a href="#static-link--sl">static links</a>,
because we want it be independent of any specific source
language being compiled. We&rsquo;ll use <a href="#translate-module">Translate module</a> to manage
static links.</p>
<p>The static link (which is a pointer to the enclosing function)
is passed to a function in a register and stored into the frame,
just like any other escaping formal parameter. So we will treat
it as one by adding another <code>true</code> value at the front the list
of booleans representing formal parameters. It means that for
some function <code>f(x,y)</code> (assuming neigher <code>x</code> nor <code>y</code> escapes)
we&rsquo;ll have the following list:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#f92672">[</span>true<span style="color:#f92672">;</span> false<span style="color:#f92672">;</span> false<span style="color:#f92672">]</span>
</code></pre></div><p>Notice the extra <code>true</code> at the beginning.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Translate module</p>
<p>The <code>Translate</code> module handles the notion of nested scopes (via
static links), providing the interface to the <code>Semant</code> module.</p>
<p>We separate <code>Semant</code> from <code>Translate</code> module to avoid a huge,
unweildy module that does both: type checking and semantic
translation.</p>
<p>Ok, I think at this point we are ready to write some initial
implementation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">type</span> expr <span style="color:#f92672">=</span> <span style="color:#66d9ef">unit</span>

<span style="color:#75715e">(** Represents a nesting level *)</span>
<span style="color:#66d9ef">type</span> level

<span style="color:#75715e">(** Describes a way to access a formal parameter or a local variable.
</span><span style="color:#75715e">    Basically, it is just a [Frame.access] plus a nesting [level] *)</span>
<span style="color:#66d9ef">type</span> access <span style="color:#f92672">=</span> level <span style="color:#f92672">*</span> Frame.access

<span style="color:#75715e">(** Outermost level at which all
</span><span style="color:#75715e">    top-level functions and variables are declared *)</span>
<span style="color:#66d9ef">val</span> outermost <span style="color:#f92672">:</span> level

<span style="color:#75715e">(** Creates a new &#34;nesting level&#34; for a function *)</span>
<span style="color:#66d9ef">val</span> mk <span style="color:#f92672">:</span> level option <span style="color:#f92672">-&gt;</span> Temp.label <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">list</span> <span style="color:#f92672">-&gt;</span> level

<span style="color:#75715e">(** Extracts a list of accesses *)</span>
<span style="color:#66d9ef">val</span> formals <span style="color:#f92672">:</span> level <span style="color:#f92672">-&gt;</span> access <span style="color:#66d9ef">list</span>

<span style="color:#75715e">(** Creates an [access] at the given [level].
</span><span style="color:#75715e">    The argument [bool] specifies whether the variable escapes *)</span>
<span style="color:#66d9ef">val</span> alloc_local <span style="color:#f92672">:</span> level <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">bool</span> <span style="color:#f92672">-&gt;</span> access
</code></pre></div><p>We don&rsquo;t know yet what the <code>expr</code> will be, thats why it is a
type alias for <code>unit</code>. And here is the basic implementation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">type</span> expr <span style="color:#f92672">=</span> <span style="color:#66d9ef">unit</span> <span style="color:#f92672">[@@</span>deriving show<span style="color:#f92672">]</span>

<span style="color:#66d9ef">type</span> level <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  parent<span style="color:#f92672">:</span> level option<span style="color:#f92672">;</span>
  frame<span style="color:#f92672">:</span> Frame.t
<span style="color:#f92672">}</span> <span style="color:#f92672">[@@</span>deriving show<span style="color:#f92672">]</span>

<span style="color:#66d9ef">type</span> access <span style="color:#f92672">=</span> level <span style="color:#f92672">*</span> Frame.access

<span style="color:#66d9ef">let</span> outermost <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> label <span style="color:#f92672">=</span> Temp.mk_label <span style="color:#a6e22e">None</span> <span style="color:#66d9ef">in</span>
  <span style="color:#f92672">{</span> parent <span style="color:#f92672">=</span> <span style="color:#a6e22e">None</span><span style="color:#f92672">;</span>
    frame <span style="color:#f92672">=</span> Frame.mk label []<span style="color:#f92672">;</span>
  <span style="color:#f92672">}</span>

<span style="color:#66d9ef">let</span> mk parent label formals <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> formals <span style="color:#f92672">=</span> true <span style="color:#f92672">::</span> formals <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> frame <span style="color:#f92672">=</span> Frame.mk label formals <span style="color:#66d9ef">in</span>
  <span style="color:#f92672">{</span> parent<span style="color:#f92672">;</span> frame <span style="color:#f92672">}</span>

<span style="color:#75715e">(* Returns formals (excluding the static link) *)</span>
<span style="color:#66d9ef">let</span> formals lev <span style="color:#f92672">=</span>
  <span style="color:#75715e">(* exclude the SL *)</span>
  <span style="color:#66d9ef">let</span> args <span style="color:#f92672">=</span> List.tl <span style="color:#f92672">(</span>Frame.formals lev<span style="color:#f92672">.</span>frame<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
  List.map <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> access <span style="color:#f92672">-&gt;</span> lev<span style="color:#f92672">,</span> access<span style="color:#f92672">)</span> args

<span style="color:#66d9ef">let</span> alloc_local lev esc <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> access <span style="color:#f92672">=</span> Frame.alloc_local lev<span style="color:#f92672">.</span>frame esc <span style="color:#66d9ef">in</span>
  lev<span style="color:#f92672">,</span> access
</code></pre></div><p>Notice the <code>formals = true :: formals</code> in the <code>mk</code> function, it
is there to represent a static link.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Env</p>
<p>We must keep the <code>Translate.level</code> along with the <code>Temp.label</code>
in the <code>FunEntry</code>. Also we need to update the <code>VarEntry</code> to
include the <code>Translate.access</code>.</p>
<p>Here is how our updated <code>Env</code> module looks like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">module</span> <span style="color:#a6e22e">T</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">Type</span>
<span style="color:#66d9ef">module</span> <span style="color:#a6e22e">Table</span> <span style="color:#f92672">=</span> Symbol.<span style="color:#a6e22e">Table</span>

<span style="color:#66d9ef">type</span> access

<span style="color:#75715e">(** Variable entry *)</span>
<span style="color:#66d9ef">type</span> var_entry <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  access<span style="color:#f92672">:</span> Translate.access<span style="color:#f92672">;</span> <span style="color:#75715e">(** Describes how to access the variable **)</span>
  ty<span style="color:#f92672">:</span> T.t <span style="color:#75715e">(** Type of the variable *)</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">(** Function entry *)</span>
<span style="color:#66d9ef">type</span> fun_entry <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>
  level<span style="color:#f92672">:</span> Translate.level<span style="color:#f92672">;</span> <span style="color:#75715e">(** Nesting level *)</span>
  label<span style="color:#f92672">:</span> Temp.label<span style="color:#f92672">;</span> <span style="color:#75715e">(** Label of the machine-code entry point *)</span>
  formals<span style="color:#f92672">:</span> T.t <span style="color:#66d9ef">list</span><span style="color:#f92672">;</span> <span style="color:#75715e">(** Types of the formal parameters *)</span>
  result<span style="color:#f92672">:</span> T.t <span style="color:#75715e">(** Type of the result returned by the function **)</span>
<span style="color:#f92672">}</span>

<span style="color:#75715e">(** Term-level entry *)</span>
<span style="color:#66d9ef">type</span> entry <span style="color:#f92672">=</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">VarEntry</span> <span style="color:#66d9ef">of</span> var_entry
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">FunEntry</span> <span style="color:#66d9ef">of</span> fun_entry

<span style="color:#75715e">(** Contains bindings for predefined functions *)</span>
<span style="color:#66d9ef">val</span> base_venv <span style="color:#f92672">:</span> entry Table.t

<span style="color:#75715e">(** Predefined types *)</span>
<span style="color:#66d9ef">val</span> base_tenv <span style="color:#f92672">:</span> T.t Table.t
</code></pre></div></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Escapes</p>
<p>To calculate which variables should be stored in registers and
which should be allocated in the frame we&rsquo;ll have a special
module named <code>Escape</code>.</p>
<p>Here its interface in OCaml:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#75715e">(** Depth (nesting level) of the function that
</span><span style="color:#75715e">    contains the variable declaration *)</span>
<span style="color:#66d9ef">type</span> depth

<span style="color:#75715e">(** Environment that maps variables to pairs of depth and
</span><span style="color:#75715e">    a reference to a boolean flag indicating if a
</span><span style="color:#75715e">    particular variable escapes *)</span>
<span style="color:#66d9ef">type</span> env <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>depth <span style="color:#f92672">*</span> <span style="color:#66d9ef">bool</span> ref<span style="color:#f92672">)</span> Symbol.Table.t

<span style="color:#75715e">(** Looks for escaping variables and records this
</span><span style="color:#75715e">    info in the [escape] fields of the abstract syntax *)</span>
<span style="color:#66d9ef">val</span> traverse_prog <span style="color:#f92672">:</span> Syntax.expr <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">unit</span>
</code></pre></div><p>The <code>traverse_prog</code> function is going to traverse the entire AST
looking for escaping uses of every variable. Also, we&rsquo;ll have a
separate environment <code>env</code> to track &ldquo;escaping&rdquo; of variables.</p>
<p>Whenever a variable or formal-parameter declaration \(a\) is
found at static function-nesting depth \(d\) then a new binding
<code>(d, ref false)</code> is entered into the environment <code>env</code>. This new
environment is used in processing expressions within the scope
of the variable. Then whenever this var or formal-parameter
\(a\) is used at depth \(\gt d\) (which means that it escapes),
then our &ldquo;escape ref&rdquo; is set to <code>true</code> in the environment.</p>
<p>This should take place before semantic analysis, because the
<code>Semant</code> module needs to know about escaping variables to do
it&rsquo;s work.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>Semant</p>
<p>Now lets go and update our <code>Semant</code> module.</p>
<p>I won&rsquo;t paste the whole implementation, the code is <a href="https://github.com/vyorkin/tiger/blob/master/chapter6/lib/semant.ml">here</a>.</p>
</li>
</ul>
<h4 id="summary">
  Summary
  <a class="heading-link" href="#summary">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<h2 id="haskell">
  Haskell
  <a class="heading-link" href="#haskell">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<h3 id="a-week-of-liquid-haskell">
  <!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> A week of Liquid Haskell
  <a class="heading-link" href="#a-week-of-liquid-haskell">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>In this post I&rsquo;ll share my experience of playing around with Liquid
Haskell for about a week.</p>
<h3 id="building-a-toy-ethereum-like-vm-in-haskell">
  <!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> Building a toy Ethereum-like VM in Haskell
  <a class="heading-link" href="#building-a-toy-ethereum-like-vm-in-haskell">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<h3 id="writing-a-simple-trading-bot-in-haskell">
  <!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> Writing a simple trading bot in Haskell
  <a class="heading-link" href="#writing-a-simple-trading-bot-in-haskell">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Some time ago I was interested in trading blah blah.</p>
<h3 id="notes-on-parallel-and-concurrent-programming-in-haskell">
  <!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> Notes on parallel &amp; concurrent programming in Haskell
  <a class="heading-link" href="#notes-on-parallel-and-concurrent-programming-in-haskell">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>\begin{equation}
\label{eq:1}
C = W\log_{2} (1+\mathrm{SNR})
\end{equation}</p>
<p>See: <a href="http://www.jmilne.org/not/Mamscd.pdf">http://www.jmilne.org/not/Mamscd.pdf</a></p>
<p>\(\require{AMScd}\)</p>
<p>\begin{CD}
K(X) @&gt;{ch}&raquo; H(X;\mathbb Q);\\<br>
@VVV @VVV \\<br>
K(Y) @&gt;{ch}&raquo; H(Y;\mathbb Q);
\end{CD}</p>
<h2 id="ocaml">
  OCaml
  <a class="heading-link" href="#ocaml">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<h3 id="instrumenting-and-profiling-ocaml-programs">
  <!-- raw HTML omitted -->DRAFT<!-- raw HTML omitted --> Instrumenting and profiling OCaml programs
  <a class="heading-link" href="#instrumenting-and-profiling-ocaml-programs">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<h4 id="intro">
  Intro
  <a class="heading-link" href="#intro">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>Profiling is rather a large topic, but basically it allows us to
learn where the program spent its time and which functions
called which other functions during its execution. We use that
information to understand which pieces of our program are slower
than we expected.</p>
<p>Note the difference between profiling and benchmarking: we use
(micro-)benchmarking to estimate the cost of executing an
individual isolated piece of code, but we use profiling to
understand to properties of the whole program and possibly find
the hot spots.</p>
<p>Usually profiling is achieved by instrumenting either the
program source code or its binary executable. <strong>Instrumentation</strong>
means adding some extra code to collect the required information
(for example, where it was called from), which may cause
significant performance changes. This is why code should only
execute if some special flag is set (like <code>--profile</code> / <code>-p</code>).</p>
<p>Here are some known instrumentation types according to the
Wikipedia:</p>
<ul>
<li><strong>Manual</strong> â performed by the programmer by adding extra code to
measure execution costs</li>
<li><strong>Automatic source level</strong> â instrumentation added to the source
code by an automatic tool according to an instrumentation policy</li>
<li><strong>Interpreter instrumentation</strong> â interpreter debug option can
enable the collection of performance metrics as the
interpreter encounters each target statement</li>
<li><strong>Intermediate language</strong> â instrumentation added to assembly or
byte code</li>
<li><strong>Binary translation</strong> â the tool adds instrumentation to a
compiled executable</li>
<li><strong>Compiler assisted</strong></li>
<li><strong>Runtime instrumentation and injection</strong></li>
</ul>
<p>In this post we are going to take a closer look only at the
<strong>manual instrumentation</strong> and the <strong>interpreter instrumentation</strong>
in a context of the OCaml language and its ecosystem.</p>
<p>Typically profiling includes the following steps:</p>
<ul>
<li>Compiling (or just running) a program with profiling enabled</li>
<li>Executing it to generate profile data</li>
<li>Analyzing profile data to find bottlenecks</li>
</ul>
<p>We also may want to consider the output format. Generally these
forms may be available for the analysis:</p>
<ul>
<li><strong>Flat</strong> â Shows the average call times for each function and
how much time spent executing that function. Output is in the
form of a table, rows are usually sorted by decreasing time
spent and a number of calls, then alphabetically by name. <a href="https://sourceware.org/binutils/docs/gprof/Flat-Profile.html#Flat-Profile">Here</a>
is the more detailed description with an example</li>
<li><strong>Call-graph</strong> â Includes call-chains involved. Helps to find
functions that call other functions that spend unusual amounts
of time. Again, there is a good example in <a href="https://sourceware.org/binutils/docs/gprof/Call-Graph.html#Call-Graph">gprof docs</a></li>
<li><strong>Annotated source</strong> â Lists the program  source code annotated
with the number of times each line of the program was executed
(see an example in <a href="https://sourceware.org/binutils/docs/gprof/Annotated-Source.html#Annotated-Source">gprof docs</a>)</li>
<li><strong>Input-sensitive</strong> â Additionally shows how an applicationâs
performance scales as a function of its input</li>
</ul>
<h4 id="tools">
  Tools
  <a class="heading-link" href="#tools">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>There are several profiling tools available in OCaml ecosystem.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p><a href="https://github.com/janestreet/core%5Fprofiler">core_profiler</a></p>
<p>Library made by Jane Street that helps you profile programs and
estimate various costs. It belongs to the <code>Core</code> ecosystem,
which is good, but looks like it&rsquo;s poorly documented. Here is
the <a href="https://blog.janestreet.com/what-the-interns-have-wrought-rpc%5Fparallel-and-core%5Fprofiler/">post</a> describing this library and the <a href="https://ocaml.janestreet.com/ocaml-core/latest/doc/core%5Fprofiler/core%5Fprofiler.html">docs</a> (with usage
examples).</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p><a href="https://github.com/LexiFi/landmarks">landmarks</a></p>
<p>The tool made by <a href="http://www.lexifi.com/">LexiFi</a>. Personally I havenât tried it, but it
looks good.</p>
</li>
</ul>
<h4 id="references">
  References
  <a class="heading-link" href="#references">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>Statistical memory profiling:</p>
<ul>
<li><a href="http://ocaml.org/meetings/ocaml/2016/Jourdan-statistically%5Fprofiling%5Fmemory%5Fin%5FOCaml.pdf">http://ocaml.org/meetings/ocaml/2016/Jourdan-statistically%5Fprofiling%5Fmemory%5Fin%5FOCaml.pdf</a></li>
<li><a href="https://www.youtube.com/watch?v=wX4m8yqbuqE">https://www.youtube.com/watch?v=wX4m8yqbuqE</a></li>
</ul>
<h3 id="benchmarking-ocaml-code">
  <!-- raw HTML omitted -->DRAFT<!-- raw HTML omitted --> Benchmarking OCaml code
  <a class="heading-link" href="#benchmarking-ocaml-code">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>The most known tool for benchmarking OCaml code is the
<a href="https://github.com/janestreet/core%5Fbench">Core_bench</a> by Jane Street. There is a <a href="https://blog.janestreet.com/core%5Fbench-micro-benchmarking-for-ocaml/">post about it</a> in the Jane
Street tech blog that should help to get started, but it may be
a bit outdated.</p>
<p>Here is the basic usage:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Core</span>
<span style="color:#66d9ef">open</span> <span style="color:#a6e22e">Core_bench</span>

<span style="color:#66d9ef">module</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">=</span> Bench.<span style="color:#a6e22e">Test</span>

<span style="color:#66d9ef">let</span> benchmarks <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> Random.float 10<span style="color:#f92672">.</span>0 <span style="color:#66d9ef">in</span>
  <span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> Random.float 10<span style="color:#f92672">.</span>0 <span style="color:#66d9ef">in</span>
  <span style="color:#f92672">[</span> B.create <span style="color:#f92672">~</span>name<span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Float add&#34;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> () <span style="color:#f92672">-&gt;</span> ignore <span style="color:#f92672">(</span>x <span style="color:#f92672">+.</span> y<span style="color:#f92672">))</span>
  <span style="color:#f92672">;</span> B.create <span style="color:#f92672">~</span>name<span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Float mul&#34;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> () <span style="color:#f92672">-&gt;</span> ignore <span style="color:#f92672">(</span>x <span style="color:#f92672">*.</span> y<span style="color:#f92672">))</span>
  <span style="color:#f92672">;</span> B.create <span style="color:#f92672">~</span>name<span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;Float div&#34;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> () <span style="color:#f92672">-&gt;</span> ignore <span style="color:#f92672">(</span>x <span style="color:#f92672">/.</span> y<span style="color:#f92672">))</span>
  <span style="color:#f92672">]</span>

<span style="color:#66d9ef">let</span> () <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> cmd <span style="color:#f92672">=</span> Bench.make_command benchmarks <span style="color:#66d9ef">in</span>
  Command.run cmd
</code></pre></div><h3 id="Ð·Ð°Ð¼ÐµÑÐºÐ°-Ð¾-lwt">
  <!-- raw HTML omitted -->DONE<!-- raw HTML omitted --> ÐÐ°Ð¼ÐµÑÐºÐ° Ð¾ Lwt
  <a class="heading-link" href="#%d0%b7%d0%b0%d0%bc%d0%b5%d1%82%d0%ba%d0%b0-%d0%be-lwt">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<h4 id="ÑÑÐ¾-ÑÐ°ÐºÐ¾Ðµ-lwt">
  Ð§ÑÐ¾ ÑÐ°ÐºÐ¾Ðµ Lwt
  <a class="heading-link" href="#%d1%87%d1%82%d0%be-%d1%82%d0%b0%d0%ba%d0%be%d0%b5-lwt">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p><a href="https://github.com/ocsigen/lwt">Lwt</a> ÑÑÐ¾ Ð¾Ð´Ð½Ð° Ð¸Ð· Ð½Ð°Ð¸Ð±Ð¾Ð»ÐµÐµ Ð¿Ð¾Ð¿ÑÐ»ÑÑÐ½ÑÑ OCaml Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐº,
ÑÐ°Ð·ÑÐ°Ð±Ð°ÑÑÐ²Ð°ÐµÐ¼Ð°Ñ ÑÐ¾Ð¾Ð±ÑÐµÑÑÐ²Ð¾Ð¼. ÐÐ¾ ÑÑÑÐ¸ ÑÑÐ¾ Ð¿ÑÐ¾ÑÑÐ¾ ÑÐµÐ°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ
<a href="https://en.wikipedia.org/wiki/Cooperative%5Fmultitasking">ÐºÐ¾Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð²Ð½Ð¾Ð¹ Ð¼Ð½Ð¾Ð³Ð¾Ð·Ð°Ð´Ð°ÑÐ½Ð¾ÑÑÐ¸</a> (ÐºÐ°Ðº Ð°Ð»ÑÑÐµÑÐ½Ð°ÑÐ¸Ð²Ñ <a href="https://en.wikipedia.org/wiki/Preemption%5F(computing)">Ð²ÑÑÐµÑÐ½ÑÑÑÐµÐ¹
Ð¼Ð½Ð¾Ð³Ð¾Ð·Ð°Ð´Ð°ÑÐ½Ð¾ÑÑÐ¸</a>) Ð² OCaml Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ <a href="https://en.wikipedia.org/wiki/Futures%5Fand%5Fpromises">Promises</a>.</p>
<p><em>Ð Ð´Ð°Ð»ÑÐ½ÐµÐ¹ÑÐµÐ¼ Ñ Ð±ÑÐ´Ñ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÑÐ»Ð¾Ð²Ð° âÐ¿Ð¾ÑÐ¾Ðºâ Ð¸ Ð¿ÑÐ¾Ð¼Ð¸Ñ ÐºÐ°Ðº
Ð²Ð·Ð°Ð¸Ð¼Ð¾Ð·Ð°Ð¼ÐµÐ½ÑÐ¼ÑÐµ</em>.</p>
<h4 id="Ð²Ð¸Ð´Ñ-Ð¼Ð½Ð¾Ð³Ð¾Ð·Ð°Ð´Ð°ÑÐ½Ð¾ÑÑÐµÐ¹">
  ÐÐ¸Ð´Ñ âÐ¼Ð½Ð¾Ð³Ð¾Ð·Ð°Ð´Ð°ÑÐ½Ð¾ÑÑÐµÐ¹â
  <a class="heading-link" href="#%d0%b2%d0%b8%d0%b4%d1%8b-%d0%bc%d0%bd%d0%be%d0%b3%d0%be%d0%b7%d0%b0%d0%b4%d0%b0%d1%87%d0%bd%d0%be%d1%81%d1%82%d0%b5%d0%b9">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p><em>Ð­ÑÐ¾Ñ Ð¿Ð°ÑÐ°Ð³ÑÐ°Ñ Ð¼Ð¾Ð¶Ð½Ð¾ Ð¿ÑÐ¾Ð¿ÑÑÑÐ¸ÑÑ</em></p>
<p>ÐÑÐ»Ð¸ Ð² Ð´Ð²ÑÑ ÑÐ»Ð¾Ð²Ð°Ñ, ÑÐ¾ Ð²ÑÑÐµÑÐ½ÑÑÑÑÑ Ð¸ ÐºÐ¾Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð²Ð½ÑÑ
Ð¼Ð½Ð¾Ð³Ð¾Ð·Ð°Ð´Ð°ÑÐ½Ð¾ÑÑÑ Ð¼Ð¾Ð¶Ð½Ð¾ Ð¾Ð±ÑÑÑÐ½Ð¸ÑÑ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼:</p>
<ul>
<li>
<p><strong>ÐÑÑÐµÑÐ½ÑÑÑÐ°Ñ Ð¼Ð½Ð¾Ð³Ð¾Ð·Ð°Ð´Ð°ÑÐ½Ð¾ÑÑÑ</strong> Ð¾Ð·Ð½Ð°ÑÐ°ÐµÑ, ÑÑÐ¾ Ñ Ð½Ð°Ñ ÐµÑÑÑ Ð½ÐµÐºÐ¸Ð¹
Ð¿Ð»Ð°Ð½Ð¸ÑÐ¾Ð²ÑÐ¸Ðº, Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÑÑÐ¸Ð¹ ÑÐµÑÐµÐ½Ð¸Ñ Ð¾ ÑÐ¾Ð¼, ÐºÐ¾Ð³Ð´Ð° Ð±ÑÐ´ÐµÑ
Ð²ÑÐ¿Ð¾Ð»Ð½ÑÑÑÑÑ ÐºÐ°ÐºÐ¾Ð¹ Ð¿Ð¾ÑÐ¾Ðº, Ð¾Ð±ÑÑÐ½Ð¾ Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°Ñ Ð²Ð¾ Ð²Ð½Ð¸Ð¼Ð°Ð½Ð¸Ðµ Ð¿ÑÐ¸Ð¾ÑÐ¸ÑÐµÑ
Ð¿Ð¾ÑÐ¾ÐºÐ¾Ð² Ð¸ Ð²ÑÐ´ÐµÐ»ÑÑ Ð¸Ð¼ Ð½ÐµÐºÐ¸Ðµ ÐºÐ²Ð°Ð½ÑÑ Ð²ÑÐµÐ¼ÐµÐ½Ð¸. Ð­ÑÐ¾Ñ Ð²Ð¸Ð´
Ð¼Ð½Ð¾Ð³Ð¾Ð·Ð°Ð´Ð°ÑÐ½Ð¾ÑÑÐ¸ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÑÑÑ Ð² Ð±Ð¾Ð»ÑÑÐ¸Ð½ÑÑÐ²Ðµ ÑÐ¾Ð²ÑÐµÐ¼ÐµÐ½Ð½ÑÑ ÐÐ¡.</p>
</li>
<li>
<p><strong>ÐÐ¾Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð²Ð½Ð°Ñ Ð¼Ð½Ð¾Ð³Ð¾Ð·Ð°Ð´Ð°ÑÐ½Ð¾ÑÑÑ</strong> â Ð¿Ð»Ð°Ð½Ð¸ÑÐ¾Ð²ÑÐ¸Ðº Ð½Ðµ Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÐµÑ
ÑÐµÑÐµÐ½Ð¸Ðµ Ð¾ Ð¿ÐµÑÐµÐºÐ»ÑÑÐµÐ½Ð¸Ð¸ Ð¿Ð¾ÑÐ¾ÐºÐ¾Ð². ÐÐ¾ÑÐ¾Ðº Ð´Ð¾Ð»Ð¶ÐµÐ½ ÑÐ²Ð½Ð¾
ÑÐ¸Ð³Ð½Ð°Ð»Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð¾ ÑÐ¾Ð¼, ÑÑÐ¾ Ð¾Ð½ Ð³Ð¾ÑÐ¾Ð² Ð¿ÑÐµÑÐ²Ð°ÑÑÑÑ Ð¸ Ð¿ÑÐµÐ´Ð¾ÑÑÐ°Ð²Ð¸ÑÑ
Ð¿ÑÐ¾ÑÐµÑÑÐ¾ÑÐ½Ð¾Ðµ Ð²ÑÐµÐ¼Ñ Ð´ÑÑÐ³Ð¸Ð¼ Ð¿Ð¾ÑÐ¾ÐºÐ°Ð¼.</p>
</li>
</ul>
<h4 id="Ð°ÑÐ¸Ð½ÑÑÐ¾Ð½Ð½Ð¾Ðµ-Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ-Ñ-lwt-Ð¸-Ð¿ÑÐ¾Ð¼Ð¸ÑÑ">
  ÐÑÐ¸Ð½ÑÑÐ¾Ð½Ð½Ð¾Ðµ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ Ñ Lwt Ð¸ Ð¿ÑÐ¾Ð¼Ð¸ÑÑ
  <a class="heading-link" href="#%d0%b0%d1%81%d0%b8%d0%bd%d1%85%d1%80%d0%be%d0%bd%d0%bd%d0%be%d0%b5-%d0%bf%d1%80%d0%be%d0%b3%d1%80%d0%b0%d0%bc%d0%bc%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d1%81-lwt-%d0%b8-%d0%bf%d1%80%d0%be%d0%bc%d0%b8%d1%81%d1%8b">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>Lwt Ð¿ÑÐµÐ´Ð¾ÑÑÐ°Ð²Ð»ÑÐµÑ Ð½Ð°Ð¼ ÑÐ¸Ð¿ Ð´Ð°Ð½Ð½ÑÑ <code>'a Lwt.t</code>. ÐÐ¾Ð¶Ð½Ð¾ Ð¾ÑÐ½Ð¾ÑÐ¸ÑÑÑÑ Ðº
Ð½ÐµÐ¼Ñ, ÐºÐ°Ðº Ðº âÐ¿Ð¾ÑÐ¾ÐºÑâ. Ð­ÑÐ¾ Ð¾Ð±ÑÑÐ½ÑÐ¹ Ð¿ÑÐ¾Ð¼Ð¸Ñ, ÑÐ¾Ð´ÐµÑÐ¶Ð°ÑÐ¸Ð¹ Ð½ÐµÐºÐ¾ÑÐ¾ÑÐ¾Ðµ
Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ ÑÐ¸Ð¿Ð° <code>'a</code>, ÐºÐ¾ÑÐ¾ÑÐ¾Ðµ Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¾, Ð½Ð°Ð¿ÑÐ¸Ð¼ÐµÑ,
ÐºÐ¾Ð³Ð´Ð°-ÑÐ¾ Ð² Ð±ÑÐ´ÑÑÐµÐ¼, Ð½Ð¾ ÑÐ¾Ð»ÑÐºÐ¾ Ð¾Ð´Ð¸Ð½ ÑÐ°Ð·. Ð ÑÐµÑÐ¼Ð¸Ð½Ð°Ñ OCaml ÑÑÐ¾
Ð¿ÑÐ¾ÑÑÐ¾ <code>'a ref</code>, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð±ÑÐ´ÐµÑ Ð·Ð°Ð¿Ð¾Ð»Ð½ÐµÐ½ Ð¿Ð¾Ð·Ð¶Ðµ. ÐÐ·Ð½Ð°ÑÐ°Ð»ÑÐ½Ð¾
Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ Ð² Ð½ÑÐ¼ Ð½ÐµÑ Ð¸ Ð¿ÑÐ¾Ð¼Ð¸Ñ Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð² ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ð¸ <code>Sleep</code> (pending).
ÐÐ¾Ð³Ð´Ð° Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ðµ Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð¾ ÑÑÐ¿ÐµÑÐ½Ð¾, Lwt Ð¿Ð¾Ð¼ÐµÑÐ°ÐµÑ ÑÐµÐ·ÑÐ»ÑÑÐ°Ñ ÑÐ¸Ð¿Ð°
<code>'a</code> Ð² Ð½Ð°Ñ Ð¿ÑÐ¾Ð¼Ð¸Ñ Ð¸ ÐµÐ³Ð¾ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ðµ ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑÑ <code>Return</code> (resolved). Ð
ÑÐ»ÑÑÐ°Ðµ Ð¶Ðµ Ð½ÐµÑÐ´Ð°ÑÐ¸ ÐµÐ³Ð¾ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ðµ Ð¸Ð·Ð¼ÐµÐ½ÑÐµÑÑÑ Ð½Ð° <code>Fail</code> (rejected) Ð¸ Ð²
Ð½ÐµÐ³Ð¾ Ð¿Ð¾Ð¼ÐµÑÐ°ÐµÑÑÑ Ð¿ÑÐ¾Ð¸Ð·Ð¾ÑÐµÐ´ÑÐ°Ñ Ð¾ÑÐ¸Ð±ÐºÐ°.</p>
<!-- raw HTML omitted -->
<ul>
<li>
<p>API</p>
<p>ÐÐ¾Ñ ÐºÐ°Ðº Ð²ÑÐ³Ð»ÑÐ´Ð¸Ñ ÑÐ¸Ð¿, Ð¾Ð¿Ð¸ÑÑÐ²Ð°ÑÑÐ¸Ð¹ ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ñ:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">&#39;</span>a state <span style="color:#f92672">=</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Return</span> <span style="color:#66d9ef">of</span> <span style="color:#66d9ef">&#39;</span>a
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Fail</span> <span style="color:#66d9ef">of</span> exn
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">Sleep</span>
</code></pre></div><p>Lwt Ð¿ÑÐµÐ´Ð¾ÑÑÐ°Ð²Ð»ÑÐµÑ Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ Ð¿Ð¾Ð»ÐµÐ·Ð½ÑÑ Ñ-ÑÐ¸Ð¹:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">val</span> return <span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a Ltw.t
</code></pre></div><p>ÐÐ¾Ð½ÑÑÐ½Ð¾, ÑÑÐ¾ ÑÑÐ° Ñ-ÑÐ¸Ñ ÑÑÐ¸Ð²Ð¸Ð°Ð»ÑÐ½Ð¾ ÑÐ¿Ð°ÐºÐ¾Ð²ÑÐ²Ð°ÐµÑ ÑÐ¶Ðµ Ð¸Ð·Ð²ÐµÑÑÐ½Ð¾
Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ Ð² Ð¿ÑÐ¾Ð¼Ð¸Ñ. Ð¡Ð¾Ð¾ÑÐ²ÐµÑÑÑÐ²ÐµÐ½Ð½Ð¾, ÑÑÐ¾Ñ Ð¿ÑÐ¾Ð¼Ð¸Ñ ÑÑÐ°Ð·Ñ Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð²
ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ð¸ <code>Return</code> (resolved).</p>
<p>ÐÐ½Ð°ÑÐµÐ½Ð¸Ñ, ÑÐ¿Ð°ÐºÐ¾Ð²Ð°Ð½Ð½ÑÐµ Ð² <code>Lwt.t</code>, Ð½Ðµ Ð¼Ð¾Ð³ÑÑ Ð±ÑÑÑ Ð¿ÑÐ¾ÑÑÐ¾ Ð¸Ð·Ð²Ð»ÐµÑÐµÐ½Ñ
(Ñ.Ðº. Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ðµ Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ ÐµÑÑ Ð½Ðµ Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð¾). ÐÐ»Ñ ÑÑÐ¾Ð³Ð¾ Ð¼Ñ
Ð´Ð¾Ð»Ð¶Ð½Ñ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ð¾Ð¿ÐµÑÐ°ÑÐ¾Ñ <code>bind</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">val</span> <span style="color:#f92672">(&gt;&gt;=):</span> <span style="color:#66d9ef">&#39;</span>a Lwt.t <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">&#39;</span>a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b Lwt.t<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>b Lwt.t
</code></pre></div><p>Ð¢Ð°ÐºÐ°Ñ ÐºÐ¾Ð½ÑÑÑÑÐºÑÐ¸Ñ Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ Ð½Ð°Ð¼ Ð´ÐµÐ»Ð°ÑÑ ÐºÐ¾Ð¼Ð¿Ð¾Ð·Ð¸ÑÐ¸Ñ Ð¿ÑÐ¾Ð¼Ð¸ÑÐ¾Ð² Ð²
âÐ¼Ð¾Ð½Ð°Ð´Ð¸ÑÐµÑÐºÐ¾Ð¼â ÑÑÐ¸Ð»Ðµ.</p>
<p><code>f &gt;&gt;= g</code> ÑÐ¾Ð·Ð´Ð°ÑÑ Ð½Ð°Ð¼ Ð¿ÑÐ¾Ð¼Ð¸Ñ, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð¶Ð´ÑÑ Ð¿Ð¾ÐºÐ° Ð·Ð°Ð²ÐµÑÑÐ¸ÑÑÑ
âÐ¿Ð¾ÑÐ¾Ðºâ <code>f : 'a Lwt.t</code>, Ð¿Ð¾Ð»ÑÑÐ°ÐµÑ ÑÐµÐ·ÑÐ»ÑÑÐ°Ñ ÐµÐ³Ð¾ Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ð¹ (Ð½ÐµÐºÐ¸Ð¹
<code>x : 'a</code>) Ð¸ Ð¿ÐµÑÐµÐ´Ð°ÑÑ ÐµÐ³Ð¾ Ð² Ñ-ÑÐ¸Ñ <code>g : 'a -&gt; 'b Ltw.t</code>, ÐºÐ¾ÑÐ¾ÑÐ°Ñ
Ð·Ð°Ð¿ÑÑÐºÐ°ÐµÑ Ð¿Ð¾ÑÐ¾Ðº <code>'b Ltw.t</code>. ÐÑÐ»Ð¸ <code>f</code> Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð² ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ð¸
<strong>pending</strong>, ÑÐ¾ Ð¸ <code>f &gt;&gt;= g</code> Ð±ÑÐ´ÐµÑ Ð² ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ð¸ <code>pending</code>.
Ð¡Ð¾Ð¾ÑÐ²ÐµÑÑÑÐ²ÐµÐ½Ð½Ð¾, ÐµÑÐ»Ð¸ <code>f</code> Ð·Ð°Ð²ÐµÑÑÐ¸ÑÑÑ Ñ Ð¾ÑÐ¸Ð±ÐºÐ¾Ð¹, ÑÐ¾ Ð¸ <code>f &gt;&gt;= g</code>
Ð·Ð°Ð²ÐµÑÑÐ¸ÑÑÑ Ñ ÑÐ¾Ð¹ Ð¶Ðµ ÑÐ°Ð¼Ð¾Ð¹ Ð¾ÑÐ¸Ð±ÐºÐ¾Ð¹.</p>
<p>ÐÐµÑÐºÐ¾Ð»ÑÐºÐ¾ Ð´ÑÑÐ³Ð¸Ñ Ð¿Ð¾Ð»ÐµÐ·Ð½ÑÑ Ñ-ÑÐ¸Ð¹:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">val</span> join <span style="color:#f92672">:</span> <span style="color:#66d9ef">unit</span> Lwt.t <span style="color:#66d9ef">list</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">unit</span> Lwt.t
</code></pre></div><p><code>join</code> Ð¿Ð¾Ð»ÑÑÐ°ÐµÑ ÑÐ¿Ð¸ÑÐ¾Ðº Ð¿Ð¾ÑÐ¾ÐºÐ¾Ð² Ð¸ Ð¾Ð¶Ð¸Ð´Ð°ÐµÑ Ð¿Ð¾ÐºÐ° Ð¾Ð½Ð¸ Ð²ÑÐµ
Ð·Ð°Ð²ÐµÑÑÐ°ÑÑÑ. ÐÑÐ»Ð¸ ÑÐ¾ÑÑ Ð±Ñ Ð¾Ð´Ð¸Ð½ Ð¸Ð· Ð½Ð¸Ñ Ð·Ð°Ð²ÐµÑÑÐ¸ÑÑÑ Ñ Ð¾ÑÐ¸Ð±ÐºÐ¾Ð¹
(Ð¿ÐµÑÐµÐ¹Ð´ÑÑ Ð² ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ðµ rejected), ÑÐ¾ Ð¸ ÑÐµÐ·ÑÐ»ÑÑÐ¸ÑÑÑÑÐ¸Ð¹ Ð¿Ð¾ÑÐ¾Ðº
Ð·Ð°Ð²ÐµÑÑÐ¸ÑÑÑ Ñ ÑÐ¾Ð¹ Ð¶Ðµ Ð¾ÑÐ¸Ð±ÐºÐ¾Ð¹ (Ð¿Ð¾ÑÐ»Ðµ ÑÐ¾Ð³Ð¾, ÐºÐ°Ðº Ð²ÑÐµ Ð¾ÑÑÐ°Ð»ÑÐ½ÑÐµ
Ð¿Ð¾ÑÐ¾ÐºÐ¸ Ð·Ð°Ð²ÐµÑÑÐ°Ñ ÑÐ²Ð¾Ð¸ Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ñ).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">val</span> choose <span style="color:#f92672">:</span> <span style="color:#66d9ef">&#39;</span>a t <span style="color:#66d9ef">list</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">&#39;</span>a t
</code></pre></div><p><code>choose</code> Ð¶Ð´ÑÑ Ð¿Ð¾ÐºÐ° Ð²ÑÐ¿Ð¾Ð»Ð½Ð¸ÑÑÑ ÑÐ¾ÑÑ Ð±Ñ Ð¾Ð´Ð¸Ð½ Ð¿Ð¾ÑÐ¾Ðº. ÐÑÐ»Ð¸ ÑÐ°ÐºÐ¸Ñ
Ð¾ÐºÐ°Ð·Ð°Ð»Ð¾ÑÑ Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾, ÑÐ¾ Ð² ÐºÐ°ÑÐµÑÑÐ²Ðµ ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÐ° Ð²ÑÐ±Ð¸ÑÐ°ÐµÑÑÑ Ð¾Ð´Ð¸Ð½ Ð¸Ð·
Ð½Ð¸Ñ cÐ»ÑÑÐ°Ð¹Ð½ÑÐ¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼.</p>
<p>ÐÐ° ÑÐ°Ð¼Ð¾Ð¼ Ð´ÐµÐ»Ðµ Ð¸Ñ Ð¾Ð³ÑÐ¾Ð¼Ð½Ð¾Ðµ Ð¼Ð½Ð¾Ð¶ÐµÑÑÐ²Ð¾ Ð¸ Ð²ÑÐµ Ð¸Ñ Ð¼Ð¾Ð¶Ð½Ð¾ Ð½Ð°Ð¹ÑÐ¸ <a href="http://ocsigen.org/lwt/dev/api/Lwt%5Flist">ÑÑÑ</a>.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>PPX</p>
<p>Ð£ Ð½Ð°Ñ ÐµÑÑÑ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¹ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐµÑÐºÐ¸Ð¹ ÑÐ°ÑÐ°Ñ:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span><span style="color:#f92672">%</span>lwt i <span style="color:#f92672">=</span> f () <span style="color:#66d9ef">in</span>
<span style="color:#f92672">...</span>
</code></pre></div><p>Ð§ÑÐ¾ ÑÐºÐ²Ð¸Ð²Ð°Ð»ÐµÐ½ÑÐ½Ð¾ ÑÐ»ÐµÐ´ÑÑÑÐµÐ¼Ñ ÑÑÐ°Ð³Ð¼ÐµÐ½ÑÑ:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml">Lwt.bind <span style="color:#f92672">(</span>f ()<span style="color:#f92672">)</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">fun</span> i <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">...)</span>
</code></pre></div></li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>ÐÑÐ¸Ð¼ÐµÑÑ</p>
<p><em>Ð¡Ð»ÐµÐ´ÑÑÑÐ¸Ðµ Ð¿ÑÐ¸Ð¼ÐµÑÑ Ñ Ð²Ð·ÑÐ» Ð¸Ð· Ð¾ÑÐ¸ÑÐ¸Ð°Ð»ÑÐ½Ð¾Ð³Ð¾ ÑÑÑÐ¾ÑÐ¸Ð°Ð»Ð°</em></p>
<p>Ð§ÑÐµÐ½Ð¸Ðµ Ð¸Ð· STDIN Ð±ÐµÐ· Lwt, Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ¸ÑÑÐµÑÑÑ Ð¿Ð¾ÐºÐ° Ð½Ðµ
Ð¿Ð¾ÑÑÑÐ¿Ð¸Ñ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»ÑÑÐºÐ¸Ð¹ Ð²Ð²Ð¾Ð´:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> () <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> line <span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> Pervasives.read_line () <span style="color:#66d9ef">in</span>
  print_endline <span style="color:#e6db74">&#34;Now unblocked!&#34;</span><span style="color:#f92672">;</span>
  ignore line
</code></pre></div><p>Ð¡ Ð¿ÑÐ¾Ð¼Ð¸ÑÐ°Ð¼Ð¸ Lwt Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ðµ Ð¿ÑÐ¾Ð´Ð¾Ð»Ð¶Ð°ÐµÑÑÑ:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> () <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> line_promise <span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> Lwt.t <span style="color:#f92672">=</span> Lwt_io.<span style="color:#f92672">(</span>read_line stdin<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
  print_endline <span style="color:#e6db74">&#34;Execution just continues...&#34;</span><span style="color:#f92672">;</span>
  ignore line_promise
</code></pre></div><p>Ð Ð´Ð°Ð½Ð½Ð¾Ð¼ ÑÐ»ÑÑÐ°Ðµ, ÑÑÐ¾ Ð½Ðµ ÑÐ¾Ð²ÑÐµÐ¼ ÑÐ¾, ÑÑÐ¾ Ð½Ð°Ð¼ Ð½ÑÐ¶Ð½Ð¾, Ñ.Ðº. Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ð°
ÑÑÐ°Ð·Ñ Ð·Ð°Ð²ÐµÑÑÐ°ÐµÑ ÑÐ°Ð±Ð¾ÑÑ, ÑÐ°Ðº Ð¸ Ð½Ðµ Ð´Ð¾Ð¶Ð´Ð°Ð²ÑÐ¸ÑÑ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»ÑÑÐºÐ¾Ð³Ð¾
Ð²Ð²Ð¾Ð´Ð°. Ð§ÑÐ¾Ð±Ñ Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ Ð¸ Ð¿Ð¾Ð´Ð¾Ð¶Ð´Ð°ÑÑ Ð¿Ð¾ÐºÐ° Ð¿ÑÐ¾Ð¼Ð¸Ñ Ð²ÑÐ¿Ð¾Ð»Ð½Ð¸ÑÑÑ,
Ð¼Ñ Ð¼Ð¾Ð¶ÐµÐ¼ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ñ-ÑÐ¸Ñ <code>Lwt_main.run</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> () <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">let</span> line_promise <span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> Lwt.t <span style="color:#f92672">=</span> Lwt_io.<span style="color:#f92672">(</span>read_line stdin<span style="color:#f92672">)</span> <span style="color:#66d9ef">in</span>
  print_endline <span style="color:#e6db74">&#34;Execution just continues...&#34;</span><span style="color:#f92672">;</span>
  <span style="color:#66d9ef">let</span> line <span style="color:#f92672">:</span> <span style="color:#66d9ef">string</span> <span style="color:#f92672">=</span> Lwt_main.run line_promise <span style="color:#66d9ef">in</span>
  ignore line
</code></pre></div><p><code>Lwt_main.run</code> Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÑÑÑ ÑÐ¾Ð»ÑÐºÐ¾ 1 ÑÐ°Ð·, ÑÑÐ¾Ð±Ñ Ð¿Ð¾Ð´Ð¾Ð¶Ð°ÑÑ Ð¿Ð¾ÐºÐ°
Ð·Ð°Ð²ÐµÑÑÐ¸ÑÑÑ Ð¿ÑÐ¾Ð¼Ð¸Ñ ÑÐ°Ð¼Ð¾Ð³Ð¾ Ð²ÐµÑÑÐ½ÐµÐ³Ð¾ ÑÑÐ¾Ð²Ð½Ñ. ÐÐ¾Ð³Ð´Ð° ÑÑÐ¾Ñ Ð¿ÑÐ¾Ð¼Ð¸Ñ
Ð²ÑÐ¿Ð¾Ð»Ð½Ð¸ÑÑÑ, Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ð° Ð·Ð°Ð²ÐµÑÑÐ°ÐµÑ ÑÐ°Ð±Ð¾ÑÑ.</p>
</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>
<p>ÐÑÑ Ð¿ÑÐ¸Ð¼ÐµÑÑ:</p>
<p>ÐÐ¿ÑÑÑ Ð¶Ðµ, Ñ Ð½Ðµ Ð·Ð°Ð¼Ð¾ÑÐ°ÑÐ¸Ð²Ð°Ð»ÑÑ Ð¸ Ð²Ð·ÑÐ» Ð¿ÑÐ¸Ð¼ÐµÑÑ Ð¸Ð· Ð¾ÑÐ¸ÑÐ¸Ð°Ð»ÑÐ½Ð¾Ð³Ð¾
ÑÑÑÐ¾ÑÐ¸Ð°Ð»Ð°, ÑÐº Ñ ÑÐ»Ð¸ÑÐºÐ¾Ð¼ Ð»ÐµÐ½Ð¸Ð²ÑÐ¹, ÑÑÐ¾Ð±Ñ Ð¿ÑÐ¸Ð´ÑÐ¼ÑÐ²Ð°ÑÑ Ð¸Ñ ÑÐ°Ð¼Ð¾Ð¼Ñ.</p>
<p>ÐÑÐ¸Ð¼ÐµÑ ÑÑÐ½ÐºÑÐ¸Ð¸, ÐºÐ¾ÑÐ¾ÑÐ°Ñ Ð¿ÐµÑÐ°ÑÐ°ÐµÑ âticâ ÐºÐ°Ð¶Ð´ÑÑ ÑÐµÐºÑÐ½Ð´Ñ, Ð½Ðµ
Ð±Ð»Ð¾ÐºÐ¸ÑÑÑ Ð´ÑÑÐ³Ð¸Ðµ âÐ¿Ð¾ÑÐ¾ÐºÐ¸â:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> tic () <span style="color:#f92672">=</span>
  print_endline <span style="color:#e6db74">&#34;tic&#34;</span><span style="color:#f92672">;</span>
  <span style="color:#66d9ef">let</span><span style="color:#f92672">%</span>lwt () <span style="color:#f92672">=</span> Lwt_unix.sleep 1<span style="color:#f92672">.</span>0 <span style="color:#66d9ef">in</span>
  tic ()
</code></pre></div><p>ÐÑÐ¸Ð¼ÐµÑ Ð·Ð°Ð¿ÑÑÐºÐ° Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¸Ñ âÐ¿Ð¾ÑÐ¾ÐºÐ¾Ð²â Ð¸ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ðµ Ð¸Ñ ÑÐµÐ·ÑÐ»ÑÑÐ°ÑÐ¾Ð².</p>
<p>ÐÐ¾Ð¿ÑÑÑÐ¸Ð¼ Ñ Ð½Ð°Ñ ÐµÑÑÑ Ð¿Ð°ÑÐ° Ñ-ÑÐ¸Ð¹ <code>f</code> Ð¸ <code>g</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">val</span> f <span style="color:#f92672">:</span> <span style="color:#66d9ef">unit</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">unit</span> Lwt.t
<span style="color:#66d9ef">val</span> g <span style="color:#f92672">:</span> <span style="color:#66d9ef">unit</span> <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">unit</span> Lwt.t
</code></pre></div><p>Ð¡Ð»ÐµÐ´ÑÑÑÐ¸Ð¹ ÐºÐ¾Ð´ Ð·Ð°Ð¿ÑÑÑÐ¸Ñ Ð¸Ñ Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ñ Ð¿Ð¾ÑÐ»ÐµÐ´Ð¾Ð²Ð°ÑÐµÐ»ÑÐ½Ð¾:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span><span style="color:#f92672">%</span>lwt () <span style="color:#f92672">=</span> f () <span style="color:#66d9ef">in</span>
<span style="color:#66d9ef">let</span><span style="color:#f92672">%</span>lwt () <span style="color:#f92672">=</span> g () <span style="color:#66d9ef">in</span>
<span style="color:#f92672">...</span>
</code></pre></div><p>Ð Ð²Ð¾Ñ ÑÐ°Ðº Ð¼Ñ Ð¼Ð¾Ð¶ÐµÐ¼ Ð·Ð°Ð¿ÑÑÑÐ¸ÑÑ Ð¾Ð±Ðµ Ñ-ÑÐ¸Ð¸ ÐºÐ¾Ð½ÐºÑÑÐµÐ½ÑÐ½Ð¾ Ð¸ ÑÑÐ°Ð·Ñ Ð¶Ðµ
Ð¿Ð¾Ð´Ð¾Ð¶Ð´Ð°ÑÑ Ð¸Ñ Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð¸Ñ:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> p1 <span style="color:#f92672">=</span> f () <span style="color:#66d9ef">in</span>
<span style="color:#66d9ef">let</span> p2 <span style="color:#f92672">=</span> g () <span style="color:#66d9ef">in</span>
<span style="color:#66d9ef">let</span><span style="color:#f92672">%</span>lwt () <span style="color:#f92672">=</span> p1 <span style="color:#66d9ef">in</span>
<span style="color:#66d9ef">let</span><span style="color:#f92672">%</span>lwt () <span style="color:#f92672">=</span> p2 <span style="color:#66d9ef">in</span>
<span style="color:#f92672">...</span>
</code></pre></div><p>ÐÑÐ¸Ð¼ÐµÑ Ñ-ÑÐ¸Ð¸, ÐºÐ¾ÑÐ¾ÑÐ°Ñ Ð²ÑÐ¿Ð¾Ð»Ð½ÑÐµÑ Ð²ÑÐµ Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ñ Ð¸Ð· ÑÐ¿Ð¸ÑÐºÐ°
ÐºÐ¾Ð½ÐºÑÑÑÐµÐ½ÑÐ½Ð¾:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> map f l <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">match</span> l <span style="color:#66d9ef">with</span>
  <span style="color:#f92672">|</span> [] <span style="color:#f92672">-&gt;</span> Lwt.return []
  <span style="color:#f92672">|</span> v <span style="color:#f92672">::</span> r <span style="color:#f92672">-&gt;</span>
      <span style="color:#66d9ef">let</span> t <span style="color:#f92672">=</span> f v <span style="color:#66d9ef">in</span>
      <span style="color:#66d9ef">let</span> rt <span style="color:#f92672">=</span> map f r <span style="color:#66d9ef">in</span>
      <span style="color:#66d9ef">let</span><span style="color:#f92672">%</span>lwt v&#39; <span style="color:#f92672">=</span> t <span style="color:#66d9ef">in</span>
      <span style="color:#66d9ef">let</span><span style="color:#f92672">%</span>lwt l&#39; <span style="color:#f92672">=</span> rt <span style="color:#66d9ef">in</span>
      Lwt.return <span style="color:#f92672">(</span>v&#39; <span style="color:#f92672">::</span> l&#39;<span style="color:#f92672">)</span>
</code></pre></div><p>Ð¡Ð»ÐµÐ´ÑÑÑÐ°Ñ Ñ-ÑÐ¸Ñ Ð½Ð°Ð¾Ð±Ð¾ÑÐ¾Ñ, Ð¾Ð¶Ð¸Ð´Ð°ÐµÑ Ð¿Ð¾ÐºÐ° Ð²ÑÐ¿Ð¾Ð»Ð½Ð¸ÑÑÑ ÐºÐ°Ð¶Ð´Ð¾Ðµ
Ð¿ÑÐµÐ´ÑÐ´ÑÑÐµÐµ Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ðµ Ð¸Ð· ÑÐ¿Ð¸ÑÐºÐ°, Ð¿ÑÐµÐ¶Ð´Ðµ ÑÐµÐ¼ Ð·Ð°Ð¿ÑÑÑÐ¸ÑÑ ÑÐ»ÐµÐ´ÑÑÑÐµÐµ:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ocaml" data-lang="ocaml"><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">rec</span> map_serial f l <span style="color:#f92672">=</span>
  <span style="color:#66d9ef">match</span> l <span style="color:#66d9ef">with</span>
  <span style="color:#f92672">|</span> [] <span style="color:#f92672">-&gt;</span> return []
  <span style="color:#f92672">|</span> v <span style="color:#f92672">::</span> r <span style="color:#f92672">-&gt;</span>
      <span style="color:#66d9ef">let</span><span style="color:#f92672">%</span>lwt v&#39; <span style="color:#f92672">=</span> f v <span style="color:#66d9ef">in</span>
      <span style="color:#66d9ef">let</span><span style="color:#f92672">%</span>lwt l&#39; <span style="color:#f92672">=</span> map_serial f r <span style="color:#66d9ef">in</span>
      Lwt.return <span style="color:#f92672">(</span>v&#39; <span style="color:#f92672">::</span> l&#39;<span style="color:#f92672">)</span>
</code></pre></div><p>ÐÐ¾Ð½ÐµÑÐ½Ð¾, ÑÑÐ¾ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ°Ð¼ÑÐµ âÐ²ÐµÑÑÐºÐ¸â Lwt.</p>
</li>
</ul>
<h4 id="Ð¿Ð¾Ð»ÐµÐ·Ð½ÑÐµ-ÑÑÑÐ»ÐºÐ¸">
  ÐÐ¾Ð»ÐµÐ·Ð½ÑÐµ ÑÑÑÐ»ÐºÐ¸
  <a class="heading-link" href="#%d0%bf%d0%be%d0%bb%d0%b5%d0%b7%d0%bd%d1%8b%d0%b5-%d1%81%d1%81%d1%8b%d0%bb%d0%ba%d0%b8">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<ul>
<li><a href="https://www.cs.cornell.edu/courses/cs3110/2019sp/textbook/ads/promises.html">Promises </a> Ð² ÐºÐ½Ð¸Ð³Ðµ Functional Programming in OCaml</li>
<li><a href="https://gitter.im/ocaml-lwt/Lobby">Lwt Gitter</a></li>
<li>Ð¢ÑÑÐ¾ÑÐ¸Ð°Ð» <a href="https://ocsigen.org/tuto/6.4/manual/lwt">Lwt in 5 minutes</a></li>
<li><a href="https://ocsigen.org/lwt/4.4.0/manual/manual">Lwt Ð¼Ð°Ð½ÑÐ°Ð»</a></li>
<li><a href="https://www.baturin.org/code/lwt-counter-server/">Ð¢ÑÑÐ¾ÑÐ¸Ð°Ð»</a> Ð¿ÑÐ¾ ÑÐ¾, ÐºÐ°Ðº ÑÐ´ÐµÐ»Ð°ÑÑ Ð¿ÑÐ¾ÑÑÐ¾Ð¹ ÑÐµÑÐ²ÐµÑ Ð½Ð° ÑÐ¾ÐºÐµÑÐ°Ñ, Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÑÑÐ¸Ð¹
ÐºÐ»Ð¸ÐµÐ½ÑÐ°Ð¼ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐ°ÑÑÑÑ, ÑÐ²ÐµÐ»Ð¸ÑÐ¸Ð²Ð°ÑÑ ÑÑÑÑÑÐ¸Ðº Ð¸ ÑÐ¸ÑÐ°ÑÑ ÐµÐ³Ð¾
Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ.</li>
</ul>
<h2 id="emacs">
  Emacs
  <a class="heading-link" href="#emacs">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<h3 id="my-first-emacs-package-ormolu-dot-el">
  <!-- raw HTML omitted -->DRAFT<!-- raw HTML omitted --> My first Emacs package: ormolu.el
  <a class="heading-link" href="#my-first-emacs-package-ormolu-dot-el">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<h4 id="intro">
  Intro
  <a class="heading-link" href="#intro">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>I&rsquo;ve been using Emacs on a daily basis for about 2 years already,</p>
<p><a href="https://github.com/tweag/ormolu">Ormolu</a> is an opinionated zero-configuration formatter for
Haskell source code built in <a href="http://tweag.io">Tweag</a>.</p>
<h3 id="writing-an-emacs-major-mode-for-the-tiger-language">
  <!-- raw HTML omitted -->DRAFT<!-- raw HTML omitted --> Writing an Emacs major mode for the Tiger language
  <a class="heading-link" href="#writing-an-emacs-major-mode-for-the-tiger-language">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<h4 id="references">
  References
  <a class="heading-link" href="#references">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>There is a really good tutorial by Xah Lee: <a href="http://ergoemacs.org/emacs/elisp%5Fwrite%5Fmajor%5Fmode%5Findex.html">Emacs Lisp How to
Write Major Mode</a>, which I highly recommend reading.</p>
<h2 id="notes-on-coq-and-ssreflect">
  Notes on Coq and Ssreflect
  <a class="heading-link" href="#notes-on-coq-and-ssreflect">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<h2 id="proving-tapl-in-coq">
  Proving TAPL in Coq
  <a class="heading-link" href="#proving-tapl-in-coq">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<h3 id="proving-tapl-in-coq--ch-3-wip">
  <!-- raw HTML omitted -->DONE<!-- raw HTML omitted --> Proving TAPL in Coq (ch 3, WIP)
  <a class="heading-link" href="#proving-tapl-in-coq--ch-3-wip">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>In order to understand things clearly and to learn Coq proof
assistant at the same time, I&rsquo;ve decided to do some proves while
reading the TAPL book.</p>
<p>The code is <a href="https://github.com/vyorkin/tapl-coq">on the GitHub</a>.</p>
<p>For the excercises I want to use the <a href="https://coq.inria.fr/refman/proof-engine/ssreflect-proof-language.html">ssreflect</a> proof language
instead of <code>ltac</code>. I&rsquo;ll keep solutions to each chapter in a
separate file. We&rsquo;ll always work in the following context:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-coq" data-lang="coq"><span style="color:#f92672">Set</span> <span style="color:#f92672">Implicit</span> <span style="color:#f92672">Arguments</span><span style="color:#f92672">.</span>
<span style="color:#f92672">Unset</span> <span style="color:#f92672">Strict</span> <span style="color:#f92672">Implicit</span><span style="color:#f92672">.</span>
<span style="color:#f92672">Unset</span> <span style="color:#f92672">Printing</span> <span style="color:#f92672">Implicit</span> Defensive<span style="color:#f92672">.</span>
From Coq <span style="color:#f92672">Require</span> <span style="color:#f92672">Import</span> ssreflect<span style="color:#f92672">.</span>
</code></pre></div><p>I&rsquo;ll start with the operational semantics of boolean
expressions. Here is the definition in Coq:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-coq" data-lang="coq"><span style="color:#f92672">Inductive</span> term <span style="color:#f92672">:</span> <span style="color:#66d9ef">Type</span> <span style="color:#f92672">:=</span>
<span style="color:#f92672">|</span> T_true
<span style="color:#f92672">|</span> T_false
<span style="color:#f92672">|</span> T_cond <span style="color:#f92672">(</span>cond t1 t2 <span style="color:#f92672">:</span> term<span style="color:#f92672">).</span>
</code></pre></div><p>Letâs introduce a <a href="https://coq.inria.fr/refman/user-extensions/syntax-extensions.html#custom-entries">custom grammar entry</a> for expressiveness.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-coq" data-lang="coq">Declare Custom Entry term<span style="color:#f92672">.</span>

<span style="color:#f92672">Notation</span> <span style="color:#e6db74">&#34;[ e ]&#34;</span> <span style="color:#f92672">:=</span> e <span style="color:#f92672">(</span>e custom term at level 2<span style="color:#f92672">).</span>
<span style="color:#f92672">Notation</span> <span style="color:#e6db74">&#34;( x )&#34;</span> <span style="color:#f92672">:=</span> x <span style="color:#f92672">(</span><span style="color:#66d9ef">in</span> custom term<span style="color:#f92672">,</span> x at level 2<span style="color:#f92672">).</span>

<span style="color:#f92672">Notation</span> <span style="color:#e6db74">&#34;&#39;true&#39;&#34;</span>  <span style="color:#f92672">:=</span> <span style="color:#f92672">(</span>T_true<span style="color:#f92672">)</span>  <span style="color:#f92672">(</span><span style="color:#66d9ef">in</span> custom term at level 0<span style="color:#f92672">).</span>
<span style="color:#f92672">Notation</span> <span style="color:#e6db74">&#34;&#39;false&#39;&#34;</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">(</span>T_false<span style="color:#f92672">)</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">in</span> custom term at level 0<span style="color:#f92672">).</span>

<span style="color:#f92672">Notation</span> <span style="color:#e6db74">&#34;&#39;if&#39; cond &#39;then&#39; t1 &#39;else&#39; t2&#34;</span> <span style="color:#f92672">:=</span>
  <span style="color:#f92672">(</span>T_cond cond t1 t2<span style="color:#f92672">)</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">in</span> custom term at level 2<span style="color:#f92672">).</span>

<span style="color:#f92672">Notation</span> <span style="color:#e6db74">&#34;x&#34;</span> <span style="color:#f92672">:=</span> x <span style="color:#f92672">(</span><span style="color:#66d9ef">in</span> custom term at level 0<span style="color:#f92672">,</span> x constr at level 0<span style="color:#f92672">).</span>
</code></pre></div><p>We can check that it works as expected:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-coq" data-lang="coq"><span style="color:#f92672">Check</span> <span style="color:#f92672">[</span> true <span style="color:#f92672">].</span>
<span style="color:#f92672">Check</span> <span style="color:#66d9ef">fun</span> cond t1 t2 <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">[</span> <span style="color:#66d9ef">if</span> cond <span style="color:#66d9ef">then</span> t1 <span style="color:#66d9ef">else</span> t2 <span style="color:#f92672">].</span>
<span style="color:#f92672">Unset</span> <span style="color:#f92672">Printing</span> Notations<span style="color:#f92672">.</span>
<span style="color:#f92672">Check</span> <span style="color:#66d9ef">fun</span> cond t1 t2 <span style="color:#f92672">=&gt;</span> <span style="color:#f92672">[</span> <span style="color:#66d9ef">if</span> cond <span style="color:#66d9ef">then</span> t1 <span style="color:#66d9ef">else</span> t2 <span style="color:#f92672">].</span>
<span style="color:#f92672">Set</span> <span style="color:#f92672">Printing</span> Notations<span style="color:#f92672">.</span>
</code></pre></div><p>The <code>==&gt;</code> notation represents an evaluation relation on terms: &ldquo;<code>t</code>
evaluates to <code>t'</code> in one step&rdquo; (as per p.35)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-coq" data-lang="coq"><span style="color:#f92672">Reserved</span> <span style="color:#f92672">Notation</span> <span style="color:#e6db74">&#34;t ==&gt; t&#39;&#34;</span> <span style="color:#f92672">(</span>at level 50<span style="color:#f92672">).</span>
</code></pre></div><p>This relation is defined by three inference rules:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-coq" data-lang="coq"><span style="color:#f92672">Inductive</span> eval_step <span style="color:#f92672">:</span> term <span style="color:#f92672">-&gt;</span> term <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Prop</span> <span style="color:#f92672">:=</span>
<span style="color:#f92672">|</span> E_IfTrue  <span style="color:#f92672">:</span> <span style="color:#66d9ef">forall</span> t1 t2<span style="color:#f92672">,</span> <span style="color:#f92672">[</span> <span style="color:#66d9ef">if</span> true  <span style="color:#66d9ef">then</span> t1 <span style="color:#66d9ef">else</span> t2 <span style="color:#f92672">]</span> <span style="color:#f92672">==&gt;</span> t1
<span style="color:#f92672">|</span> E_IfFalse <span style="color:#f92672">:</span> <span style="color:#66d9ef">forall</span> t1 t2<span style="color:#f92672">,</span> <span style="color:#f92672">[</span> <span style="color:#66d9ef">if</span> false <span style="color:#66d9ef">then</span> t1 <span style="color:#66d9ef">else</span> t2 <span style="color:#f92672">]</span> <span style="color:#f92672">==&gt;</span> t2
<span style="color:#f92672">|</span> E_If <span style="color:#f92672">:</span> <span style="color:#66d9ef">forall</span> c c&#39; t1 t2<span style="color:#f92672">,</span> c <span style="color:#f92672">==&gt;</span> c&#39; <span style="color:#f92672">-&gt;</span> <span style="color:#f92672">[</span> <span style="color:#66d9ef">if</span> c <span style="color:#66d9ef">then</span> t1 <span style="color:#66d9ef">else</span> t2<span style="color:#f92672">]</span> <span style="color:#f92672">==&gt;</span> <span style="color:#f92672">[</span> <span style="color:#66d9ef">if</span> c&#39; <span style="color:#66d9ef">then</span> t1 <span style="color:#66d9ef">else</span> t2 <span style="color:#f92672">]</span>
where <span style="color:#e6db74">&#34;e ==&gt; e&#39;&#34;</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">(</span>eval_step e e&#39;<span style="color:#f92672">).</span>
</code></pre></div><p><strong>Definition</strong>: an instance of an inference rule is obtained by
consistently replace each metavariable by the same term in the
rule&rsquo;s conclusion and all its premises (if any).</p>
<p>The example instance of the <code>E_IfTrue</code> rule:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-coq" data-lang="coq"><span style="color:#f92672">Theorem</span> ex_inst_e_iftrue <span style="color:#f92672">:</span>
  <span style="color:#f92672">[</span> <span style="color:#66d9ef">if</span> true <span style="color:#66d9ef">then</span> true <span style="color:#66d9ef">else</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">if</span> false <span style="color:#66d9ef">then</span> false <span style="color:#66d9ef">else</span> false<span style="color:#f92672">)</span> <span style="color:#f92672">]</span> <span style="color:#f92672">==&gt;</span> <span style="color:#f92672">[</span> true <span style="color:#f92672">].</span>
<span style="color:#f92672">Proof</span><span style="color:#f92672">.</span> <span style="color:#66d9ef">by</span> <span style="color:#66d9ef">apply</span><span style="color:#f92672">:</span> E_IfTrue<span style="color:#f92672">.</span> <span style="color:#f92672">Qed</span><span style="color:#f92672">.</span>
</code></pre></div><p><strong>Definition</strong>: The one-step evaluation relation <code>==&gt;</code> is the
smallest binary relation on terms satisfying the three rules in
<code>eval_step</code>. When the pair <code>(t, t')</code> is in the evaluation
relation, we say that &ldquo;the evaluation statement (or judgment) <code>t ==&gt; t'</code> is derivable&rdquo;.</p>
<p>Let&rsquo;s show an example of a derivable evaluation statememt. We&rsquo;ll
use these 3 abbreviations (they are taken from the book as is):</p>
<p>The proof is by construction of a derivation &ldquo;tree&rdquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-coq" data-lang="coq"><span style="color:#f92672">Module</span> Ex_3_5_3<span style="color:#f92672">.</span>
  <span style="color:#f92672">Definition</span> s <span style="color:#f92672">:=</span> <span style="color:#f92672">[</span> <span style="color:#66d9ef">if</span> true  <span style="color:#66d9ef">then</span> false <span style="color:#66d9ef">else</span> false <span style="color:#f92672">].</span>
  <span style="color:#f92672">Definition</span> t <span style="color:#f92672">:=</span> <span style="color:#f92672">[</span> <span style="color:#66d9ef">if</span> s     <span style="color:#66d9ef">then</span> true  <span style="color:#66d9ef">else</span> true  <span style="color:#f92672">].</span>
  <span style="color:#f92672">Definition</span> u <span style="color:#f92672">:=</span> <span style="color:#f92672">[</span> <span style="color:#66d9ef">if</span> false <span style="color:#66d9ef">then</span> true  <span style="color:#66d9ef">else</span> true  <span style="color:#f92672">].</span>

  <span style="color:#f92672">Theorem</span> ex <span style="color:#f92672">:</span>
    <span style="color:#f92672">[</span> <span style="color:#66d9ef">if</span> t <span style="color:#66d9ef">then</span> false <span style="color:#66d9ef">else</span> false <span style="color:#f92672">]</span> <span style="color:#f92672">==&gt;</span> <span style="color:#f92672">[</span> <span style="color:#66d9ef">if</span> u <span style="color:#66d9ef">then</span> false <span style="color:#66d9ef">else</span> false <span style="color:#f92672">].</span>
  <span style="color:#f92672">Proof</span><span style="color:#f92672">.</span>
    <span style="color:#66d9ef">apply</span><span style="color:#f92672">:</span> E_If<span style="color:#f92672">.</span>
    <span style="color:#75715e">(*                             t ==&gt; u
</span><span style="color:#75715e">       [ if s then true else true  ] ==&gt; [ if false then true else true  ] *)</span>
    <span style="color:#66d9ef">apply</span><span style="color:#f92672">:</span> E_If<span style="color:#f92672">.</span>
    <span style="color:#75715e">(*                                 s ==&gt; [ false ]
</span><span style="color:#75715e">       [ if true then false else false ] ==&gt; [ false ] *)</span>
    <span style="color:#66d9ef">exact</span><span style="color:#f92672">:</span> E_IfTrue<span style="color:#f92672">.</span>

    Restart<span style="color:#f92672">.</span>

    <span style="color:#66d9ef">by</span> <span style="color:#66d9ef">do</span> 2<span style="color:#f92672">!</span> <span style="color:#66d9ef">apply</span><span style="color:#f92672">:</span> E_If<span style="color:#f92672">;</span> <span style="color:#66d9ef">exact</span><span style="color:#f92672">:</span> E_IfTrue<span style="color:#f92672">.</span>
  <span style="color:#f92672">Qed</span><span style="color:#f92672">.</span>
<span style="color:#f92672">End</span> Ex_3_5_3<span style="color:#f92672">.</span>
</code></pre></div><p><strong>Theorem</strong> [Determinacy of one-step evaluation]:
if <code>t ==&gt; t'</code> and <code>t ==&gt; t''</code>, then <code>t' = t''</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-coq" data-lang="coq"><span style="color:#f92672">Theorem</span> eval_step_is_det <span style="color:#f92672">:</span>
  <span style="color:#66d9ef">forall</span> t t&#39; t&#39;&#39; <span style="color:#f92672">:</span> term<span style="color:#f92672">,</span>
    <span style="color:#f92672">(</span>t <span style="color:#f92672">==&gt;</span> t&#39;<span style="color:#f92672">)</span> <span style="color:#f92672">/\</span> <span style="color:#f92672">(</span>t <span style="color:#f92672">==&gt;</span> t&#39;&#39;<span style="color:#f92672">)</span> <span style="color:#f92672">-&gt;</span> t&#39; <span style="color:#f92672">=</span> t&#39;&#39;<span style="color:#f92672">.</span>
  <span style="color:#f92672">Proof</span><span style="color:#f92672">.</span>
  <span style="color:#75715e">(* I havenât came up with a proof yet *)</span>
  Abort<span style="color:#f92672">.</span>
</code></pre></div><p>It would be much easier to define the one-step evaluation as a
function instead:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-coq" data-lang="coq"><span style="color:#f92672">Fixpoint</span> one_step <span style="color:#f92672">(</span>t <span style="color:#f92672">:</span> term<span style="color:#f92672">)</span> <span style="color:#f92672">:</span> term <span style="color:#f92672">:=</span>
<span style="color:#66d9ef">match</span> t <span style="color:#66d9ef">with</span>
<span style="color:#f92672">|</span> T_cond T_true t1 t2 <span style="color:#f92672">=&gt;</span> t1
<span style="color:#f92672">|</span> T_cond T_false t1 t2 <span style="color:#f92672">=&gt;</span> t2
<span style="color:#f92672">|</span> T_cond cond t1 t2 <span style="color:#f92672">=&gt;</span> T_cond <span style="color:#f92672">(</span>one_step cond<span style="color:#f92672">)</span> t1 t2
<span style="color:#f92672">|</span> t <span style="color:#f92672">=&gt;</span> t
<span style="color:#66d9ef">end</span><span style="color:#f92672">.</span>
</code></pre></div><p>A separate notation for our fixpoint-definition:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-coq" data-lang="coq"><span style="color:#f92672">Notation</span> <span style="color:#e6db74">&#34;t ==&gt;&gt; t&#39;&#34;</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">(</span>one_step t <span style="color:#f92672">=</span> t&#39;<span style="color:#f92672">)</span> <span style="color:#f92672">(</span>at level 50<span style="color:#f92672">).</span>
</code></pre></div><p>Now, it is much simplier to proove it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-coq" data-lang="coq"><span style="color:#f92672">Theorem</span> one_step_is_det t t&#39; t&#39;&#39;<span style="color:#f92672">:</span>
  t <span style="color:#f92672">==&gt;&gt;</span> t&#39; <span style="color:#f92672">/\</span> t <span style="color:#f92672">==&gt;&gt;</span> t&#39;&#39; <span style="color:#f92672">-&gt;</span> t&#39; <span style="color:#f92672">=</span> t&#39;&#39;<span style="color:#f92672">.</span>
<span style="color:#f92672">Proof</span><span style="color:#f92672">.</span>
  <span style="color:#66d9ef">move</span><span style="color:#f92672">=&gt;</span> [] H1 H2<span style="color:#f92672">.</span>
  <span style="color:#66d9ef">rewrite</span> <span style="color:#f92672">-</span>H1 <span style="color:#f92672">-</span>H2<span style="color:#f92672">.</span>
  <span style="color:#66d9ef">done</span><span style="color:#f92672">.</span>

  Restart<span style="color:#f92672">.</span>

  <span style="color:#75715e">(* Idiomatic proof *)</span>
  <span style="color:#66d9ef">by</span> <span style="color:#66d9ef">move</span><span style="color:#f92672">=&gt;</span> [] <span style="color:#f92672">-&gt;.</span>
<span style="color:#f92672">Qed</span><span style="color:#f92672">.</span>
</code></pre></div><p>Letâs define a notion of the ânormal formâ.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-coq" data-lang="coq"><span style="color:#f92672">Definition</span> nf t <span style="color:#f92672">:=</span> t <span style="color:#f92672">==&gt;&gt;</span> t<span style="color:#f92672">.</span>
</code></pre></div><p><strong>Theorem 3.5.7</strong>: Every value is in normal form.</p>
<p>The proof is trivial:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-coq" data-lang="coq"><span style="color:#f92672">Theorem</span> vnf <span style="color:#f92672">:</span> nf <span style="color:#f92672">[[</span> true <span style="color:#f92672">]]</span> <span style="color:#f92672">/\</span> nf <span style="color:#f92672">[[</span> false <span style="color:#f92672">]].</span>
<span style="color:#f92672">Proof</span><span style="color:#f92672">.</span> <span style="color:#66d9ef">by</span> []<span style="color:#f92672">.</span> <span style="color:#f92672">Qed</span><span style="color:#f92672">.</span>
</code></pre></div><p><strong>Theorem 3.5.8</strong>: If <code>t</code> is in normal form, then <code>t</code> is a value.</p>
<h4 id="summary">
  Summary
  <a class="heading-link" href="#summary">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h4>
<p>TODO</p>
<h3 id="proving-tapl-in-coq--ch-4-wip">
  <!-- raw HTML omitted -->TODO<!-- raw HTML omitted --> Proving TAPL in Coq (ch 4, WIP)
  <a class="heading-link" href="#proving-tapl-in-coq--ch-4-wip">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-coq" data-lang="coq"><span style="color:#f92672">Inductive</span> term <span style="color:#f92672">:</span> <span style="color:#66d9ef">Type</span> <span style="color:#f92672">:=</span>
<span style="color:#f92672">|</span> term_true
<span style="color:#f92672">|</span> term_false
<span style="color:#f92672">|</span> term_cond <span style="color:#f92672">(</span>cond t1 t2 <span style="color:#f92672">:</span> term<span style="color:#f92672">)</span>
<span style="color:#f92672">|</span> term_zero
<span style="color:#f92672">|</span> term_succ <span style="color:#f92672">(</span>n <span style="color:#f92672">:</span> term<span style="color:#f92672">)</span>
<span style="color:#f92672">|</span> term_pred <span style="color:#f92672">(</span>n <span style="color:#f92672">:</span> term<span style="color:#f92672">)</span>
<span style="color:#f92672">|</span> term_iszero <span style="color:#f92672">(</span>n <span style="color:#f92672">:</span> term<span style="color:#f92672">).</span>
</code></pre></div><h2 id="Ð·Ð°Ð¼ÐµÑÐºÐ¸-Ð¿ÑÐ¾-ÑÐ¸Ð¿Ñ-Ð²-coq--wip">
  <!-- raw HTML omitted -->DONE<!-- raw HTML omitted --> ÐÐ°Ð¼ÐµÑÐºÐ¸ Ð¿ÑÐ¾ ÑÐ¸Ð¿Ñ Ð² Coq (WIP)
  <a class="heading-link" href="#%d0%b7%d0%b0%d0%bc%d0%b5%d1%82%d0%ba%d0%b8-%d0%bf%d1%80%d0%be-%d1%82%d0%b8%d0%bf%d1%8b-%d0%b2-coq--wip">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h2>
<h3 id="gallina-Ð¸-cic">
  Gallina Ð¸ CIC
  <a class="heading-link" href="#gallina-%d0%b8-cic">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>Ð¤Ð¾ÑÐ¼Ð°Ð»ÑÐ½ÑÐ¹ ÑÐ·ÑÐº, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÑÑÑ Ð² Coq Ð´Ð»Ñ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ñ
Ð¼Ð°ÑÐµÐ¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸Ñ ÑÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð¸Ð¹ Ð¸ Ð´Ð¾ÐºÐ°Ð·Ð°ÑÐµÐ»ÑÑÑÐ² Ð½Ð°Ð·ÑÐ²Ð°ÐµÑÑÑ ÐºÑÑÐ¸ÑÐ°.
Ð¡ÐµÑÑÑÐ·Ð½Ð¾, Ð¾Ð½Ð¸ Ð½Ð°Ð·Ð²Ð°Ð»Ð¸ ÐµÐ³Ð¾ Ð¿Ð¾-Ð¸ÑÐ¿Ð°Ð½ÑÐºÐ¸ â Gallina (Ñ.Ðµ. gallina
blanca ÑÑÐ¾ âÐ±ÐµÐ»Ð°Ñ ÐºÑÑÐ¸ÑÐ°â). Ð­ÑÐ¾Ñ ÑÐ¾ÑÐ¼Ð°Ð»ÑÐ½ÑÐ¹ ÑÐ·ÑÐº Ð¾ÑÐ½Ð¾Ð²Ð°Ð½ Ð½Ð°
ÑÐ¾ÑÐ¼Ð°Ð»Ð¸Ð·Ð¼Ðµ (ÑÐ°Ð·Ð½Ð¾Ð²Ð¸Ð´Ð½Ð¾ÑÑÐ¸ ÑÐµÐ¾ÑÐ¸Ð¸ ÑÐ¸Ð¿Ð¾Ð²), ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð½Ð°Ð·ÑÐ²Ð°ÐµÑÑÑ
ÐÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ðµ ÐÐ½Ð´ÑÐºÑÐ¸Ð²Ð½ÑÑ ÐÐ¾Ð½ÑÑÑÑÐºÑÐ¸Ð¹ (Calculus of Inductive
Constructions, ÑÐ¾ÐºÑÐ°ÑÑÐ½Ð½Ð¾ CIC).</p>
<p>ÐÐ¾Ð³Ð¸ÑÐµÑÐºÐ¸Ðµ ÑÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð¸Ñ Ð¾ÑÐ¾Ð¶Ð´ÐµÑÑÐ²Ð»ÑÑÑÑÑ Ñ Ð½ÐµÐºÐ¾ÑÐ¾ÑÑÐ¼Ð¸ ÑÐ¸Ð¿Ð°Ð¼Ð¸, Ð° Ð¸Ñ
Ð´Ð¾ÐºÐ°Ð·Ð°ÑÐµÐ»ÑÑÑÐ²Ð° Ñ ÑÐµÑÐ¼Ð°Ð¼Ð¸ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²ÑÑÑÐ¸Ñ ÑÐ¸Ð¿Ð¾Ð². Ð¢Ð°ÐºÐ¸Ð¼ Ð¾Ð±ÑÐ°Ð·Ð¾Ð¼,
ÑÑÐ¾Ð±Ñ Ð´Ð¾ÐºÐ°Ð·Ð°ÑÑ ÑÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð¸Ðµ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾ ÑÐºÐ¾Ð½ÑÑÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ
(Ð¿ÑÐµÐ´ÑÑÐ²Ð¸ÑÑ) ÑÐµÑÐ¼ Ð½ÑÐ¶Ð½Ð¾Ð³Ð¾ ÑÐ¸Ð¿Ð°. ÐÐ¾ÑÐ¾ÑÐµ Ð³Ð¾Ð²Ð¾ÑÑ: ÑÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð¸Ñ ÑÑÐ¾
ÑÐ¸Ð¿Ñ, Ð° Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ñ ÑÑÐ¾ Ð´Ð¾ÐºÐ°Ð·Ð°ÑÐµÐ»ÑÑÑÐ²Ð°. ÐÑÑÐ°ÑÐ¸, Ð² Ð¾Ð±ÑÐ°ÑÐ½ÑÑ ÑÑÐ¾ÑÐ¾Ð½Ñ
ÑÑÐ¾ Ð½Ðµ Ð²ÑÐµÐ³Ð´Ð° ÑÐ°Ð±Ð¾ÑÐ°ÐµÑ.</p>
<p>ÐÐ°Ð¶Ð´Ð¾Ðµ Ð²ÑÑÐ°Ð¶ÐµÐ½Ð¸Ðµ Ð² Gallina ÑÑÐ¾ ÑÐµÑÐ¼ CIC, Ð° Ð»ÑÐ±Ð¾Ð¹ ÑÐµÑÐ¼ Ð¸Ð¼ÐµÐµÑ ÑÐ¸Ð¿
(Ð² Ð½ÐµÐºÐ¾ÑÐ¾ÑÐ¾Ð¼ ÐºÐ¾Ð½ÑÐµÐºÑÑÐµ).</p>
<h3 id="Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼ÑÐµ-ÑÐ¸Ð¿Ñ-Ð¸-ÑÑÐ½ÐºÑÐ¸Ð¸">
  ÐÐ°Ð²Ð¸ÑÐ¸Ð¼ÑÐµ ÑÐ¸Ð¿Ñ Ð¸ ÑÑÐ½ÐºÑÐ¸Ð¸
  <a class="heading-link" href="#%d0%b7%d0%b0%d0%b2%d0%b8%d1%81%d0%b8%d0%bc%d1%8b%d0%b5-%d1%82%d0%b8%d0%bf%d1%8b-%d0%b8-%d1%84%d1%83%d0%bd%d0%ba%d1%86%d0%b8%d0%b8">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p><em>Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑÑ Ð¿ÑÐµÐ´Ð²Ð°ÑÐ¸ÑÐµÐ»ÑÐ½Ð¾ Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ ÐºÐ°ÐºÐ¾Ðµ-ÑÐ¾ Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð¸Ð»Ð¸
Ð¾ÑÐ²ÐµÐ¶Ð¸ÑÑ Ð·Ð½Ð°Ð½Ð¸Ñ Ð¾ Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼ÑÑ ÑÐ¸Ð¿Ð°Ñ. ÐÐ¾ÑÑÐ°ÑÐ¾ÑÐ½Ð¾ Ð¿Ð¾ÑÑÐ°ÑÐ¸ÑÑ 5 Ð¼Ð¸Ð½ÑÑ Ð½Ð° ÑÑÐµÐ½Ð¸Ðµ <a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D1%8B%D0%B9%5F%D1%82%D0%B8%D0%BF">ÑÑÑÑÐºÐ¾Ð¹ Ð²Ð¸ÐºÐ¸</a></em></p>
<p><strong>Ð¢Ð¸Ð¿</strong> ÑÑÐ¾ ÑÐ°ÑÑÐ½ÑÐ¹ ÑÐ»ÑÑÐ°Ð¹ ÑÐµÑÐ¼Ð°, Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÑÐ¼ÑÐ¹ Ñ Ð¿Ð¾Ð¼Ð¾ÑÑÑ
ÑÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð¸Ñ ÑÐ¸Ð¿Ð¸Ð·Ð°ÑÐ¸Ð¸.</p>
<p>ÐÑÐ»Ð¸ \( x \) â Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½Ð°Ñ, Ð° \( T \) Ð¸ \( U \) â ÑÐµÑÐ¼Ñ, ÑÐ¾Ð³Ð´Ð° \(
\forall x : T, U \) ÑÐ¾Ð¶Ðµ ÑÐµÑÐ¼. Ð ÑÐ¾ Ð¶Ðµ Ð²ÑÐµÐ¼Ñ ÑÑÐ¾ ÑÐ¸Ð¿, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð¿ÑÐµÐ´ÑÑÐ°Ð²Ð»ÑÐµÑ
ÑÐ¾Ð±Ð¾Ð¹ ÑÐµÐ¼ÐµÐ¹ÑÑÐ²Ð¾ ÑÐ¸Ð¿Ð¾Ð² \( U \), Ð¸Ð½Ð´ÐµÐºÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÑ ÑÐ»ÐµÐ¼ÐµÐ½ÑÐ°Ð¼Ð¸ ÑÐ¸Ð¿Ð°
\( T \).</p>
<ul>
<li>ÐÐ¾Ð³Ð´Ð° \( x \) Ð²ÑÑÑÐµÑÐ°ÐµÑÑÑ Ð² ÑÐµÑÐ¼Ðµ \( U \) (ÐºÐ°Ðº ÑÐ²Ð¾Ð±Ð¾Ð´Ð½Ð°Ñ
Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½Ð°Ñ) Ð¼Ñ Ð³Ð¾Ð²Ð¾ÑÐ¸Ð¼, ÑÑÐ¾ \( \forall x : T, U \) â Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼ÑÐ¹ ÑÐ¸Ð¿</li>
<li>ÐÑÐ»Ð¸ \( x \) Ð½Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÑÑÑ Ð² \( U \), ÑÐ¾ Ð¼Ñ Ð¿Ð¾Ð»ÑÑÐ¸Ð¼ Ð¾Ð±ÑÑÐ½ÑÑ
Ñ-ÑÐ¸Ñ ÑÐ¸Ð¿Ð° \( T \rightarrow U \)</li>
</ul>
<p>ÐÐµÑ Ð½Ð¸ÐºÐ°ÐºÐ¾Ð¹ ÑÐ°Ð·Ð½Ð¸ÑÑ Ð¼ÐµÐ¶Ð´Ñ \( A \rightarrow B \) Ð¸ \( \forall x : A, B \) (ÐºÑÐ¾Ð¼Ðµ
Ð½Ð¾ÑÐ°ÑÐ¸Ð¸).</p>
<p>Ð Coq Ð½Ð¾ÑÐ°ÑÐ¸Ñ Ð²Ð¸Ð´Ð° <code>&quot;A -&gt; B&quot; := forall _ : A, B</code> ÑÑÐ¾ Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð°Ñ
Ñ-ÑÐ¸Ñ, Ð² ÑÐ¾Ð¼ ÑÐ»ÑÑÐ°Ðµ, ÐºÐ¾Ð³Ð´Ð° Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ÑÐ¹ ÑÐ¸Ð¿ Ð½Ð¸ÐºÐ°Ðº Ð½Ðµ Ð·Ð°Ð²Ð¸ÑÐ¸Ñ Ð¾Ñ
Ð²ÑÐ¾Ð´Ð½Ð¾Ð³Ð¾ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ.</p>
<p>ÐÐ¾Ð¾Ð±ÑÐµ Ð³Ð¾Ð²Ð¾ÑÑ, Ð¾Ð±ÑÑÐ½Ð¾Ðµ ÑÑÐ½ÐºÑÐ¸Ð¾Ð½Ð°Ð»ÑÐ½Ð¾Ðµ Ð¿ÑÐ¾ÑÑÑÐ°Ð½ÑÑÐ²Ð¾ ÑÐ²Ð»ÑÐµÑÑÑ ÑÐµÐ¼
ÑÐ°ÑÑÐ½ÑÐ¼ ÑÐ»ÑÑÐ°ÐµÐ¼, ÐºÐ¾Ð³Ð´Ð° Ð¾Ð±Ð»Ð°ÑÑÑ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ð¹ Ð½Ðµ Ð·Ð°Ð²Ð¸ÑÐ¸Ñ Ð¾Ñ Ð²ÑÐ¾Ð´Ð½Ð¾Ð³Ð¾
Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ°.</p>
<h3 id="ÑÐ¸Ð¿Ñ-ÑÐµÑÐ¼Ñ-Ð¸-Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ñ">
  Ð¢Ð¸Ð¿Ñ, ÑÐµÑÐ¼Ñ Ð¸ Ð²ÑÑÐ¸ÑÐ»ÐµÐ½Ð¸Ñ
  <a class="heading-link" href="#%d1%82%d0%b8%d0%bf%d1%8b-%d1%82%d0%b5%d1%80%d0%bc%d1%8b-%d0%b8-%d0%b2%d1%8b%d1%87%d0%b8%d1%81%d0%bb%d0%b5%d0%bd%d0%b8%d1%8f">
    <i class="fa fa-link" aria-hidden="true"></i>
  </a>
</h3>
<p>ÐÑÐ¾ÑÑÐµÐ¹ÑÐ¸Ðµ ÑÐµÑÐ¼Ñ ÑÑÐ¾ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½ÑÐµ Ð¸ Ð´Ð²Ð° ÑÐ¾ÑÑÐ°: \( Prop \) Ð¸ \(
Type_{i} \) Ð´Ð»Ñ \( i \in \mathbb{N} \).</p>
<p>ÐÐ°Ðº Ð¸Ð·Ð²ÐµÑÑÐ½Ð¾, <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%81%D1%82%D0%BE%5F%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5%5F%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D0%B0-%D0%B8%D1%81%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5#%D0%9A%D0%BE%D0%BD%D1%82%D0%B5%D0%BA%D1%81%D1%82%D1%8B%5F%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8%5F%D0%B8%5F%D1%83%D1%82%D0%B2%D0%B5%D1%80%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F%5F%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8">ÑÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð¸Ñ ÑÐ¸Ð¿Ð¸Ð·Ð°ÑÐ¸Ð¸</a> Ð²ÑÐ¾Ð´Ðµ \( \Gamma \vdash t : T
\) ÑÐ²ÑÐ·ÑÐ²Ð°ÑÑ Ð½ÐµÐºÐ¾ÑÐ¾ÑÑÐ¹ ÐºÐ¾Ð½ÑÐµÐºÑÑ \( \Gamma \) (Ð³Ð°Ð¼Ð¼Ð°) Ð¸ Ð´Ð²Ð° ÑÐµÑÐ¼Ð° \( t
\) Ð¸ \( T \). ÐÐ¾Ð½ÑÐµÐºÑÑ \( \Gamma \) ÑÑÐ¾ ÑÐ°ÐºÐ¾Ðµ Ð¼ÐµÑÑÐ¾, Ð³Ð´Ðµ ÑÑÐ°Ð½ÑÑÑÑ Ð²ÑÐµ
Ð¸Ð·Ð²ÐµÑÑÐ½ÑÐµ Ð½Ð°Ð¼ ÑÐ°ÐºÑÑ Ð¸ Ð¿ÑÐµÐ´Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Ð² ÑÐ¾Ñ Ð¼Ð¾Ð¼ÐµÐ½Ñ, ÐºÐ¾Ð³Ð´Ð° Ð½Ð°Ð¼
Ð²ÑÑÑÐµÑÐ°ÐµÑÑÑ ÑÐµÑÐ¼, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð¼Ñ Ð²Ð¸Ð´Ð¸Ð¼ ÑÐ¿ÑÐ°Ð²Ð° Ð¾Ñ \( \vdash \).
ÐÐ¾Ð½ÑÐµÐºÑÑ Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ Ð¿ÑÑÑÑÐ¼ Ð¸Ð»Ð¸ ÑÐ¾Ð´ÐµÑÐ¶Ð°ÑÑ ÑÐ¸Ð¿Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÐµ
Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½ÑÐµ Ð¸ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ:</p>
<ul>
<li>Ð¢Ð¸Ð¿Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°Ð½Ð½Ð°Ñ <strong>Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½Ð°Ñ</strong> â Ð¿Ð°ÑÐ° Ð¸Ð· Ð¸Ð¼ÐµÐ½Ð¸ Ð¸ ÑÐ¸Ð¿Ð°:
<code>Variable n : nat</code></li>
<li>Ð¢Ð¸Ð¿Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°Ð½Ð½Ð¾Ðµ <strong>Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ</strong> â ÑÑÐ¾Ð¹ÐºÐ° Ð¸Ð· Ð¸Ð¼ÐµÐ½Ð¸, ÑÐµÑÐ¼Ð° Ð¸
ÑÐ¸Ð¿Ð°: <code>Definition a : T := t</code></li>
</ul>
<p>Ð£ÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð¸Ñ ÑÐ¸Ð¿Ð¸Ð·Ð°ÑÐ¸Ð¸ Ð² Ð¿ÑÑÑÐ¾Ð¼ ÐºÐ¾Ð½ÑÐµÐºÑÑÐµ Ð²ÑÑÐ°Ð¶Ð°ÑÑ Ð°ÐºÑÐ¸Ð¾Ð¼Ñ:</p>
<ul>
<li>\( \vdash Prop : Type_{1} \)</li>
<li>\( \vdash Type : Type_{i+1} \)</li>
</ul>
<p>Ð¢.Ðµ. ÑÐ¾ÑÑÐ° \( Prop \) Ð¸ \( Type \) ÑÑÐ¾ Ð¾Ð´Ð½Ð¾Ð²ÑÐµÐ¼ÐµÐ½Ð½Ð¾ Ð¸ ÑÐ¸Ð¿Ñ Ð¸ ÑÐ¸Ð¿Ñ ÑÐ¸Ð¿Ð¾Ð².</p>
<p>Ð¢Ð¸Ð¿ ÑÑÐ¾ ÑÐµÑÐ¼, ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð¼Ð¾Ð¶ÐµÑ  Ð±ÑÑÑ ÑÐ¸Ð¿Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°Ð½ ÑÐ¾ÑÑÐ¾Ð¼ Ð² Ð½ÐµÐºÐ¾ÑÐ¾ÑÐ¾Ð¼ ÐºÐ¾Ð½ÑÐµÐºÑÑÐµ:</p>
<ul>
<li>\( \Gamma \vdash T : Prop \)</li>
<li>\( \Gamma \vdash T : Type \)</li>
</ul>
<p>ÐÐ¾Ð½ÑÐµÐºÑÑÑ Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÑÑ Ð½Ð°Ð¼ ÐºÐ¾Ð½ÑÑÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð±Ð¾Ð»ÐµÐµ ÑÐ»Ð¾Ð¶Ð½ÑÐµ ÑÐ¸Ð¿Ñ, Ð½Ð°Ð¿ÑÐ¸Ð¼ÐµÑ:</p>
<p>\( \Gamma \vdash T : Type \wedge \Gamma,x : T \vdash U : Type \Longrightarrow \Gamma \vdash \forall x : T, U : Type \)</p>
<p>Ð¿Ð¾Ð»ÑÑÐµÐ½Ð½ÑÐ¹ ÑÐ¸Ð¿ \( \Gamma \vdash \forall x : T, U : Type \) ÑÑÐ¾ ÑÐ¸Ð¿ ÑÑÐ½ÐºÑÐ¸Ð¹ \( T \rightarrow U \),
ÐºÐ¾ÑÐ¾ÑÑÐµ Ð¾Ð¿Ð¸ÑÑÐ²Ð°ÑÑÑÑ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼ Ð¿ÑÐ°Ð²Ð¸Ð»Ð¾Ð¼:
\( \Gamma \vdash \forall x : T, U : Type \wedge \Gamma,x : T \vdash t : U
\Longrightarrow \Gamma \vdash fun \space x \Rightarrow t : \forall x : T, U \)</p>
<p>ÐÑÐ¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¸Ð¿Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ°Ðº:
\( \Gamma \vdash u : \forall x : T, U \wedge \Gamma \vdash t : T \Longrightarrow \Gamma
\vdash u \space t : U [t/x] \)</p>
<p>Ð³Ð´Ðµ \( U [t/x] \) ÑÑÐ¾ ÑÐ¸Ð¿, Ð¿Ð¾Ð»ÑÑÐµÐ½Ð½ÑÐ¹ Ð¿ÑÑÑÐ¼ Ð·Ð°Ð¼ÐµÐ½Ñ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹
\( x \) Ð½Ð° ÑÐµÑÐ¼ \( t \) Ð² \( U \).</p>
<p>Ð Ð°ÑÑÐ¼Ð¾ÑÑÐ¸Ð¼ ÑÐ°Ð²ÑÐ¾Ð»Ð³Ð¸Ñ \( A \rightarrow A \). ÐÐ´ÐµÑÑ ÑÐ¸Ð¼Ð²Ð¾Ð» Ð¸Ð¼Ð¿Ð»Ð¸ÐºÐ°ÑÐ¸Ð¸ \( \rightarrow
\) Ð¼Ð¾Ð¶Ð½Ð¾ Ð¿Ð¾Ð½Ð¸Ð¼Ð°ÑÑ ÐºÐ°Ðº Ð»Ð¾Ð³Ð¸ÑÐµÑÐºÑÑ Ð¸Ð¼Ð¿Ð»Ð¸ÐºÐ°ÑÐ¸Ñ (âÐµÑÐ»Ð¸â¦, ÑÐ¾â¦â), Ð½Ð¾
ÑÑÐ¾Ñ Ð¶Ðµ ÑÐ¸Ð¼Ð²Ð¾Ð» Ð¼Ñ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÐ¼ Ð¸ Ð´Ð»Ñ ÑÑÐ½ÐºÑÐ¸Ð¹.</p>
<p>Ð¢ÐµÑÐ¼ <code>fun x : A =&gt; x</code> ÑÑÐ¾ ÐµÐ´Ð¸Ð½Ð¸ÑÐ½Ð°Ñ ÑÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ ÑÐµÑÐ¼Ð¾Ð² ÑÐ¸Ð¿Ð° \( A
\) Ð¸ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ð° ÑÐ¸Ð¿Ð° \( A \rightarrow A \).</p>
<p>ÐÑÐ»Ð¸ Ð¿Ð¾Ð½Ð¸Ð¼Ð°ÑÑ ÑÐ¸Ð¿ \( A \) ÐºÐ°Ðº ÑÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð¸Ðµ, Ð° ÑÐµÑÐ¼Ñ ÑÑÐ¾Ð³Ð¾ ÑÐ¸Ð¿Ð°
ÐºÐ°Ðº Ð´Ð¾ÐºÐ°Ð·Ð°ÑÐµÐ»ÑÑÑÐ²Ð° (ÑÐ²Ð¸Ð´ÐµÑÐµÐ»ÑÑÑÐ²Ð°) ÑÑÐ¾Ð³Ð¾ ÑÑÐ²ÐµÑÐ¶Ð´ÐµÐ½Ð¸Ñ, ÑÐ¾
Ð²ÑÑÐµÑÐ¿Ð¾Ð¼ÑÐ½ÑÑÐ°Ñ ÑÑÐ½ÐºÑÐ¸Ñ ÑÑÐ¾ ÐµÐ´Ð¸Ð½Ð¸ÑÐ¸Ð½Ð°Ñ ÑÑÐ½ÐºÑÐ¸Ñ Ð½Ð°Ð´
Ð´Ð¾ÐºÐ°Ð·Ð°ÑÐµÐ»ÑÑÑÐ²Ð°Ð¼Ð¸ \( A \).</p>
<p>ÐÐ¾Ð¾Ð±ÑÐµ, Ð´Ð¾ÐºÐ°Ð·Ð°ÑÐµÐ»ÑÑÑÐ²Ð° Ð¸Ð¼Ð¿Ð»Ð¸ÐºÐ°ÑÐ¸Ð¹ Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ°ÑÑÐ¼Ð°ÑÑÐ¸Ð²Ð°ÑÑ ÐºÐ°Ðº
ÑÑÐ½ÐºÑÐ¸Ð¸, ÑÑÐ°Ð½ÑÑÐ¾ÑÐ¼Ð¸ÑÑÑÑÐ¸Ðµ Ð´Ð¾ÐºÐ°Ð·Ð°ÑÐµÐ»ÑÑÑÐ²Ð° Ð¿ÑÐµÐ´Ð¿Ð¾ÑÑÐ»Ð¾Ðº Ð²
Ð´Ð¾ÐºÐ°Ð·Ð°ÑÐµÐ»ÑÑÑÐ²Ð° Ð·Ð°ÐºÐ»ÑÑÐµÐ½Ð¸Ð¹.</p>
<p>Ð Ð°ÑÑÐ¼Ð¾ÑÑÐ¸Ð¼ Ð¿ÑÐ°Ð²Ð¸Ð»Ð° Ð²Ð²Ð¾Ð´Ð° Ð´Ð»Ñ Ð¸Ð¼Ð¿Ð»Ð¸ÐºÐ°ÑÐ¸Ð¸ Ð¸ ÑÐ½Ð¸Ð²ÐµÑÑÐ°Ð»ÑÐ½Ð¾Ð¹
ÐºÐ²Ð°Ð½ÑÐ¸ÑÐ¸ÐºÐ°ÑÐ¸Ð¸. Ð¡Ð»ÐµÐ´ÑÑÑÐ°Ñ Ð·Ð°Ð¿Ð¸ÑÑ Ð¾Ð·Ð½Ð°ÑÐ°ÐµÑ: Ð´Ð»Ñ ÑÐ¾Ð³Ð¾, ÑÑÐ¾Ð±Ñ
Ð´Ð¾ÐºÐ°Ð·Ð°ÑÑ \( A \rightarrow B \) Ð½Ð°Ð¼ Ð½ÑÐ¶Ð½Ð¾ Ð´Ð¾ÐºÐ°Ð·Ð°ÑÑ \( B \), Ð¿ÑÐ¸ ÑÑÐ»Ð¾Ð²Ð¸Ð¸,
ÑÑÐ¾ \( A \) ÑÐ¶Ðµ Ð´Ð¾ÐºÐ°Ð·Ð°Ð½Ð¾.</p>
<p>\( {\dfrac{{A \atop \vdots} \atop B}{A \rightarrow B}} \rightarrow I \)</p>
<p>ÐÐ½Ð°Ð»Ð¾Ð³Ð¸ÑÐ½Ð¾ Ð¸ Ð·Ð´ÐµÑÑ: ÑÑÐ¾Ð±Ñ Ð´Ð¾ÐºÐ°Ð·Ð°ÑÑ \( \forall x, B \) Ð¼Ñ Ð´Ð¾Ð»Ð¶Ð½Ñ
Ð´Ð¾ÐºÐ°Ð·Ð°ÑÑ \( B \) Ð´Ð»Ñ Ð½ÐµÐºÐ¾ÑÐ¾ÑÐ¾Ð¹ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ \( x \).</p>
<p>\( {\dfrac{B}{\forall x, B}}{\space \forall_{I} \space (x \space \textsf{fresh})} \)</p>
<p>ÐÐ½Ð½Ð¾ÑÐ¸ÑÑÐµÐ¼ ÑÑÐ¸ Ð¿ÑÐ°Ð²Ð¸Ð»Ð° ÑÐ¸Ð¿Ð¸Ð·Ð°ÑÐ¸Ð¸ ÑÐµÑÐ¼Ð°Ð¼Ð¸, Ð¸Ð¼ÐµÑÑÐ¸Ð¼Ð¸
ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²ÑÑÑÐ¸Ðµ ÑÐ¸Ð¿Ñ:</p>
<p>\( {\dfrac{{x \space : \space A \atop \vdots} \atop {b \space : \space B}}{(fun \space x : A
\Rightarrow b) : A \rightarrow B}} \rightarrow I \)</p>
<p>\( \dfrac{b : B}{(fun \space x : A \Rightarrow b) : \forall x, B} \space \forall_{I} \)</p>
<p>ÐÐ°Ð¼ÐµÑÐ¸Ð¼, ÑÑÐ¾ ÑÐµÑÐ¼ (Ð°Ð±ÑÑÑÐ°ÐºÑÐ¸Ñ) \( fun â¦ \Rightarrow â¦ \) ÑÐ»ÑÐ¶Ð¸Ñ
Ð´Ð¾ÐºÐ°Ð·Ð°ÑÐµÐ»ÑÑÑÐ²Ð¾Ð¼ Ð´Ð»Ñ Ð¾Ð±Ð¾Ð¸Ñ Ð¿ÑÐ°Ð²Ð¸Ð». Ð Ð² ÑÐ¾Ð¼ Ð¸ Ð² Ð´ÑÑÐ³Ð¾Ð¼ ÑÐ»ÑÑÐ°Ðµ ÑÐµÑÐ¼
\( b \) ÑÐ²Ð»ÑÐµÑÑÑ Ð´Ð¾ÐºÐ°Ð·Ð°ÑÐµÐ»ÑÑÑÐ²Ð¾Ð¼ \( B \). ÐÐ´Ð¸Ð½ÑÑÐ²ÐµÐ½Ð½Ð°Ñ ÑÐ°Ð·Ð½Ð¸ÑÐ° Ð²
ÑÐ¾Ð¼, ÑÑÐ¾ \( x \) Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ ÑÐ²Ð¾Ð±Ð¾Ð´Ð½Ð¾Ð¹ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ Ð² \( B \)
ÑÐ¾Ð»ÑÐºÐ¾ Ð²Ð¾ Ð²ÑÐ¾ÑÐ¾Ð¼ Ð¿ÑÐ°Ð²Ð¸Ð»Ðµ.</p>
<p>Ð¡Ð´ÐµÐ»Ð°ÐµÐ¼ ÑÐ¾Ð¶Ðµ ÑÐ°Ð¼Ð¾Ðµ Ð´Ð»Ñ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²ÑÑÑÐ¸Ð¹ Ð¿ÑÐ°Ð²Ð¸Ð»
ÑÐ»Ð¸Ð¼Ð¸Ð½Ð¸ÑÐ¸Ð¸\ÑÐ´Ð°Ð»ÐµÐ½Ð¸Ñ. ÐÐ¼ÐµÐµÐ¼ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ðµ Ð¿ÑÐ°Ð²Ð¸Ð»Ð°:</p>
<p>\( \dfrac{A \rightarrow B \qquad A}{B} \rightarrow E \)</p>
<p>\( \dfrac{\forall x, B}{B[t/x]} \space \forall_E \space (t \space \textsf{is a term})\)</p>
<p>ÐÐ°Ðº Ð²Ð¸Ð´Ð½Ð¾ Ð¸Ð· Ð°Ð½Ð½Ð¾ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÑ Ð¿ÑÐ°Ð²Ð¸Ð» Ð½Ð¸Ð¶Ðµ, Ð² ÑÐ»ÑÑÐ°Ðµ ÑÐ»Ð¸Ð¼Ð¸Ð½Ð°ÑÐ¸Ð¸
Ð´Ð¾ÐºÐ°Ð·Ð°ÑÐµÐ»ÑÑÑÐ²Ð¾Ð¼ ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑÑ Ð¿ÑÐ¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ ÑÑÐ½ÐºÑÐ¸Ð¸.</p>
<p>\( \dfrac{f : A \rightarrow B \qquad t : A}{(f \space t) : B} \rightarrow E \)</p>
<p>\( \dfrac{f : \forall x : A, B \qquad t : A}{(f \space t) : B[t/x]} \space \forall_E \)</p>
<p>ÐÐ»Ñ Ð±Ð¾Ð»ÐµÐµ Ð³Ð»ÑÐ±Ð¾ÐºÐ¾Ð³Ð¾ Ð¿Ð¾Ð³ÑÑÐ¶ÐµÐ½Ð¸Ñ Ð¼Ð¾Ð¶Ð½Ð¾ Ð¿Ð¾ÑÐ¸ÑÐ°ÑÑ Ð²ÑÑÐµÑÐ¿Ð¾Ð¼ÑÐ½ÑÑÑÑ
ÐºÐ½Ð¸Ð³Ñ Ð¸ <a href="https://hal.inria.fr/hal-01094195/document">Introduction to the Calculus of Inductive Constructions</a>.</p>

      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [
          ['$', '$'], ['\\(', '\\)']
        ],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  </script>
  </section>

      </div>

      
  <footer class="footer">
    <section class="container">
      
      
        Â©
        
        2021
         Vasiliy Yorkin 
      
      
      
    </section>
  </footer>


    </main>

    
      
      <script src="https://vyorkin.org/js/coder.min.03b17769f4f91ae35667e1f2a1ca8c16f50562576cf90ff32b3179926914daa5.js" integrity="sha256-A7F3afT5GuNWZ&#43;HyocqMFvUFYlds&#43;Q/zKzF5kmkU2qU="></script>
    

    

    

    

    

    

    

    

    
  </body>

</html>
